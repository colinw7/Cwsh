CONCAT_ID=##concat##
##concat##CEscape.cpp
#include <CEscape.h>
#include <CFile.h>
#include <CDir.h>
#include <COSRead.h>
#include <CStrUtil.h>

using std::string;
using std::vector;
using std::ostream;

#define CTRL_A_s ""
#define CTRL_B_s ""
#define CTRL_C_s ""
#define CTRL_D_s ""
#define CTRL_E_s ""
#define CTRL_F_s ""
#define CTRL_G_s ""
#define CTRL_H_s ""
#define CTRL_I_s "\011"
#define CTRL_J_s "\012"
#define CTRL_K_s ""
#define CTRL_L_s ""
#define CTRL_M_s "\015"
#define CTRL_N_s ""
#define CTRL_O_s ""
#define CTRL_P_s ""
#define CTRL_Q_s "\021"
#define CTRL_R_s ""
#define CTRL_S_s "\023"
#define CTRL_T_s ""
#define CTRL_U_s ""
#define CTRL_V_s ""
#define CTRL_W_s ""
#define CTRL_X_s ""
#define CTRL_Y_s ""
#define CTRL_Z_s ""

#define ESC_c ''
#define ESC_s ""
#define CSI_s "["
#define OSC_s "]"
#define ST_s  "\\"

string
CEscape::
NUL()
{
  return "\000";
}

string
CEscape::
SOH()
{
  return CTRL_A_s;
}

string
CEscape::
STX()
{
  return CTRL_B_s;
}

string
CEscape::
ETX()
{
  return CTRL_C_s;
}

string
CEscape::
EOT()
{
  return CTRL_D_s;
}

string
CEscape::
ENQ()
{
  return CTRL_E_s;
}

string
CEscape::
ACK()
{
  return CTRL_F_s;
}

string
CEscape::
BEL()
{
  return CTRL_G_s;
}

string
CEscape::
BS()
{
  return CTRL_H_s;
}

string
CEscape::
HT()
{
  return CTRL_I_s;
}

string
CEscape::
LF()
{
  return CTRL_J_s;
}

string
CEscape::
VT()
{
  return CTRL_K_s;
}

string
CEscape::
FF()
{
  return CTRL_L_s;
}

string
CEscape::
CR()
{
  return CTRL_M_s;
}

string
CEscape::
SO()
{
  return CTRL_N_s;
}

string
CEscape::
SI()
{
  return CTRL_O_s;
}

string
CEscape::
DLE()
{
  return CTRL_P_s;
}

string
CEscape::
DC1()
{
  return CTRL_Q_s;
}

string
CEscape::
DC2()
{
  return CTRL_R_s;
}

string
CEscape::
DC3()
{
  return CTRL_S_s;
}

string
CEscape::
DC4()
{
  return CTRL_T_s;
}

string
CEscape::
NAK()
{
  return CTRL_U_s;
}

string
CEscape::
SYN()
{
  return CTRL_V_s;
}

string
CEscape::
ETB()
{
  return CTRL_W_s;
}

string
CEscape::
CAN()
{
  return CTRL_X_s;
}

string
CEscape::
EM()
{
  return CTRL_Y_s;
}

string
CEscape::
SUB()
{
  return CTRL_Z_s;
}

string
CEscape::
DEL()
{
  static char c[2] = { 0x7f, 0x00 };

  return &c[0];
}

string
CEscape::
SP()
{
  return " ";
}

string
CEscape::
IND()
{
  return ESC_s "D";
}

string
CEscape::
NEL()
{
  return ESC_s "E";
}

string
CEscape::
HTS()
{
  return ESC_s "H";
}

string
CEscape::
RI()
{
  return ESC_s "M";
}

string
CEscape::
SS2()
{
  return ESC_s "N";
}

string
CEscape::
SS3()
{
  return ESC_s "O";
}

string
CEscape::
DCS()
{
  return ESC_s "P";
}

string
CEscape::
SPA()
{
  return ESC_s "V";
}

string
CEscape::
EPA()
{
  return ESC_s "W";
}

string
CEscape::
SOS()
{
  return ESC_s "X";
}

string
CEscape::
DECID()
{
  return ESC_s "Z";
}

//----------------

// CSI 1t : de-iconify
string
CEscape::
windowOpDeiconify()
{
  return windowOp(WINDOW_OP_DEICONIFY);
}

// CSI 2t : iconify
string
CEscape::
windowOpIconify()
{
  return windowOp(WINDOW_OP_ICONIFY);
}

// CSI 3;<x>;<y>t : move to x,y
string
CEscape::
windowOpMove(int x, int y)
{
  return windowOp(WINDOW_OP_MOVE, CStrUtil::toString(x), CStrUtil::toString(y));
}

// CSI 4;<h>;<w>t : resize to h,w pixels
string
CEscape::
windowOpPixelSize(int h, int w)
{
  return windowOp(WINDOW_OP_PIXEL_SIZE, CStrUtil::toString(h), CStrUtil::toString(w));
}

// CSI 5t : raise
string
CEscape::
windowOpRaise()
{
  return windowOp(WINDOW_OP_RAISE);
}

// CSI 6t : lower
string
CEscape::
windowOpLower()
{
  return windowOp(WINDOW_OP_LOWER);
}

// CSI 7t : refresh
string
CEscape::
windowOpRefresh()
{
  return windowOp(WINDOW_OP_REFRESH);
}

// CSI 8;<h>;<w>t : resize to h,w chars
string
CEscape::
windowOpCharSize(int h, int w)
{
  return windowOp(WINDOW_OP_CHAR_SIZE, CStrUtil::toString(h), CStrUtil::toString(w));
}

// CSI 9;0t : restore maximized window
string
CEscape::
windowOpRestoreMaximized()
{
  return windowOp(WINDOW_OP_MAXIMIZE, "0");
}

// CSI 9;1t : maximize window
string
CEscape::
windowOpMaximize()
{
  return windowOp(WINDOW_OP_MAXIMIZE, "1");
}

// CSI 11t : report state as CSI 1 or CSI 2
string
CEscape::
windowOpReportState()
{
  return windowOp(WINDOW_OP_REPORT_STATE);
}

// CSI 13t : report pos as CSI 3;<x>;<y>t
string
CEscape::
windowOpReportPos()
{
  return windowOp(WINDOW_OP_REPORT_POS);
}

// CSI 14t : report size as CSI 4;<h>;<w>t
string
CEscape::
windowOpReportPixelSize()
{
  return windowOp(WINDOW_OP_REPORT_PIXEL_SIZE);
}

// CSI 18t : report size as CSI 8;<h>;<w>t
string
CEscape::
windowOpReportCharSize()
{
  return windowOp(WINDOW_OP_REPORT_CHAR_SIZE);
}

// CSI 19t : report screen size as CSI 9;<h>;<w>t
string
CEscape::
windowOpReportScreenSize()
{
  return windowOp(WINDOW_OP_REPORT_SCREEN_SIZE);
}

// CSI 20t : report icon label as OSC L label ST
string
CEscape::
windowOpReportIconLabel()
{
  return windowOp(WINDOW_OP_REPORT_ICON_STR);
}

// CSI 21t : report window title as OSC l label ST
string
CEscape::
windowOpReportWindowTitle()
{
  return windowOp(WINDOW_OP_REPORT_TITLE_STR);
}

// CSI 24 ... : resize to 24 or greater lines
string
CEscape::
windowOpResizeNLines(int n)
{
  return windowOp((WindowOp) n);
}

// CSI <op>;<arg1>;<arg2>t : window_op <op>
string
CEscape::
windowOp(WindowOp op, const string &arg1, const string &arg2)
{
  string str = CStrUtil::toString(int(op));

  if (! arg1.empty()) {
    str += ";" + arg1;

    if (! arg2.empty())
      str += ";" + arg2;
  }

  str += "t";

  return CSI(str);
}

bool
CEscape::
decodeWindowOp(const string &str, WindowOp &op, string &arg1, string &arg2)
{
  int len = str.size();

  if (len < 3) return false;

  if (str[0] != ESC_c || str[1] != '[' || str[len - 1] != 't')
    return false;

  int i = 2;

  vector<string> args;

  while (i < len && str[i] != 't') {
    string arg;

    while (i < len && str[i] != ';' && str[i] != 't')
      arg += str[i++];

    if (i < len && str[i] == ';')
      ++i;

    args.push_back(arg);
  }

  uint num_args = args.size();

  if (num_args < 1)
    return false;

  int op_num;

  if (! CStrUtil::toInteger(args[0], &op_num))
    return false;

  op = (WindowOp) op_num;

  if (i != len - 1)
    return false;

  arg1 = (num_args >= 2 ? args[1] : "");
  arg2 = (num_args >= 3 ? args[2] : "");

  return true;
}

string
CEscape::
oscIconWindowTitle(const string &str)
{
  return OSC_s "0;" + str + ST_s;
}

string
CEscape::
oscIconTitle(const string &str)
{
  return OSC_s "1;" + str + ST_s;
}

string
CEscape::
oscWindowTitle(const string &str)
{
  return OSC_s "2;" + str + ST_s;
}

string
CEscape::
oscWindowProp(const string &str)
{
  return OSC_s "3;" + str + ST_s;
}

string
CEscape::
oscColor(int num, const string &str)
{
  return OSC_s "4;" + CStrUtil::toString(num) + ";" + str + ST_s;
}

string
CEscape::
oscFg(const string &str)
{
  return OSC_s "10;" + str + ST_s;
}

string
CEscape::
oscBg(const string &str)
{
  return OSC_s "11;" + str + ST_s;
}

string
CEscape::
oscCursorColor(const string &str)
{
  return OSC_s "12;" + str + ST_s;
}

string
CEscape::
oscFont(const string &str)
{
  return OSC_s "50;" + str + ST_s;
}

//-----------

string
CEscape::
DECSC()
{
  return ESC_s "7";
}

string
CEscape::
DECRC()
{
  return ESC_s "8";
}

string
CEscape::
DECPAM()
{
  return ESC_s "=";
}

string
CEscape::
DECPNM()
{
  return ESC_s ">";
}

string
CEscape::
RIS()
{
  return ESC_s "c";
}

string
CEscape::
DECALN()
{
  return ESC_s "#8";
}

string
CEscape::
ICH(int n)
{
  if (n < 0)
    return CSI_s "@";
  else
    return CSI_s + CStrUtil::toString(n) + "@";
}

string
CEscape::
CUU(int n)
{
  if (n < 0)
    return CSI_s "A";
  else
    return CSI_s + CStrUtil::toString(n) + "A";
}

string
CEscape::
CUD(int n)
{
  if (n < 0)
    return CSI_s "B";
  else
    return CSI_s + CStrUtil::toString(n) + "B";
}

string
CEscape::
CUF(int n)
{
  if (n < 0)
    return CSI_s "C";
  else
    return CSI_s + CStrUtil::toString(n) + "C";
}

string
CEscape::
CUB(int n)
{
  if (n < 0)
    return CSI_s "D";
  else
    return CSI_s + CStrUtil::toString(n) + "D";
}

string
CEscape::
CNL(int n)
{
  if (n < 0)
    return CSI_s "E";
  else
    return CSI_s + CStrUtil::toString(n) + "E";
}

string
CEscape::
CPL(int n)
{
  if (n < 0)
    return CSI_s "F";
  else
    return CSI_s + CStrUtil::toString(n) + "F";
}

string
CEscape::
CHA(int n)
{
  if (n < 0)
    return CSI_s "G";
  else
    return CSI_s + CStrUtil::toString(n) + "G";
}

string
CEscape::
CUP(int row, int col)
{
  if (row < 0 || col < 0)
    return CSI_s "H";
  else
    return CSI_s + CStrUtil::toString(row) + ";" +
                   CStrUtil::toString(col) + "H";
}

string
CEscape::
CHT(int n)
{
  if (n < 0)
    return CSI_s "I";
  else
    return CSI_s + CStrUtil::toString(n) + "I";
}

string
CEscape::
ED(int n)
{
  if (n < 0)
    return CSI_s "J";
  else
    return CSI_s + CStrUtil::toString(n) + "J";
}

string
CEscape::
DECSED(int n)
{
  if (n < 0)
    return CSI_s "?J";
  else
    return CSI_s "?" + CStrUtil::toString(n) + "J";
}

string
CEscape::
EL(int n)
{
  if (n < 0)
    return CSI_s "K";
  else
    return CSI_s + CStrUtil::toString(n) + "K";
}

string
CEscape::
DECSEL(int n)
{
  if (n < 0)
    return CSI_s "?K";
  else
    return CSI_s "?" + CStrUtil::toString(n) + "K";
}

string
CEscape::
IL(int n)
{
  if (n < 0)
    return CSI_s "L";
  else
    return CSI_s + CStrUtil::toString(n) + "L";
}

string
CEscape::
DL(int n)
{
  if (n < 0)
    return CSI_s "M";
  else
    return CSI_s + CStrUtil::toString(n) + "M";
}

string
CEscape::
DCH(int n)
{
  if (n < 0)
    return CSI_s "P";
  else
    return CSI_s + CStrUtil::toString(n) + "P";
}

string
CEscape::
SU(int n)
{
  if (n < 0)
    return CSI_s "S";
  else
    return CSI_s + CStrUtil::toString(n) + "S";
}

string
CEscape::
SD(int n)
{
  if (n < 0)
    return CSI_s "T";
  else
    return CSI_s + CStrUtil::toString(n) + "T";
}

string
CEscape::
ECH(int n)
{
  if (n < 0)
    return CSI_s "X";
  else
    return CSI_s + CStrUtil::toString(n) + "X";
}

string
CEscape::
CBT(int n)
{
  if (n < 0)
    return CSI_s "Z";
  else
    return CSI_s + CStrUtil::toString(n) + "Z";
}

string
CEscape::
HPA(int n)
{
  if (n < 0)
    return CSI_s "`";
  else
    return CSI_s + CStrUtil::toString(n) + "`";
}

string
CEscape::
REP(int n)
{
  if (n < 0)
    return CSI_s "b";
  else
    return CSI_s + CStrUtil::toString(n) + "b";
}

string
CEscape::
DA1(int n)
{
  if (n < 0)
    return CSI_s "c";
  else
    return CSI_s + CStrUtil::toString(n) + "c";
}

string
CEscape::
DA2(int n)
{
  if (n < 0)
    return CSI_s ">c";
  else
    return CSI_s + string(">") + CStrUtil::toString(n) + "c";
}

string
CEscape::
VPA(int n)
{
  if (n < 0)
    return CSI_s "d";
  else
    return CSI_s + CStrUtil::toString(n) + "d";
}

string
CEscape::
HVP(int row, int col)
{
  if (row == 1 && col == 1)
    return CSI_s "f";
  else
    return CSI_s + CStrUtil::toString(row) + ";" +
                   CStrUtil::toString(col) + "f";
}

string
CEscape::
TBC(int n)
{
  if (n < 0)
    return CSI_s "g";
  else
    return CSI_s + CStrUtil::toString(n) + "g";
}

string
CEscape::
SM(int n)
{
  if (n < 0)
    return CSI_s "h";
  else
    return CSI_s + CStrUtil::toString(n) + "h";
}

string
CEscape::
DECSET(int n)
{
  if (n < 0)
    return CSI_s "?h";
  else
    return CSI_s "?" + CStrUtil::toString(n) + "h";
}

string
CEscape::
DECSET(int n1, int n2)
{
  return CSI_s "?" + CStrUtil::toString(n1) + ";" + CStrUtil::toString(n2) + "h";
}

string
CEscape::
MC(int n)
{
  if (n < 0)
    return CSI_s "i";
  else
    return CSI_s + CStrUtil::toString(n) + "i";
}

string
CEscape::
DECMC(int n)
{
  if (n < 0)
    return CSI_s "?i";
  else
    return CSI_s "?" + CStrUtil::toString(n) + "i";
}

string
CEscape::
RM(int n)
{
  if (n < 0)
    return CSI_s "l";
  else
    return CSI_s + CStrUtil::toString(n) + "l";
}

string
CEscape::
DECRST(int n)
{
  if (n < 0)
    return CSI_s "?l";
  else
    return CSI_s "?" + CStrUtil::toString(n) + "l";
}

string
CEscape::
DECRST(int n1, int n2)
{
  return CSI_s "?" + CStrUtil::toString(n1) + ";" + CStrUtil::toString(n2) + "l";
}

string
CEscape::
SGR(int n)
{
  if (n < 0)
    return CSI_s "m";
  else
    return CSI_s + CStrUtil::toString(n) + "m";
}

string
CEscape::
SGR(int n, int r, int g, int b)
{
  return CSI_s + CStrUtil::toString(n) + ";" +
                 CStrUtil::toString(r) + ";" +
                 CStrUtil::toString(g) + ";" +
                 CStrUtil::toString(b) + "m";
}

string
CEscape::
DSR(int n)
{
  if (n < 0)
    n = 0;

  return CSI_s + CStrUtil::toString(n) + "n";
}

string
CEscape::
DECDSR(int n)
{
  if (n < 0)
    n = 0;

  return CSI_s "?" + CStrUtil::toString(n) + "n";
}

string
CEscape::
DECSTR()
{
  return CSI_s "!p";
}

string
CEscape::
DECSCL(int n, int m)
{
  if (n < 0)
    n = 0;

  return CSI_s + CStrUtil::toString(n) + ";" +
                 CStrUtil::toString(m) + "\"p";
}

string
CEscape::
DECSTBM(int top, int bottom)
{
  if (top < 0 || bottom < 0)
    return CSI_s "r";
  else
    return CSI_s + CStrUtil::toString(top) + ";" +
                   CStrUtil::toString(bottom) + "r";
}

string
CEscape::
DECCARA(int top, int left, int bottom, int right, int attr)
{
  if (top    < 0) top    = 0;
  if (left   < 0) left   = 0;
  if (bottom < 0) bottom = 0;
  if (right  < 0) right  = 0;
  if (attr   < 0) attr   = 0;

  return CSI_s + CStrUtil::toString(top   ) + ";" +
                 CStrUtil::toString(left  ) + ";";
                 CStrUtil::toString(bottom) + ";";
                 CStrUtil::toString(right ) + ";";
                 CStrUtil::toString(attr  ) + "$r";
}

string
CEscape::
SC()
{
  return CSI_s "s";
}

string
CEscape::
DECRARA(int top, int left, int bottom, int right, int attr)
{
  if (top    < 0) top    = 0;
  if (left   < 0) left   = 0;
  if (bottom < 0) bottom = 0;
  if (right  < 0) right  = 0;
  if (attr   < 0) attr   = 0;

  return CSI_s + CStrUtil::toString(top   ) + ";" +
                 CStrUtil::toString(left  ) + ";";
                 CStrUtil::toString(bottom) + ";";
                 CStrUtil::toString(right ) + ";";
                 CStrUtil::toString(attr  ) + "$t";
}

string
CEscape::
SC1()
{
  return CSI_s "u";
}

string
CEscape::
DECCRA(int src_top, int src_left, int src_bottom, int src_right, int src,
       int dst_top, int dst_left, int dst)
{
  if (src_top    < 0) src_top    = 0;
  if (src_left   < 0) src_left   = 0;
  if (src_bottom < 0) src_bottom = 0;
  if (src_right  < 0) src_right  = 0;
  if (src        < 0) src        = 0;
  if (dst_top    < 0) src_top    = 0;
  if (dst_left   < 0) src_left   = 0;
  if (dst        < 0) dst        = 0;

  return CSI_s + CStrUtil::toString(src_top   ) + ";" +
                 CStrUtil::toString(src_left  ) + ";";
                 CStrUtil::toString(src_bottom) + ";";
                 CStrUtil::toString(src_right ) + ";";
                 CStrUtil::toString(src       ) + ";";
                 CStrUtil::toString(dst_top   ) + ";";
                 CStrUtil::toString(dst_left  ) + ";";
                 CStrUtil::toString(dst       ) + "$v";
}

string
CEscape::
DECEFR(int top, int left, int bottom, int right)
{
  if (top    < 0) top    = 0;
  if (left   < 0) left   = 0;
  if (bottom < 0) bottom = 0;
  if (right  < 0) right  = 0;

  return CSI_s + CStrUtil::toString(top   ) + ";" +
                 CStrUtil::toString(left  ) + ";";
                 CStrUtil::toString(bottom) + ";";
                 CStrUtil::toString(right ) + "'w";
}

string
CEscape::
DECREQTPARM(int n)
{
  if (n < 0) n = 0;

  return CSI_s + CStrUtil::toString(n) + "x";
}

string
CEscape::
DECSACE(int n)
{
  if (n < 0) n = 0;

  return CSI_s + CStrUtil::toString(n) + "*x";
}

string
CEscape::
DECFRA(int c, int top, int left, int bottom, int right)
{
  if (c      < 0) c      = 32;
  if (top    < 0) top    = 0;
  if (left   < 0) left   = 0;
  if (bottom < 0) bottom = 0;
  if (right  < 0) right  = 0;

  return CSI_s + CStrUtil::toString(c     ) + ";" +
                 CStrUtil::toString(top   ) + ";";
                 CStrUtil::toString(left  ) + ";";
                 CStrUtil::toString(bottom) + ";";
                 CStrUtil::toString(right ) + "$x";
}

string
CEscape::
DECELR(int n1, int n2)
{
  if (n1 < 0) n1 = 0;
  if (n2 < 0) n2 = 0;

  return CSI_s + CStrUtil::toString(n1 ) + ";" +
                 CStrUtil::toString(n2) + "'z";
}

string
CEscape::
DECERA(int top, int left, int bottom, int right)
{
  if (top    < 0) top    = 0;
  if (left   < 0) left   = 0;
  if (bottom < 0) bottom = 0;
  if (right  < 0) right  = 0;

  return CSI_s + CStrUtil::toString(top   ) + ";";
                 CStrUtil::toString(left  ) + ";";
                 CStrUtil::toString(bottom) + ";";
                 CStrUtil::toString(right ) + "$z";
}

string
CEscape::
DECSLE(int n)
{
  if (n < 0) n = 0;

  return CSI_s + CStrUtil::toString(n) + "'{";
}

string
CEscape::
DECSERA(int top, int left, int bottom, int right)
{
  if (top    < 0) top    = 0;
  if (left   < 0) left   = 0;
  if (bottom < 0) bottom = 0;
  if (right  < 0) right  = 0;

  return CSI_s + CStrUtil::toString(top   ) + ";";
                 CStrUtil::toString(left  ) + ";";
                 CStrUtil::toString(bottom) + ";";
                 CStrUtil::toString(right ) + "${";
}

string
CEscape::
DECRQLP(int n)
{
  if (n < 0) n = 0;

  return CSI_s + CStrUtil::toString(n) + "'|";
}

void
CEscape::
APC(ostream &os, const string &str)
{
  os << APC(str);
}

string
CEscape::
APC(const string &str)
{
  return ESC_s "_" + str + ESC_s "\\";
}

// ESC[ !?>= <n> "`$*& @ABCDEFGHIKMLMPRSTXZ`bcdfghilmnpqrstuvwxyz{|
//
void
CEscape::
CSI(ostream &os, const string &str)
{
  os << CSI(str);
}

string
CEscape::
CSI(const string &str)
{
  return ESC_s "[" + str;
}

//-------------

static bool parseInteger
             (const vector<string> &words, int pos, int *i, bool opt=false);
static bool checkNumArgs
             (const vector<string> &args, int num, bool opt=false);

string
CEscape::
stringToEscape(const string &str)
{
  int i1, i2, i3, i4, i5;

  vector<string> words;

  CStrUtil::addFields(str, words, ";");

  uint num_words = words.size();

  if      (words[0] == "NUL") return NUL();
  else if (words[0] == "SOH") return SOH();  // Ctrl A
  else if (words[0] == "STX") return STX();  // Ctrl B
  else if (words[0] == "ETX") return ETX();  // Ctrl C
  else if (words[0] == "EOT") return EOT();  // Ctrl D
  else if (words[0] == "ENQ") return ENQ();  // Ctrl E
  else if (words[0] == "ACK") return ACK();  // Ctrl F
  else if (words[0] == "BEL") return BEL();  // Ctrl G
  else if (words[0] == "BS" ) return BS ();  // Ctrl H
  else if (words[0] == "HT" ) return HT ();  // Ctrl I
  else if (words[0] == "TAB") return HT ();  // Ctrl I
  else if (words[0] == "LF" ) return LF ();  // Ctrl J
  else if (words[0] == "NL" ) return LF ();  // Ctrl J
  else if (words[0] == "VT" ) return VT ();  // Ctrl K
  else if (words[0] == "FF" ) return FF ();  // Ctrl L
  else if (words[0] == "NP" ) return FF ();  // Ctrl L
  else if (words[0] == "CR" ) return CR ();  // Ctrl M
  else if (words[0] == "SO" ) return SO ();  // Ctrl N
  else if (words[0] == "SI" ) return SI ();  // Ctrl O
  else if (words[0] == "DLE") return DLE();
  else if (words[0] == "DC1") return DC1();
  else if (words[0] == "DC2") return DC2();
  else if (words[0] == "DC3") return DC3();
  else if (words[0] == "DC4") return DC4();
  else if (words[0] == "NAK") return NAK();
  else if (words[0] == "SYN") return SYN();
  else if (words[0] == "ETB") return ETB();
  else if (words[0] == "CAN") return CAN();
  else if (words[0] == "EM" ) return EM();
  else if (words[0] == "SUB") return SUB();
  else if (words[0] == "DEL") return DEL();

  else if (words[0] == "SP" ) return SP();

  else if (words[0] == "IND") return IND();
  else if (words[0] == "NEL") return NEL();
  else if (words[0] == "HTS") return HTS();
  else if (words[0] == "RI" ) return RI();
  else if (words[0] == "SS2") return SS2();
  else if (words[0] == "SS3") return SS3();
  else if (words[0] == "DCS") return DCS();
  else if (words[0] == "SPA") return SPA();
  else if (words[0] == "EPA") return EPA();
  else if (words[0] == "SOS") return SOS();
  else if (words[0] == "DECID") return DECID();

  else if (words[0] == "WIN") return stringWinOpToEscape(words);
  else if (words[0] == "CSI") return stringCSIOpToEscape(words);
  else if (words[0] == "OSC") return stringOSCOpToEscape(words);

  else if (words[0] == "DECSC" ) return DECSC();
  else if (words[0] == "DECRC" ) return DECRC();
  else if (words[0] == "DECPAM") return DECPAM();
  else if (words[0] == "DECPNM") return DECPNM();

  else if (words[0] == "SCS") return stringSCSOpToEscape(words);

  else if (words[0] == "RIS") return RIS();

  else if (words[0] == "DECALN") return DECALN();

  else if (words[0] == "ICH") {
    if (parseInteger(words, 1, &i1, true))
      return ICH(i1);
    else
      return ICH();
  }
  else if (words[0] == "CUU") {
    if (parseInteger(words, 1, &i1, true))
      return CUU(i1);
    else
      return CUU();
  }
  else if (words[0] == "CUD") {
    if (parseInteger(words, 1, &i1, true))
      return CUD(i1);
    else
      return CUD();
  }
  else if (words[0] == "CUF") {
    if (parseInteger(words, 1, &i1, true))
      return CUF(i1);
    else
      return CUF();
  }
  else if (words[0] == "CUB") {
    if (parseInteger(words, 1, &i1, true))
      return CUB(i1);
    else
      return CUB();
  }
  else if (words[0] == "CNL") {
    if (parseInteger(words, 1, &i1, true))
      return CNL(i1);
    else
      return CNL();
  }
  else if (words[0] == "CPL") {
    if (parseInteger(words, 1, &i1, true))
      return CPL(i1);
    else
      return CPL();
  }
  else if (words[0] == "CHA") {
    if (parseInteger(words, 1, &i1, true))
      return CHA(i1);
    else
      return CHA();
  }
  else if (words[0] == "CUP") {
    if (parseInteger(words, 1, &i1, true) &&
        parseInteger(words, 2, &i2, true))
      return CUP(i1, i2);
    else
      return CUP();
  }
  else if (words[0] == "CHT") {
    if (parseInteger(words, 1, &i1, true))
      return CHT(i1);
    else
      return CHT();
  }
  else if (words[0] == "ED") {
    if (parseInteger(words, 1, &i1, true))
      return ED(i1);
    else
      return ED();
  }
  else if (words[0] == "DECSED") {
    if (parseInteger(words, 1, &i1, true))
      return DECSED(i1);
    else
      return DECSED();
  }
  else if (words[0] == "EL") {
    if (parseInteger(words, 1, &i1, true))
      return EL(i1);
    else
      return EL();
  }
  else if (words[0] == "DECSEL") {
    if (parseInteger(words, 1, &i1, true))
      return DECSEL(i1);
    else
      return DECSEL();
  }
  else if (words[0] == "IL") {
    if (parseInteger(words, 1, &i1, true))
      return IL(i1);
    else
      return IL();
  }
  else if (words[0] == "DL") {
    if (parseInteger(words, 1, &i1, true))
      return DL(i1);
    else
      return DL();
  }
  else if (words[0] == "DCH") {
    if (parseInteger(words, 1, &i1, true))
      return DCH(i1);
    else
      return DCH();
  }
  else if (words[0] == "SU") {
    if (parseInteger(words, 1, &i1, true))
      return SU(i1);
    else
      return SU();
  }
  else if (words[0] == "SD") {
    if (parseInteger(words, 1, &i1, true))
      return SD(i1);
    else
      return SD();
  }
  else if (words[0] == "ECH") {
    if (parseInteger(words, 1, &i1, true))
      return ECH(i1);
    else
      return ECH();
  }
  else if (words[0] == "CBT") {
    if (parseInteger(words, 1, &i1, true))
      return CBT(i1);
    else
      return CBT();
  }
  else if (words[0] == "HPA") {
    if (parseInteger(words, 1, &i1, true))
      return HPA(i1);
    else
      return HPA();
  }
  else if (words[0] == "REP") {
    if (parseInteger(words, 1, &i1, true))
      return REP(i1);
    else
      return REP();
  }
  else if (words[0] == "DA1") {
    if (parseInteger(words, 1, &i1, true))
      return DA1(i1);
    else
      return DA1();
  }
  else if (words[0] == "DA2") {
    if (parseInteger(words, 1, &i1, true))
      return DA2(i1);
    else
      return DA2();
  }
  else if (words[0] == "VPA") {
    if (parseInteger(words, 1, &i1, true))
      return VPA(i1);
    else
      return VPA();
  }
  else if (words[0] == "HVP") {
    if (parseInteger(words, 1, &i1, true) &&
        parseInteger(words, 2, &i2, true))
      return HVP(i1, i2);
    else
      return HVP();
  }
  else if (words[0] == "TBC") {
    if (parseInteger(words, 1, &i1, true))
      return TBC(i1);
    else
      return TBC();
  }
  else if (words[0] == "SM") {
    if (parseInteger(words, 1, &i1, true))
      return SM(i1);
    else
      return SM();
  }
  else if (words[0] == "DECSET") {
    if (parseInteger(words, 1, &i1, true))
      return DECSET(i1);
    else
      return DECSET();
  }
  else if (words[0] == "MC") {
    if (parseInteger(words, 1, &i1, true))
      return MC(i1);
    else
      return MC();
  }
  else if (words[0] == "DECMC") {
    if (parseInteger(words, 1, &i1, true))
      return DECMC(i1);
    else
      return DECMC();
  }
  else if (words[0] == "RM") {
    if (parseInteger(words, 1, &i1, true))
      return RM(i1);
    else
      return RM();
  }
  else if (words[0] == "DECRST") {
    if (parseInteger(words, 1, &i1, true))
      return DECRST(i1);
    else
      return DECRST();
  }
  else if (words[0] == "SGR") {
    if (parseInteger(words, 1, &i1, true)) {
      if (i1 == 38 || i1 == 48) {
        int r, g, b;

        if (parseInteger(words, 2, &r, true) &&
            parseInteger(words, 3, &g, true) &&
            parseInteger(words, 4, &b, true))
          return SGR(i1,r,g,b);

        return SGR(i1);
      }
      else
        return SGR(i1);
    }
    else
      return SGR();
  }
  else if (words[0] == "DSR") {
    if (! parseInteger(words, 1, &i1, true))
      i1 = 0;

    return DSR(i1);
  }
  else if (words[0] == "DECDSR") {
    if (! parseInteger(words, 1, &i1, true))
      i1 = 0;

    return DECDSR(i1);
  }
  else if (words[0] == "DECSTR") {
    return DECSTR();
  }
  else if (words[0] == "DECSCL") {
    if (parseInteger(words, 1, &i1, true) &&
        parseInteger(words, 2, &i2, true))
      return DECSCL(i1, i2);
    else
      return DECSCL();
  }
  else if (words[0] == "DECSTBM") {
    if (parseInteger(words, 1, &i1, true) &&
        parseInteger(words, 2, &i2, true))
      return DECSTBM(i1, i2);
    else
      return DECSTBM();
  }
  else if (words[0] == "DECCARA") {
    if (parseInteger(words, 1, &i1, true) &&
        parseInteger(words, 2, &i2, true) &&
        parseInteger(words, 3, &i3, true) &&
        parseInteger(words, 4, &i4, true) &&
        parseInteger(words, 5, &i5, true))
      return DECCARA(i1, i2, i3, i4, i5);
    else
      return DECCARA();
  }
  else if (words[0] == "SC") {
    return SC();
  }
  else if (words[0] == "DECRARA") {
    if (parseInteger(words, 1, &i1, true) &&
        parseInteger(words, 2, &i2, true) &&
        parseInteger(words, 3, &i3, true) &&
        parseInteger(words, 4, &i4, true) &&
        parseInteger(words, 5, &i5, true))
      return DECRARA(i1, i2, i3, i4, i5);
    else
      return DECRARA();
  }
  else if (words[0] == "DECREQTPARM") {
    if (parseInteger(words, 1, &i1, true))
      return DECREQTPARM(i1);
    else
      return DECREQTPARM();
  }
  else if (words[0] == "DECELR") {
    if (parseInteger(words, 1, &i1, true) &&
        parseInteger(words, 2, &i2, true))
      return DECELR(i1, i2);
    else
      return DECELR();
  }
  else if (words[0] == "DECSLE") {
    if (parseInteger(words, 1, &i1, true))
      return DECSLE(i1);
    else
      return DECSLE();
  }
  else if (words[0] == "DECRQLP") {
    if (parseInteger(words, 1, &i1, true))
      return DECRQLP(i1);
    else
      return DECRQLP();
  }

  else if (words[0] == "s")
    return words[1];
  else if (words[0] == "srep") {
    int n;

    if (! parseInteger(words, 1, &n, false))
      n = 1;

    string s;

    for (int i = 0; i < n; ++i)
      s +=  words[2];

    return s;
  }
  else if (words[0] == "file") {
    CFile file(words[1]);

    string text;

    string line;

    while (file.readLine(line))
      text += line + "\n";

    return text;
  }
  else if (words[0] == "paste") {
    if (num_words > 1)
      return APC("<paste text=\"" + words[1] + "\"/>");
    else
      return APC("<paste/>");
  }
  else if (words[0] == "dir") {
    if (num_words > 1)
      return APC("<state dir=\"" + words[1] + "\"/>");
    else
      return APC("<state dir=\"" + CDir::getCurrent() + "\"/>");
  }
  else if (words[0] == "pixel") {
    if (num_words > 3)
      return APC("<pixel x=\"" + words[1] + "\" y=\"" + words[2] + "\" color=\"" +
                 words[3] + "\"/>");
    else
      return "";
  }
  else if (words[0] == "line") {
    if (num_words > 5)
      return APC("<line x1=\"" + words[1] + "\" y1=\"" + words[2] + "\" "
                 "x2=\"" + words[3] + "\" y2=\"" + words[4] + "\" color=\"" + words[5] + "\"/>");
    else
      return "";
  }
  else {
    std::cerr << "Invalid command: " <<  words[0] << std::endl;
    return "";
  }
}

string
CEscape::
stringWinOpToEscape(const vector<string> &words)
{
  if (words.size() < 2) {
    std::cerr << "Wrong number of arguments: got " <<
                 words.size() << " need at least " << 2 << std::endl;
    return "";
  }

  if      (words[1] == "deiconify") { // 1
    return windowOpDeiconify();
  }
  else if (words[1] == "iconify") { // 2
    return windowOpIconify();
  }
  else if (words[1] == "move") { // 3
    int x, y;

    if (! parseInteger(words, 2, &x) || ! parseInteger(words, 3, &y)) {
      return "";
    }

    return windowOpMove(x, y);
  }
  else if (words[1] == "pixel_resize") { // 4
    int h, w;

    if (! parseInteger(words, 2, &h) || ! parseInteger(words, 3, &w))
      return "";

    return windowOpPixelSize(h, w);
  }
  else if (words[1] == "raise") { // 5
    return windowOpRaise();
  }
  else if (words[1] == "lower") { // 6
    return windowOpLower();
  }
  else if (words[1] == "refresh") { // 7
    return windowOpRefresh();
  }
  else if (words[1] == "resize" || words[1] == "char_resize") { // 8
    int h, w;

    if (! parseInteger(words, 2, &h) || ! parseInteger(words, 3, &w))
      return "";

    return windowOpCharSize(h, w);
  }
  else if (words[1] == "restore_maximized") { // 9;0
    return windowOpRestoreMaximized();
  }
  else if (words[1] == "maximize") { // 9;1
    return windowOpMaximize();
  }
  else if (words[1] == "report_state") { // 11
    return windowOpReportState();
  }
  else if (words[1] == "report_pos") { // 13
    return windowOpReportPos();
  }
  else if (words[1] == "report_pixel_size") { // 14
    return windowOpReportPixelSize();
  }
  else if (words[1] == "report_size" || words[1] == "report_char_size") { // 18
    return windowOpReportCharSize();
  }
  else if (words[1] == "report_screen_size") { // 19
    return windowOpReportScreenSize();
  }
  else if (words[1] == "report_icon_label") { // 20
    return windowOpReportIconLabel();
  }
  else if (words[1] == "report_window_title") { // 21
    return windowOpReportWindowTitle();
  }
  else if (words[1] == "resize_lines") { // 24
    int n;

    if (! parseInteger(words, 2, &n))
      return "";

    if (n < 24) {
      std::cerr << "Invalid number of lines: " <<  n << std::endl;
      return "";
    }

    return windowOpResizeNLines(n);
  }
  else {
    std::cerr << "Invalid WIN op: " <<  words[1] << std::endl;
    return "";
  }
}

string
CEscape::
stringCSIOpToEscape(const vector<string> &words)
{
  uint num_words = words.size();

  if (num_words == 1)
    return CSI_s;

  string str = CSI_s;

  for (uint i = 1; i < num_words; ++i)
    str += words[i];

  return str;
}

string
CEscape::
stringOSCOpToEscape(const vector<string> &words)
{
  if (! checkNumArgs(words, 2)) return "";

  if      (words[1] == "icon_window_title") { // 0
    if (! checkNumArgs(words, 3)) return "";

    return oscIconWindowTitle(words[2]);
  }
  else if (words[1] == "icon_title") { // 1
    if (! checkNumArgs(words, 3)) return "";

    return oscIconTitle(words[2]);
  }
  else if (words[1] == "window_title") { // 2
    if (! checkNumArgs(words, 3)) return "";

    return oscWindowTitle(words[2]);
  }
  else if (words[1] == "window_prop") { // 3
    if (! checkNumArgs(words, 3)) return "";

    return oscWindowProp(words[2]);
  }
  else if (words[1] == "color") { // 4
    int n;

    if (! parseInteger(words, 2, &n)) return "";

    if (! checkNumArgs(words, 4)) return "";

    return oscColor(n, words[3]);
  }
  else if (words[1] == "fg") { // 10
    if (! checkNumArgs(words, 3)) return "";

    return oscFg(words[2]);
  }
  else if (words[1] == "bg") { // 11
    if (! checkNumArgs(words, 3)) return "";

    return oscBg(words[2]);
  }
  else if (words[1] == "cursor_color") {  // 12
    if (! checkNumArgs(words, 3)) return "";

    return oscCursorColor(words[2]);
  }
  else if (words[1] == "font") { // 50
    if (! checkNumArgs(words, 3)) return "";

    return oscFont(words[2]);
  }
  else {
    std::cerr << "Invalid OSC op: " <<  words[1] << std::endl;
    return "";
  }
}

string
CEscape::
stringSCSOpToEscape(const vector<string> &words)
{
  if (! checkNumArgs(words, 3, 3)) return "";

  string str;

  if      (words[1] == "0") {
    str += "(";
    str += words[2][0];
    str += ")B";
    str += SI();
  }
  else if (words[1] == "1") {
    str += ")";
    str += words[2][0];
    str += "(B";
    str += SO();
  }

  return str;
}

string
CEscape::
imageToEscape(const string &filename, int size, int x1, int y1, int x2, int y2)
{
  string str;

  str  = "<image ";
  str += "filename=\"" + filename + "\" ";
  str += "size=\"" + CStrUtil::toString(size) + "\" ";
  str += "x1=\"" + CStrUtil::toString(x1) + "\" ";
  str += "y1=\"" + CStrUtil::toString(y1) + "\" ";
  str += "x2=\"" + CStrUtil::toString(x2) + "\" ";
  str += "y2=\"" + CStrUtil::toString(y2) + "\"";
  str += "/>";

  return CEscape::APC(str);
}

string
CEscape::
imageToEscape(const string &filename, int size)
{
  string str;

  str  = "<image ";
  str += "filename=\"" + filename + "\" ";
  str += "size=\"" + CStrUtil::toString(size) + "\"";
  str += "/>";

  return CEscape::APC(str);
}

string
CEscape::
pixelPointToEscape(int x, int y, const string &color)
{
  string str;

  str  = "<pixel ";
  str += "x=\"" + CStrUtil::toString(x) + "\" ";
  str += "y=\"" + CStrUtil::toString(y) + "\" ";
  str += "color=\"" + color + "\"";
  str += "/>";

  return CEscape::APC(str);
}

string
CEscape::
pixelLineToEscape(int x1, int y1, int x2, int y2, const string &color)
{
  string str;

  str  = "<line ";
  str += "x1=\"" + CStrUtil::toString(x1) + "\" ";
  str += "y1=\"" + CStrUtil::toString(y1) + "\" ";
  str += "x2=\"" + CStrUtil::toString(x2) + "\" ";
  str += "y2=\"" + CStrUtil::toString(y2) + "\" ";
  str += "color=\"" + color + "\"";
  str += "/>";

  return CEscape::APC(str);
}

string
CEscape::
linkToEscape(const string &name, const string &path, const string &type)
{
  string str;

  str  = "<link ";
  str += "name=\"" + name + "\" ";
  str += "dir=\""  + path + "\" ";
  str += "type=\"" + type + "\" ";
  str += "/>";

  return CEscape::APC(str);
}

string
CEscape::
commandToEscape(const string &name, const string &dir, bool start)
{
  string str;

  str  = "<command ";
  str += "name=\"" + name + "\" ";
  str += "dir=\""  + dir + "\" ";
  str += "start=\""  + CStrUtil::toString(start) + "\" ";
  str += "/>";

  return CEscape::APC(str);
}

bool
CEscape::
getWindowCharSize(int *rows, int *cols)
{
  // get window char size

  COSRead::write(0, CEscape::windowOpReportCharSize().c_str());

  std::string result = readResult();

  std::vector<std::string> args;

  if (parseEscape(result, args)) {
    uint num_args = args.size();

    if (num_args == 3 && CStrUtil::isInteger(args[0]) && CStrUtil::isInteger(args[1])) {
      *rows = CStrUtil::toInteger(args[1]);
      *cols = CStrUtil::toInteger(args[2]);

      return true;
    }
  }

  return false;
}

bool
CEscape::
getWindowPixelSize(int *width, int *height)
{
  // get window pixel size

  COSRead::write(0, CEscape::windowOpReportPixelSize().c_str());

  std::string result = readResult();

  std::vector<std::string> args;

  if (parseEscape(result, args)) {
    uint num_args = args.size();

    if (num_args == 3 && CStrUtil::isInteger(args[0]) && CStrUtil::isInteger(args[1])) {
      *width  = CStrUtil::toInteger(args[2]);
      *height = CStrUtil::toInteger(args[1]);

      return true;
    }
  }

  return false;
}

std::string
CEscape::
readResult()
{
  std::string result;

  if (COSRead::wait_read(0, 1, 0))
    COSRead::read(0, result);

  return result;
}

bool
CEscape::
parseEscape(const std::string &str, std::vector<std::string> &args)
{
  int len = str.size();

  if (len < 3) return false;

  if (str[0] != '' || str[1] != '[' || ! isalpha(str[len - 1]))
    return false;

  int i = 2;

  while (i < len && ! isalpha(str[i])) {
    std::string arg;

    while (i < len && str[i] != ';' && ! isalpha(str[i]))
      arg += str[i++];

    if (i < len && str[i] == ';')
      ++i;

    args.push_back(arg);
  }

  return true;
}

bool
CEscape::
parseMouse(const string &str, int *button, int *x, int *y, bool *release)
{
  if (str.size() != 6) return false;

  if (str[0] != '' || str[1] != '[' || str[2] != 'M')
    return false;

  *button  = str[3] - 32;
  *x       = str[4] - 32;
  *y       = str[5] - 32;
  *release = (*button == 3);

  if (*release)
    *button = 1;

  return true;
}

//------------

static bool
parseInteger(const vector<string> &words, int pos, int *i, bool opt)
{
  if (! checkNumArgs(words, pos + 1, opt)) return false;

  if (! CStrUtil::toInteger(words[pos], i)) {
    if (! opt)
      std::cerr << "Invalid integer: " <<  words[pos] << std::endl;
    return false;
  }

  return true;
}

static bool
checkNumArgs(const vector<string> &args, int num, bool opt)
{
  if ((int) args.size() < num) {
    if (! opt)
      std::cerr << "Wrong number of arguments: got " <<
                   args.size() << " need at least " << num + 1 << std::endl;

    return false;
  }

  return true;
}
##concat##CFileMatch.cpp
#include <CFileMatch.h>

#include <CDir.h>
#include <CStrUtil.h>
#include <CGlob.h>

CFileMatch::
CFileMatch() :
 only_exec_(false)
{
}

CFileMatch::
~CFileMatch()
{
  GlobList::iterator pglob1 = ignore_patterns_.begin();
  GlobList::iterator pglob2 = ignore_patterns_.end();

  for ( ; pglob1 != pglob2; ++pglob1)
    delete *pglob1;
}

void
CFileMatch::
addIgnorePattern(const std::string &pattern)
{
  CGlob *glob = new CGlob(pattern);

  ignore_patterns_.push_back(glob);
}

std::string
CFileMatch::
mostMatchPrefix(const std::string &prefix)
{
  std::vector<std::string> files;

  if (! CFileMatch::matchPrefix(prefix, files))
    return prefix;

  return CStrUtil::mostMatch(files);
}

std::string
CFileMatch::
mostMatchPattern(const std::string &pattern)
{
  std::vector<std::string> files;

  if (! CFileMatch::matchPattern(pattern, files))
    return pattern;

  return CStrUtil::mostMatch(files);
}

bool
CFileMatch::
matchPrefix(const std::string &prefix, std::vector<std::string> &files)
{
  std::string pattern = prefix + "*";

  if (! matchPattern(pattern, files))
    return false;

  return true;
}

bool
CFileMatch::
matchPattern(const std::string &pattern, std::vector<std::string> &files)
{
  CStrWords words = CStrUtil::toFields(pattern, "/");

  int num_words = words.size();

  if (num_words == 0)
    return false;

  std::vector<std::string> words1;

  int i = 0;

  for ( ; i < num_words; i++) {
    std::string word1 = words[i].getWord();;
    std::string word2;

    if (CFile::expandTilde(word1, word2))
      words1.push_back(word2);
    else
      words1.push_back(word1);
  }

  i = 0;

  while (i < num_words && words1[i].size() == 0)
    i++;

  if (i >= num_words)
    return false;

  if (pattern.size() > 0 && pattern[0] == '/')
    files.push_back("/");
  else
    files.push_back("");

  for ( ; i < num_words; i++) {
    if (words1[i].size() == 0)
      continue;

    std::vector< std::vector<std::string> > files2_array;

    int num_files = files.size();

    for (int j = 0; j < num_files; j++) {
      if (files[j] != "") {
        if (! CFile::exists(files[j]) || ! CFile::isDirectory(files[j]))
          continue;

        CDir::enter(files[j]);
      }

      std::vector<std::string> files1;

      matchCurrentDir(words1[i], files1);

      if (files1.size() > 0) {
        std::vector<std::string> files2;

        int num_files1 = files1.size();

        for (int k = 0; k < num_files1; k++) {
          if (words1[i][0] != '.' &&
              (files1[k].size() > 0 && files1[k][0] == '.'))
            continue;

          std::string file = files[j];

          if (file.size() > 0 && file[file.size() - 1] != '/')
            file += "/";

          file += files1[k];

          files2.push_back(file);
        }

        files2_array.push_back(files2);
      }

      if (files[j] != "")
        CDir::leave();
    }

    files.clear();

    int num_files2_array = files2_array.size();

    for (int j = 0; j < num_files2_array; j++)
      copy(files2_array[j].begin(), files2_array[j].end(),
           back_inserter(files));
  }

  int num_files = files.size();

  std::string word;

  for (i = 0; i < num_files; i++) {
    if (CFile::addTilde(files[i], word))
      files[i] = word;
  }

  return true;
}

bool
CFileMatch::
matchCurrentDir(const std::string &pattern, std::vector<std::string> &files)
{
  if (pattern == "." || pattern == "..") {
    files.push_back(pattern);

    return true;
  }

  if (CFile::exists(pattern)) {
    files.push_back(pattern);

    return true;
  }

  CDir dir(".");

  CGlob glob(pattern);

  glob.setAllowOr(false);
  glob.setAllowNonPrintable(true);

  std::vector<std::string> filenames;

  (void) dir.getFilenames(filenames);

  int num_filenames = filenames.size();

  for (int i = 0; i < num_filenames; i++) {
    const std::string &fileName = filenames[i];

    if (isIgnoreFile(fileName))
      continue;

    if (only_exec_ && ! CFile::isExecutable(fileName))
      continue;

    if (glob.compare(fileName))
      files.push_back(fileName);
  }

  return true;
}

bool
CFileMatch::
isIgnoreFile(const std::string &fileName)
{
  GlobList::iterator pglob1 = ignore_patterns_.begin();
  GlobList::iterator pglob2 = ignore_patterns_.end();

  for ( ; pglob1 != pglob2; ++pglob1)
    if ((*pglob1)->compare(fileName))
      return true;

  return false;
}
##concat##CPathList.cpp
#include <CPathList.h>

#include <CFile.h>
#include <CFileMatch.h>

#include <COSEnv.h>
#include <CStrUtil.h>

CPathList::
CPathList() {
}

void
CPathList::
add(const std::string &dir)
{
  dirs_.push_back(dir);
}

void
CPathList::
addEnvValue(const std::string &name)
{
  if (! CEnvInst.exists(name))
    return;

  std::string path = CEnvInst.get(name);

  CStrWords words = CStrUtil::toFields(path, ":");

  int num_words = words.size();

  for (int i = 0; i < num_words; i++)
    dirs_.push_back(words[i].getWord());
}

void
CPathList::
remove(const std::string &dir)
{
  dirs_.remove(dir);
}

void
CPathList::
clear()
{
  dirs_.clear();
}

bool
CPathList::
search(const std::string &file, std::string &path)
{
  std::string file1;

  if (! CFile::expandTilde(file, file1))
    file1 = file;

  if (file1.size() > 0 && file1[0] == '/') {
    CFile file2(file1);

    if (file2.exists() && file2.isRegular() && file2.isExecutable()) {
      path = file2.getPath();

      return true;
    }

    return false;
  }

  CPathDirList::iterator p1 = dirs_.begin();
  CPathDirList::iterator p2 = dirs_.end();

  for ( ; p1 != p2; ++p1) {
    path = *p1 + "/" + file;

    CFile file(path);

    if (file.exists() && file.isRegular() && file.isExecutable())
      return true;
  }

  return false;
}

std::string
CPathList::
mostMatchPrefix(const std::string &prefix)
{
  std::vector<std::string> dirs;
  std::vector<std::string> files;

  if (! matchPrefix(prefix, dirs, files))
    return prefix;

  return CStrUtil::mostMatch(files);
}

std::string
CPathList::
mostMatchPattern(const std::string &pattern)
{
  std::vector<std::string> dirs;
  std::vector<std::string> files;

  if (! matchPattern(pattern, dirs, files))
    return pattern;

  return CStrUtil::mostMatch(files);
}

bool
CPathList::
matchPrefix(const std::string &prefix, std::vector<std::string> &dirs,
            std::vector<std::string> &files)
{
  std::string pattern = prefix + "*";

  return matchPattern(pattern, dirs, files);
}

bool
CPathList::
matchPattern(const std::string &pattern, std::vector<std::string> &dirs,
             std::vector<std::string> &files)
{
  std::string pattern1;

  if (! CFile::expandTilde(pattern, pattern1))
    pattern1 = pattern;

  std::string::size_type pos = pattern1.find('/');

  if (pos != std::string::npos) {
    std::vector<std::string> files1;

    CFileMatch fileMatch;

    fileMatch.matchPattern(pattern1, files1);

    int num_files1 = files1.size();

    for (int j = 0; j < num_files1; j++) {
      std::string fileName;

      if (! CFile::expandTilde(files1[j], fileName))
        fileName = files1[j];

      CFile file(fileName);

      if (file.exists() && file.isRegular() && file.isExecutable()) {
        std::string::size_type pos = files1[j].rfind('/');

        dirs.push_back(file.getDir());

        if (pos != std::string::npos)
          files.push_back(files1[j].substr(pos + 1));
        else
          files.push_back(files1[j]);
      }
    }

    return ! files.empty();
  }

  CPathDirList::iterator p1 = dirs_.begin();
  CPathDirList::iterator p2 = dirs_.end();

  for ( ; p1 != p2; ++p1) {
    std::string full_path = *p1 + "/" + pattern;

    std::vector<std::string> files1;

    CFileMatch fileMatch;

    fileMatch.matchPattern(full_path, files1);

    int num_files1 = files1.size();

    for (int j = 0; j < num_files1; j++) {
      std::string fileName;

      if (! CFile::expandTilde(files1[j], fileName))
        fileName = files1[j];

      CFile file(fileName);

      if (file.exists() && file.isRegular() && file.isExecutable()) {
        std::string::size_type pos = files1[j].rfind('/');

        dirs.push_back(file.getDir());

        if (pos != std::string::npos)
          files.push_back(files1[j].substr(pos + 1));
        else
          files.push_back(files1[j]);
      }
    }
  }

  return ! files.empty();
}

std::string
CPathList::
toEnvValue()
{
  CPathDirList::iterator p1 = dirs_.begin();
  CPathDirList::iterator p2 = dirs_.end();

  std::string str;

  for ( ; p1 != p2; ++p1) {
    if (str.size() > 0)
      str += ":";

    str += *p1;
  }

  return str;
}
##concat##CwshAlias.cpp
#include <CwshI.h>
#include <CwshHistoryParser.h>

template<typename T>
class CwshAliasListValueDisplay {
 public:
  void operator()(const typename T::value_type &alias) {
    alias.second->display();
  }
};

CwshAliasMgr::
CwshAliasMgr(Cwsh *cwsh) :
 cwsh_(cwsh), last_alias_(NULL)
{
}

CwshAliasMgr::
~CwshAliasMgr()
{
}

void
CwshAliasMgr::
define(const CwshAliasName &name, const CwshAliasValue &value)
{
  CwshAlias *alias = new CwshAlias(name, value);

  aliases_.setValue(name, alias);
}

void
CwshAliasMgr::
undefine(const CwshAliasName &name)
{
  aliases_.unsetValue(name);
}

CwshAlias *
CwshAliasMgr::
lookup(const string &name) const
{
  return aliases_.getValue(name);
}

bool
CwshAliasMgr::
substitute(CwshCmd *cmd, CwshCmdArray &cmds) const
{
  const CwshWord &word = cmd->getWord(0);

  //------

  const string &str = word.getWord();

  if (str.empty() || str[0] == '"' || str[0] == '\'' || str[0] == '`' || str[0] == '\\')
    return false;

  //------

  CwshAlias *alias = lookup(str);

  if (alias == NULL || alias == last_alias_)
    return false;

  //------

  CwshHistoryParser parser(cwsh_);

  parser.parse(alias->getValue());

  if (cwsh_->getDebug())
    parser.display();

  vector<string> words;

  int num_words = cmd->getNumWords();

  for (int i = 0; i < num_words; i++)
    words.push_back(cmd->getWord(i).getWord());

  string line = parser.apply(words);

  //------

  CwshWordArray words1;

  CwshWord::toWords(line, words1);

  if (cwsh_->getDebug()) {
    std::cerr << "Split String Into Words" << std::endl;

    CwshWord::printWords(words1);
  }

  //------

  CwshAliasMgr *th = const_cast<CwshAliasMgr *>(this);

  th->last_alias_ = alias;

  CwshCmdSplit::wordsToCommands(words1, cmds);

  int num_cmds = cmds.size();

  if (num_cmds > 0)
    cmds[num_cmds - 1]->setSeparator(cmd->getSeparator());

  if (cwsh_->getDebug()) {
    std::cerr << "Substitute Alias" << std::endl;

    CwshCmd::displayCmdArray(cmds);
  }

  th->last_alias_ = NULL;

  //------

  return true;
}

void
CwshAliasMgr::
display() const
{
  std::for_each(aliases_.begin(), aliases_.end(), CwshAliasListValueDisplay<AliasList>());
}

string
CwshAliasMgr::
getAliasesMsg() const
{
  string msg;

  AliasList::const_iterator palias1 = aliases_.begin();
  AliasList::const_iterator palias2 = aliases_.end  ();

  for ( ; palias1 != palias2; ++palias1) {
    if (! msg.empty()) msg += "#";

    msg += (*palias1).second->getName () + "#" + (*palias1).second->getValue();
  }

  return msg;
}

//-------------------

CwshAlias::
CwshAlias(const string &name, const string &value) :
 name_(name), value_(value)
{
}

CwshAlias::
~CwshAlias()
{
}

void
CwshAlias::
display() const
{
  std::cout << name_ << " " << value_ << std::endl;
}
##concat##CwshAutoExec.cpp
#include <CwshI.h>

template<typename T>
class CwshAutoExecListValueDisplay {
 public:
  void operator()(const typename T::value_type &alias) {
    alias.second->display();
  }
};

CwshAutoExecMgr::
CwshAutoExecMgr(Cwsh *cwsh) :
 cwsh_(cwsh)
{
}

CwshAutoExecMgr::
~CwshAutoExecMgr()
{
}

void
CwshAutoExecMgr::
define(const CwshAutoExecName &suffix, const CwshAutoExecValue &value)
{
  CwshAutoExec *alias = new CwshAutoExec(suffix, value);

  auto_execs_.setValue(suffix, alias);
}

void
CwshAutoExecMgr::
undefine(const CwshAutoExecName &suffix)
{
  auto_execs_.unsetValue(suffix);
}

CwshAutoExec *
CwshAutoExecMgr::
lookup(const string &suffix) const
{
  return auto_execs_.getValue(suffix);
}

void
CwshAutoExecMgr::
display() const
{
  std::for_each(auto_execs_.begin(), auto_execs_.end(),
                CwshAutoExecListValueDisplay<AutoExecList>());
}

string
CwshAutoExecMgr::
getAutoExecsMsg() const
{
  string msg;

  AutoExecList::const_iterator palias1 = auto_execs_.begin();
  AutoExecList::const_iterator palias2 = auto_execs_.end  ();

  for ( ; palias1 != palias2; ++palias1) {
    if (! msg.empty()) msg += "#";

    msg += (*palias1).second->getName () + "#" + (*palias1).second->getValue();
  }

  return msg;
}

//-------------------

CwshAutoExec::
CwshAutoExec(const string &suffix, const string &value) :
 suffix_(suffix), value_(value)
{
}

CwshAutoExec::
~CwshAutoExec()
{
}

void
CwshAutoExec::
display() const
{
  std::cout << suffix_ << " " << value_ << std::endl;
}

bool
CwshAutoExec::
substitute(const string &name, string &cmd, vector<string> &args)
{
  cmd = value_;

  args.push_back(name);

  return true;
}
##concat##CwshBlock.cpp
#include <CwshI.h>

CwshBlockMgr::
CwshBlockMgr(Cwsh *cwsh) :
 cwsh_(cwsh)
{
  break_flag_    = false;
  breaksw_flag_  = false;
  continue_flag_ = false;
  return_flag_   = false;

  goto_depth_ = 0;
}

CwshBlockMgr::
~CwshBlockMgr()
{
  std::for_each(block_stack_.begin(), block_stack_.end(), CDeletePointer());
}

void
CwshBlockMgr::
startBlock(CwshBlockType type, const CwshLineArray &lines)
{
  if (inBlock()) {
    block_stack_.push_back(current_block_);

    current_block_.release();
  }

  current_block_ = new CwshBlock(type, lines);

  goto_depth_ = 0;
}

void
CwshBlockMgr::
endBlock()
{
  if (! inBlock())
    CWSH_THROW("Not in block");

  if (! block_stack_.empty()) {
    current_block_ = block_stack_.back();

    block_stack_.pop_back();
  }
  else
    current_block_ = NULL;

  if (goto_depth_ > 1)
    goto_depth_--;
}

bool
CwshBlockMgr::
inBlock() const
{
  return (current_block_ != NULL);
}

bool
CwshBlockMgr::
eof() const
{
  if (! inBlock())
    CWSH_THROW("Not in block");

  return current_block_->eof();
}

CwshLine
CwshBlockMgr::
readLine() const
{
  if (! inBlock())
    CWSH_THROW("Not in block");

  return current_block_->readLine();
}

CwshBlock *
CwshBlockMgr::
find(CwshBlockType type)
{
  if (! inBlock())
    return NULL;

  if (current_block_->getType() == type)
    return current_block_;

  int num_blocks = block_stack_.size();

  for (int i = num_blocks - 1; i >= 0; --i) {
    CwshBlock *block = block_stack_[i];

    if (block->getType() == type)
      return block;
  }

  return NULL;
}

void
CwshBlockMgr::
gotoLabel(const string &label)
{
  if (! inBlock())
    CWSH_THROW("goto: Not in block.");

  goto_depth_ = 0;

  int line_num = current_block_->getLabelLineNum(label);

  if (line_num != -1) {
    current_block_->setLineNum(line_num);

    return;
  }

  int num_blocks = block_stack_.size();

  for (int i = num_blocks - 1; i >= 0; i--) {
    CwshBlock *block = block_stack_[i];

    int line_num = block->getLabelLineNum(label);

    if (line_num != -1) {
      block->setLineNum(line_num);

      goto_depth_ = i + 1;

      return;
    }
  }

  CWSH_THROW("goto: Label " + label + "not found.");
}

//----------------

CwshBlock::
CwshBlock(CwshBlockType type, const CwshLineArray &lines) :
 type_(type), lines_(lines)
{
  line_num_ = 0;
}

CwshBlock::
~CwshBlock()
{
}

CwshLine
CwshBlock::
readLine()
{
  if (eof())
    CWSH_THROW("Block EOF");

  return lines_[line_num_++];
}

bool
CwshBlock::
eof() const
{
  return (line_num_ >= (int) lines_.size());
}

int
CwshBlock::
getLabelLineNum(const string &label) const
{
  int num_lines = lines_.size();

  for (int i = 0; i < num_lines; i++) {
    const CwshLine &line = lines_[i];

    vector<string> words;

    CwshString::addWords(line, words);

    if (words.size() == 2 && words[1] == ":" && words[0] == label)
      return i;
  }

  return -1;
}
##concat##CwshBraces.cpp
#include <CwshI.h>

bool
CwshBraces::
expand(const CwshWord &word, CwshWordArray &words)
{
  string str = word.getWord();

  uint len = str.size();

  uint i = 0;

  while (i < len) {
    if      (str[i] == '\"') {
      if (! CStrUtil::skipDoubleQuotedString(str, &i))
        CWSH_THROW("Unmatched \".");
    }
    else if (str[i] == '\'') {
      if (! CStrUtil::skipSingleQuotedString(str, &i))
        CWSH_THROW("Unmatched \'.");
    }
    else if (str[i] == '\\') {
      i++;

      if (i < len)
        i++;
    }
    else if (str[i] == '{')
      break;
    else
      i++;
  }

  if (i >= len)
    return false;

  i++;

  /* Save Start of String inside Braces */

  int i1 = i;

  /* Find Closing Brace */

  while (i < len) {
    if      (str[i] == '\"') {
      if (! CStrUtil::skipDoubleQuotedString(str, &i))
        CWSH_THROW("Unmatched \".");
    }
    else if (str[i] == '\'') {
      if (! CStrUtil::skipSingleQuotedString(str, &i))
        CWSH_THROW("Unmatched \'.");
    }
    else if (str[i] == '\\') {
      i++;

      if (i < len)
        i++;
    }
    else if (str[i] == '}')
      break;
    else
      i++;
  }

  if (i >= len)
    return false;

  int i2 = i - 1;

  //------

  /* Get Comma Separated Strings */

  CwshWordArray words1;

  string str1 = str.substr(0, i1 - 1);
  string str2 = str.substr(i2 + 2);

  int j = i1;
  int k = j;

  while (j <= i2) {
    if      (str[j] == '\\') {
      j++;

      if (j < (int) len)
        j++;
    }
    else if (str[j] == ',') {
      string word1 = str1 + str.substr(k, j - k) + str2;

      words1.push_back(CwshWord(word1));

      j++;

      k = j;
    }
    else
      j++;
  }

  string word1 = str1 + str.substr(k, j - k) + str2;

  words1.push_back(CwshWord(word1));

  //------

  uint num_words = words1.size();

  for (i = 0; i < num_words; i++) {
    const CwshWord &word1 = words1[i];

    CwshWordArray words2;

    if (expand(word1, words2))
      copy(words2.begin(), words2.end(), back_inserter(words));
    else
      words.push_back(word1);
  }

  //------

  return true;
}
##concat##CwshCmdSplit.cpp
#include <CwshI.h>

bool
CwshCmdSplit::
wordsToCommandLines(const CwshWordArray &words, CwshCmdLineArray &cmds)
{
  int i = 0;

  int num_words = words.size();

  while (i < num_words) {
    CwshCmdLine *cmd = new CwshCmdLine();

    wordsToCommandLine(words, &i, cmd);

    cmds.push_back(cmd);
  }

  return true;
}

void
CwshCmdSplit::
wordsToCommandLine(const CwshWordArray &words, int *i, CwshCmdLine *cmd)
{
  int brackets = 0;

  int num_words = words.size();

  while (*i < num_words) {
    const string &word = words[*i].getWord();

    if      (word == "(")
      ++brackets;
    else if (word == ")") {
      --brackets;

      if (brackets < 0)
        CWSH_THROW("Too many )'s.");
    }
    else if (word == ";") {
      ++(*i);

      break;
    }

    cmd->addWord(words[*i]);

    ++(*i);
  }

  if (brackets > 0)
    CWSH_THROW("Too many ('s.");
}

bool
CwshCmdSplit::
wordsToCommands(const CwshWordArray &words, CwshCmdArray &cmds)
{
  int i = 0;

  int num_words = words.size();

  while (i < num_words) {
    CwshCmd *cmd = new CwshCmd();

    wordsToCommand(words, &i, cmd);

    cmds.push_back(cmd);
  }

  //------

  if (cmds.size() > 0) {
    CwshCmd *last_cmd = cmds[cmds.size() - 1];

    CwshCmdSeparatorType separator_type = last_cmd->getSeparator().getType();

    if (separator_type == CWSH_COMMAND_SEPARATOR_PIPE     ||
        separator_type == CWSH_COMMAND_SEPARATOR_PIPE_ERR ||
        separator_type == CWSH_COMMAND_SEPARATOR_AND      ||
        separator_type == CWSH_COMMAND_SEPARATOR_OR)
      CWSH_THROW("Invalid null command.");
  }

  return true;
}

void
CwshCmdSplit::
wordsToCommand(const CwshWordArray &words, int *i, CwshCmd *cmd)
{
  int brackets = 0;

  int num_words = words.size();

  while (*i < num_words) {
    const string &word = words[*i].getWord();

    if      (word == "(")
      ++brackets;
    else if (word == ")") {
      --brackets;

      if (brackets < 0)
        CWSH_THROW("Too many )'s.");
    }
    else if (brackets == 0) {
      CwshCmdSeparator separator = parseCommandSeparator(word);

      if (separator.getType() != CWSH_COMMAND_SEPARATOR_NONE) {
        cmd->setSeparator(separator);

        ++(*i);

        break;
      }
    }

    cmd->addWord(words[*i]);

    ++(*i);
  }

  if (cmd->getNumWords() == 0)
    CWSH_THROW("Invalid null command.");

  if (brackets > 0)
    CWSH_THROW("Too many ('s.");
}

CwshCmdSeparator
CwshCmdSplit::
parseCommandSeparator(const string &word)
{
  if      (word == "&")
    return CwshCmdSeparator(CWSH_COMMAND_SEPARATOR_BACKGROUND);
  else if (word == "|")
    return CwshCmdSeparator(CWSH_COMMAND_SEPARATOR_PIPE);
  else if (word == "|&")
    return CwshCmdSeparator(CWSH_COMMAND_SEPARATOR_PIPE_ERR);
  else if (word == "&&")
    return CwshCmdSeparator(CWSH_COMMAND_SEPARATOR_AND);
  else if (word == "||")
    return CwshCmdSeparator(CWSH_COMMAND_SEPARATOR_OR);
  else if (word == ";")
    return CwshCmdSeparator(CWSH_COMMAND_SEPARATOR_NORMAL);
  else
    return CwshCmdSeparator(CWSH_COMMAND_SEPARATOR_NONE);
}

CwshCmdLine::
CwshCmdLine()
{
}

CwshCmdLine::
~CwshCmdLine()
{
}

void
CwshCmdLine::
addWord(const CwshWord &word)
{
  words_.push_back(word);
}

CwshCmdGroup::
CwshCmdGroup(const CwshCmdArray &commands) :
 commands_(commands)
{
}

CwshCmdGroup::
~CwshCmdGroup()
{
  std::for_each(commands_.begin(), commands_.end(), CDeletePointer());
}

void
CwshCmd::
displayCmdArray(const CwshCmdArray &cmds)
{
  std::for_each(cmds.begin(), cmds.end(), &CwshCmd::displayCmd);
}

void
CwshCmd::
displayCmd(const CwshCmd *cmd)
{
  cmd->display();
}

CwshCmd::
CwshCmd() :
 separator_(CWSH_COMMAND_SEPARATOR_NONE)
{
}

CwshCmd::
~CwshCmd()
{
}

void
CwshCmd::
addWord(const CwshWord &word)
{
  words_.push_back(word);
}

void
CwshCmd::
setWord(int i, const CwshWord &word)
{
  words_[i] = word;
}

void
CwshCmd::
setSeparator(const CwshCmdSeparator &separator)
{
  separator_ = separator;
}

void
CwshCmd::
setWords(const CwshWordArray &words)
{
  words_.clear();

  copy(words.begin(), words.end(), back_inserter(words_));
}

void
CwshCmd::
display() const
{
  string command_str = CwshWord::toString(words_);

  std::cerr << command_str << " " << separator_.getName() << std::endl;
}

string
CwshCmdSeparator::
getName() const
{
  if      (type_ == CWSH_COMMAND_SEPARATOR_BACKGROUND)
    return "&";
  else if (type_ == CWSH_COMMAND_SEPARATOR_PIPE)
    return "|";
  else if (type_ == CWSH_COMMAND_SEPARATOR_PIPE_ERR)
    return "|&";
  else if (type_ == CWSH_COMMAND_SEPARATOR_AND)
    return "&&";
  else if (type_ == CWSH_COMMAND_SEPARATOR_OR)
    return "||";
  else
    return "";
}
##concat##CwshCommand.cpp
#include <CwshI.h>

CwshCommandData::
CwshCommandData(Cwsh *cwsh, const vector<string> &words) :
 cwsh_(cwsh)
{
  type_ = CwshCommandUtil::getType(cwsh, words);

  if (type_ == CWSH_COMMAND_TYPE_UNIX) {
    string name = CStrUtil::removeEscapeChars(words[0]);

    vector<string> args;

    uint num_words = words.size();

    for (uint i = 1; i < num_words; ++i)
      args.push_back(CStrUtil::removeEscapeChars(words[i]));

    try {
      string path = CwshUnixCommand::search(cwsh, name);

      command_ = new CwshCommand(cwsh_, name, path, args);
    }
    catch (struct CwshErr *error) {
      bool found = false;

      if (num_words == 1 && CFile::exists(name) && CFile::isDirectory(name)) {
        args.clear(); args.push_back(name);

        CwshShellCommand *shell_command = cwsh_->lookupShellCommand("cd");

        // TODO: lookup and expand any cd alias
        command_ = new CwshCommand(cwsh_, "cd", CwshShellCommandMgr::runProc,
                                   (CCommand::CallbackData) shell_command, args);

        found = true;
      }
      else if (num_words == 1 && CFile::exists(name) && CFile::isRegular(name)) {
        string::size_type pos = name.rfind('.');

        if (pos != string::npos) {
          string suffix = name.substr(pos + 1);

          CwshAutoExec *exec = cwsh->lookupAutoExec(suffix);

          if (exec != NULL) {
            string         cmd;
            vector<string> args;

            if (exec->substitute(name, cmd, args)) {
              string path = CwshUnixCommand::search(cwsh, cmd);

              command_ = new CwshCommand(cwsh_, cmd, path, args);

              found = true;
            }
          }
        }
      }

      if (! found)
        CWSH_THROWQ(name, "Command not found.");
    }
  }
  else if (type_ == CWSH_COMMAND_TYPE_SHELL) {
    string name = CStrUtil::removeEscapeChars(words[0]);

    vector<string> args;

    uint num_words = words.size();

    for (uint i = 1; i < num_words; ++i)
      args.push_back(CStrUtil::removeEscapeChars(words[i]));

    CwshShellCommand *shell_command = cwsh_->lookupShellCommand(name);

    command_ = new CwshCommand(cwsh_, name, CwshShellCommandMgr::runProc,
                               (CCommand::CallbackData) shell_command, args);
  }
  else if (type_ == CWSH_COMMAND_TYPE_FUNCTION) {
    string name = CStrUtil::removeEscapeChars(words[0]);

    vector<string> args;

    uint num_words = words.size();

    for (uint i = 1; i < num_words; ++i)
      args.push_back(CStrUtil::removeEscapeChars(words[i]));

    CwshFunction *function = cwsh_->lookupFunction(name);

    command_ = new CwshCommand(cwsh_, name, CwshFunction::runProc,
                               (CCommand::CallbackData) function, args);
  }
  else if (type_ == CWSH_COMMAND_TYPE_LABEL)
    ;
  else if (type_ == CWSH_COMMAND_TYPE_SUBSHELL) {
    string name = "";

    string line = CStrUtil::toString(words, 1, words.size() - 2);

    vector<string> args;

    args.push_back(line);

    command_ = new CwshCommand(cwsh_, name, CwshCommandUtil::processLineProc,
                               cwsh_, args, true);
  }
  else if (type_ == CWSH_COMMAND_TYPE_PROCESS) {
    if (words.size() > 1)
      CWSH_THROW("Too many arguments.");

    CwshProcess *process = cwsh_->getActiveProcess(words[0]);

    if (process == NULL)
      CWSH_THROW("No such job.");

    std::cout << process->getCommandString() << std::endl;

    process->resume();

    process->wait();
  }
  else {
    string name = CStrUtil::removeEscapeChars(words[0]);

    CWSH_THROW(name + ": Unimplemented Command.");
  }
}

CwshCommandData::
~CwshCommandData()
{
}

//------------

CwshCommand::
CwshCommand(Cwsh *cwsh, const std::string &name, const std::string &path,
            const StringVectorT &args, bool do_fork) :
 CCommand(name, path, args, do_fork), cwsh_(cwsh), notify_(false), stateChanged_(false)
{
}

CwshCommand::
CwshCommand(Cwsh *cwsh, const std::string &name, CallbackProc proc, CallbackData data,
            const StringVectorT &args, bool do_fork) :
 CCommand(name, proc, data, args, do_fork), cwsh_(cwsh), notify_(false), stateChanged_(false)
{
}

CwshCommand::
~CwshCommand()
{
}

void
CwshCommand::
setState(State state)
{
  if (getState() == state) return;

  CCommand::setState(state);

  if (notify_) {
    CwshProcess *process = cwsh_->lookupProcess(getPid());
    if (! process) return;

    std::cout << "[" << process->getNum() << "] ";

    std::cout << getPid() << " ";

    if      (getState() == CCommand::STOPPED_STATE)
      std::cout << "Suspended             ";
    else if (getState() == CCommand::EXITED_STATE)
      std::cout << "Exited                ";
    else if (getState() == CCommand::SIGNALLED_STATE)
      std::cout << "Signalled             ";
    else if (getState() == CCommand::RUNNING_STATE)
      std::cout << "Running               ";
    else
      std::cout << "????                  ";

    process->print();

    std::cout << std::endl;
  }
  else
    stateChanged_ = true;
}

//------------

bool
CwshCommandUtil::
parseCommandLines(Cwsh *cwsh, const string &str, CwshCmdLineArray &cmds)
{
  // Split String Into Words

  CwshWordArray words;

  CwshWord::toWords(str, words);

  if (cwsh->getDebug()) {
    std::cerr << "Split String Into Words" << std::endl;

    CwshWord::printWords(words);
  }

  return CwshCmdSplit::wordsToCommandLines(words, cmds);
}

bool
CwshCommandUtil::
parseCommandGroups(Cwsh *cwsh, const string &str, CwshCmdGroupArray &groups)
{
  // Split String Into Words

  CwshWordArray words;

  CwshWord::toWords(str, words);

  if (cwsh->getDebug()) {
    std::cerr << "Split String Into Words" << std::endl;

    CwshWord::printWords(words);
  }

  //------

  // Split Words Into Commands

  CwshCmdArray cmds;

  CwshCmdSplit::wordsToCommands(words, cmds);

  if (cwsh->getDebug()) {
    std::cerr << "Split Words Into Commands" << std::endl;

    CwshCmd::displayCmdArray(cmds);
  }

  //------

  // Replace Aliased Commands

  CwshCmdArray cmds1;

  uint num_cmds = cmds.size();

  for (uint i = 0; i < num_cmds; ++i) {
    CwshCmdArray alias_cmds;

    if (cwsh->substituteAlias(cmds[i], alias_cmds)) {
      delete cmds[i];

      copy(alias_cmds.begin(), alias_cmds.end(), back_inserter(cmds1));
    }
    else
      cmds1.push_back(cmds[i]);
  }

  if (cwsh->getDebug()) {
    std::cerr << "Replace Aliased Commands" << std::endl;

    CwshCmd::displayCmdArray(cmds1);
  }

  //------

  groupCommands(cmds1, groups);

  //------

  return true;
}

bool
CwshCommandUtil::
groupCommands(CwshCmdArray cmds, CwshCmdGroupArray &groups)
{
  CwshCmdArray cmds1;

  uint num_cmds = cmds.size();

  for (uint i = 0; i < num_cmds; ++i) {
    cmds1.push_back(cmds[i]);

    if (cmds[i]->getSeparator().getType() == CWSH_COMMAND_SEPARATOR_NORMAL) {
      if (cmds1.size() > 0) {
        CwshCmdGroup *group = new CwshCmdGroup(cmds1);

        groups.push_back(group);

        cmds1.clear();
      }
    }
  }

  if (cmds1.size() > 0) {
    CwshCmdGroup *group = new CwshCmdGroup(cmds1);

    groups.push_back(group);
  }

  return true;
}

CwshCmdArray
CwshCommandUtil::
parseCommandGroup(Cwsh *cwsh, CwshCmdGroup *group)
{
  const CwshCmdArray cmds = group->getCommands();

  //------

  // Replace Variables

  uint num_cmds = cmds.size();

  for (uint i = 0; i < num_cmds; ++i) {
    CwshShellCommand *shell_command = cwsh->lookupShellCommand(cmds[i]->getWord(0).getWord());

    if (shell_command != NULL && shell_command->getNoExpand())
      continue;

    //------

    CwshWordArray words;

    int num_words = cmds[i]->getNumWords();

    for (int j = 0; j < num_words; ++j) {
      CwshWordArray words1;

      const CwshWord &word = cmds[i]->getWord(j);

      CwshVariableParser vparser(cwsh, word);

      if (vparser.expandVariables(words1))
        copy(words1.begin(), words1.end(), back_inserter(words));
      else
        words.push_back(word);
    }

    cmds[i]->setWords(words);
  }

  if (cwsh->getDebug()) {
    std::cerr << "Replace Variables" << std::endl;

    CwshCmd::displayCmdArray(cmds);
  }

  //------

  // Replace backquotes

  num_cmds = cmds.size();

  for (uint i = 0; i < num_cmds; ++i) {
    CwshShellCommand *shell_command = cwsh->lookupShellCommand(cmds[i]->getWord(0).getWord());

    if (shell_command != NULL && shell_command->getNoExpand())
      continue;

    //------

    CwshWordArray cmd_words;
    bool          cmd_words_changed = false;

    int num_words = cmds[i]->getNumWords();

    for (int j = 0; j < num_words; ++j) {
      const CwshWord &word = cmds[i]->getWord(j);

      CwshWordArray in_place_words;

      CwshInPlaceCommand icmd(cwsh, word);

      if (icmd.expand(in_place_words)) {
        uint num_in_place_words = in_place_words.size();

        for (uint k = 0; k < num_in_place_words; ++k)
          cmd_words.push_back(in_place_words[k]);

        cmd_words_changed = true;
      }
      else
        cmd_words.push_back(word);
    }

    if (cmd_words_changed)
      cmds[i]->setWords(cmd_words);
  }

  if (cwsh->getDebug()) {
    std::cerr << "Replace backquotes" << std::endl;

    CwshCmd::displayCmdArray(cmds);
  }

  //------

  // Expand Tildes

  num_cmds = cmds.size();

  for (uint i = 0; i < num_cmds; ++i) {
    CwshShellCommand *shell_command = cwsh->lookupShellCommand(cmds[i]->getWord(0).getWord());

    if (shell_command != NULL && shell_command->getNoWildcards())
      continue;

    //------

    int num_words = cmds[i]->getNumWords();

    for (int j = 0; j < num_words; ++j) {
      string str;

      if (CFile::expandTilde(cmds[i]->getWord(j).getWord(), str))
        cmds[i]->setWord(j, CwshWord(str));
    }
  }

  if (cwsh->getDebug()) {
    std::cerr << "Expand Tildes" << std::endl;

    CwshCmd::displayCmdArray(cmds);
  }

  //------

  // Expand Braces

  num_cmds = cmds.size();

  for (uint i = 0; i < num_cmds; ++i) {
    CwshShellCommand *shell_command = cwsh->lookupShellCommand(cmds[i]->getWord(0).getWord());

    if (shell_command != NULL && shell_command->getNoWildcards())
      continue;

    //------

    CwshWordArray words;

    int num_words = cmds[i]->getNumWords();

    for (int j = 0; j < num_words; ++j) {
      const CwshWord &word = cmds[i]->getWord(j);

      CwshWordArray words1;

      if (CwshBraces::expand(word, words1))
        copy(words1.begin(), words1.end(), back_inserter(words));
      else
        words.push_back(word);
    }

    cmds[i]->setWords(words);
  }

  if (cwsh->getDebug()) {
    std::cerr << "Expand Braces" << std::endl;

    CwshCmd::displayCmdArray(cmds);
  }

  //------

  // Expand Wildcards

  num_cmds = cmds.size();

  for (uint i = 0; i < num_cmds; ++i) {
    CwshShellCommand *shell_command = cwsh->lookupShellCommand(cmds[i]->getWord(0).getWord());

    if (shell_command != NULL && shell_command->getNoWildcards())
      continue;

    //------

    CwshWordArray words;

    int num_words = cmds[i]->getNumWords();

    for (int j = 0; j < num_words; ++j) {
      const CwshWord &word = cmds[i]->getWord(j);

      CwshWordArray words1;

      CwshPattern pattern(cwsh);

      if (pattern.expandWordToFiles(word, words1))
        copy(words1.begin(), words1.end(), back_inserter(words));
      else
        words.push_back(word);
    }

    cmds[i]->setWords(words);
  }

  if (cwsh->getDebug()) {
    std::cerr << "Expand Wildcards" << std::endl;

    CwshCmd::displayCmdArray(cmds);
  }

  //------

  // Remove Quotes

  num_cmds = cmds.size();

  for (uint i = 0; i < num_cmds; ++i) {
    CwshShellCommand *shell_command = cwsh->lookupShellCommand(cmds[i]->getWord(0).getWord());

    if (shell_command != NULL && shell_command->getNoExpand())
      continue;

    //------

    int num_words = cmds[i]->getNumWords();

    for (int j = 0; j < num_words; ++j) {
      CwshWord word = cmds[i]->getWord(j);

      word.removeQuotes();

      cmds[i]->setWord(j, word);
    }
  }

  if (cwsh->getDebug()) {
    std::cerr << "Remove Quotes" << std::endl;

    CwshCmd::displayCmdArray(cmds);
  }

  //------

  // Get Command Redirection

  num_cmds = cmds.size();

  for (uint i = 0; i < num_cmds; ++i) {
    CwshShellCommand *shell_command = cwsh->lookupShellCommand(cmds[i]->getWord(0).getWord());

    if (shell_command != NULL && shell_command->getNoExpand())
      continue;

    //------

    CwshWordArray words;

    int num_words = cmds[i]->getNumWords();

    for (int j = 0; j < num_words; ++j) {
      const string &word = cmds[i]->getWord(j).getWord();

      if      (word == ">"  || word == ">!" ||
               word == ">>" || word == ">>!") {
        ++j;

        if (j >= cmds[i]->getNumWords())
          CWSH_THROW("Missing name for redirect.");

        cmds[i]->setStdOutFile(cmds[i]->getWord(j).getWord());

        if (word == ">!" || word == ">>!")
          cmds[i]->setStdOutClobber(true);
        else
          cmds[i]->setStdOutClobber(false);

        if (word == ">>" || word == ">>!")
          cmds[i]->setStdOutAppend(true);
        else
          cmds[i]->setStdOutAppend(false);
      }
      else if (word == ">&"  || word == ">&!" ||
               word == ">>&" || word == ">>&!") {
        ++j;

        if (j >= cmds[i]->getNumWords())
          CWSH_THROW("Missing name for redirect.");

        cmds[i]->setStdErrFile(cmds[i]->getWord(j).getWord());

        if (word == ">&!" || word == ">>&!")
          cmds[i]->setStdErrClobber(true);
        else
          cmds[i]->setStdErrClobber(false);

        if (word == ">>&" || word == ">>&!")
          cmds[i]->setStdErrAppend(true);
        else
          cmds[i]->setStdErrAppend(false);
      }
      else if (word == "<") {
        ++j;

        if (j >= cmds[i]->getNumWords())
          CWSH_THROW("Missing name for redirect.");

        cmds[i]->setStdInFile(cmds[i]->getWord(j).getWord());
      }
      else if (word == "<<") {
        ++j;

        if (j >= cmds[i]->getNumWords())
          CWSH_THROW("Missing name for redirect.");

        cmds[i]->setStdInToken(cmds[i]->getWord(j).getWord());
      }
      else
        words.push_back(cmds[i]->getWord(j));
    }

    cmds[i]->setWords(words);
  }

  return cmds;
}

CwshCommandType
CwshCommandUtil::
getType(Cwsh *cwsh, const vector<string> &words)
{
  const string &name = words[0];

  if (name.size() > 0 && name[0] == '(')
    return CWSH_COMMAND_TYPE_SUBSHELL;

  //------

  if (name.size() > 0 && name[0] == '%')
    return CWSH_COMMAND_TYPE_PROCESS;

  //------

  if (words.size() == 2 && words[1] == ":")
    return CWSH_COMMAND_TYPE_LABEL;

  //------

  CwshFunction *function = cwsh->lookupFunction(name);

  if (function != NULL)
    return CWSH_COMMAND_TYPE_FUNCTION;

  //------

  CwshShellCommand *command = cwsh->lookupShellCommand(name);

  if (command != NULL)
    return CWSH_COMMAND_TYPE_SHELL;

  //------

  return CWSH_COMMAND_TYPE_UNIX;
}

void
CwshCommandUtil::
processLineProc(const vector<string> &args, CCommand::CallbackData data)
{
  Cwsh *cwsh = (Cwsh *) data;

  cwsh->processInputLine(args[0]);
}
##concat##CwshComplete.cpp
#include <CwshI.h>
#include <CFileMatch.h>
#include <CPathList.h>

CwshComplete::
CwshComplete(Cwsh *cwsh, const string &line) :
 cwsh_(cwsh), line_(line) {
}

bool
CwshComplete::
complete(string &line1)
{
  line1 = "";

  string word;

  CwshCompletionType type = getCompletionType(&word);

  if (type == CWSH_COMPLETION_TYPE_NONE)
    return false;

  string word1;

  bool flag;

  if      (type == CWSH_COMPLETION_TYPE_COMMAND)
    flag = completeCommand(word, word1);
  else if (type == CWSH_COMPLETION_TYPE_FILE)
    flag = completeFile(word, word1);
  else if (type == CWSH_COMPLETION_TYPE_VAR)
    flag = completeVariable(word, word1);
  else if (type == CWSH_COMPLETION_TYPE_USERS)
    flag = completeUsers(word, word1);
  else
    flag = false;

  uint len  = word .size();
  uint len1 = word1.size();

  if (! flag || len1 < len || word != word1.substr(0, len))
    return false;

  line1 = word1.substr(len);

  return true;
}

bool
CwshComplete::
completeCommand(string &path)
{
  return completeCommand(line_, path);
}

bool
CwshComplete::
completeCommand(const string &path, string &path1)
{
  string::size_type pos = path.rfind('/');

  if (pos == string::npos) {
    CPathList pathList;

    pathList.addEnvValue("PATH");

    path1 = pathList.mostMatchPrefix(path);
  }
  else {
    if (! completeExecFile(path, path1))
      return false;
  }

  return true;
}

bool
CwshComplete::
completeFile(string &file)
{
  return completeFile(line_, file);
}

bool
CwshComplete::
completeFile(const string &file, string &file1)
{
  CwshVariable *fignore = cwsh_->lookupVariable("fignore");

  if (fignore != NULL) {
    int num_values = fignore->getNumValues();

    for (int i = 0; i < num_values; ++i)
      file_ignore_list_.push_back("*." + fignore->getValue(i));
  }

  CFileMatch fileMatch;

  uint num = file_ignore_list_.size();

  for (uint i = 0; i < num; ++i)
    fileMatch.addIgnorePattern(file_ignore_list_[i]);

  file1 = fileMatch.mostMatchPrefix(file);

  if (file1.find(' ')) {
    string file2;

    uint len = file1.size();

    for (uint i = 0; i < len; ++i) {
      if (file1[i] == ' ')
        file2 += "\\";

      file2 += file1[i];
    }

    file1 = file2;
  }

  return true;
}

bool
CwshComplete::
completeExecFile(const string &file, string &file1)
{
  CFileMatch fileMatch;

  fileMatch.setOnlyExec();

  file1 = fileMatch.mostMatchPrefix(file);

  if (file1.find(' ')) {
    string file2;

    uint len = file1.size();

    for (uint i = 0; i < len; ++i) {
      if (file1[i] == ' ')
        file2 += "\\";

      file2 += file1[i];
    }

    file1 = file2;
  }

  return true;
}

bool
CwshComplete::
completeVariable(string &name)
{
  return completeVariable(line_, name);
}

bool
CwshComplete::
completeVariable(const string &name, string &name1)
{
  string pattern_str = name + "*";

  vector<string> names;

  CwshPattern pattern(cwsh_, pattern_str);

  if (! pattern.expandVar(names))
    return false;

  name1 = CStrUtil::mostMatch(names);

  return true;
}

bool
CwshComplete::
completeUsers(string &name)
{
  return completeUsers(line_, name);
}

bool
CwshComplete::
completeUsers(const string &name, string &name1)
{
  string pattern_str = name + "*";

  vector<string> names;

  if (! CwshString::matchUsers(pattern_str, names))
    return false;

  name1 = CStrUtil::mostMatch(names);

  return true;
}

CwshCompletionType
CwshComplete::
getCompletionType(string *word)
{
  CwshVariable *filec = cwsh_->lookupVariable("filec");

  if (filec == NULL)
    return CWSH_COMPLETION_TYPE_NONE;

  vector<string> words;

  CwshString::addWords(line_, words);

  uint len = line_.size();

  if (len > 0 && isspace(line_[len - 1]))
    words.push_back("");

  len = words.size();

  if (len == 0)
    return CWSH_COMPLETION_TYPE_NONE;

  const string &word1 = words[len - 1];

  uint len1 = word1.size();

  if      (len1 > 0 && word1[0] == '$') {
    *word = word1.substr(1);

    return CWSH_COMPLETION_TYPE_VAR;
  }
  else if (word1[0] == '~' && word1.find('/') == string::npos) {
    *word = word1.substr(1);

    return CWSH_COMPLETION_TYPE_USERS;
  }
  else if (len == 1) {
    *word = word1;

    return CWSH_COMPLETION_TYPE_COMMAND;
  }
  else {
    *word = word1;

    return CWSH_COMPLETION_TYPE_FILE;
  }
}
##concat##Cwsh.cpp
#include <CwshI.h>
#include <CwshShMem.h>
#include <CArgs.h>
//#include <COSPty.h>
#include <cstdio>

CwshMgr &
CwshMgr::
getInstance()
{
  static CwshMgr *instance_;

  if (instance_ == NULL)
    instance_ = new CwshMgr();

  return *instance_;
}

CwshMgr::
CwshMgr()
{
}

CwshMgr::
~CwshMgr()
{
}

void
CwshMgr::
add(Cwsh *cwsh)
{
  cwsh_list_.push_back(cwsh);
}

void
CwshMgr::
remove(Cwsh *cwsh)
{
  cwsh_list_.remove(cwsh);
}

void
CwshMgr::
term(int status)
{
  CwshList::iterator p = cwsh_list_.begin();

  while (p != cwsh_list_.end()) {
    term(*p, status);

    remove(*p);

    p = cwsh_list_.begin();
  }
}

void
CwshMgr::
term(Cwsh *cwsh, int status)
{
  cwsh->term();

  if (cwsh_list_.size() == 0)
    exit(status);
}

void
CwshMgr::
setInterrupt(bool flag)
{
  CwshList::iterator p1, p2;

  for (p1 = cwsh_list_.begin(), p2 = cwsh_list_.end(); p1 != p2; ++p1)
    (*p1)->setInterrupt(flag);
}

void
CwshMgr::
readInterrupt()
{
  CwshList::iterator p1, p2;

  for (p1 = cwsh_list_.begin(), p2 = cwsh_list_.end(); p1 != p2; ++p1)
    (*p1)->readInterrupt();
}

void
CwshMgr::
gotoBlockLabel(const string &label)
{
  CwshList::iterator p1, p2;

  for (p1 = cwsh_list_.begin(), p2 = cwsh_list_.end(); p1 != p2; ++p1)
    (*p1)->gotoBlockLabel(label);
}

void
CwshMgr::
stopActiveProcesses()
{
  CwshList::iterator p1, p2;

  for (p1 = cwsh_list_.begin(), p2 = cwsh_list_.end(); p1 != p2; ++p1) {
    CwshProcess *process = (*p1)->getCurrentActiveProcess();

    if (process != NULL) {
      std::cout << "[" << process->getNum() << "]    Stopped               ";

      process->print();

      std::cout << std::endl;

      process->tstop();
    }
  }
}

//--------

Cwsh::
Cwsh() :
 exit_on_error_ (false),
 fast_startup_  (false),
 interactive_   (false),
 no_execute_    (false),
 exit_after_cmd_(false),
 login_shell_   (false),
 prompt_type_   (CWSH_PROMPT_TYPE_NORMAL),
 compatible_    (false),
 silentMode_    (false),
 debug_         (false),
 interrupt_     (false),
 verbose1_      (false),
 verbose2_      (false),
 echo1_         (false),
 echo2_         (false),
 term_tries_    (0),
 exit_          (false),
 exit_status_   (0)
{
  function_mgr_  = new CwshFunctionMgr(this);
  variable_mgr_  = new CwshVariableMgr(this);
  process_mgr_   = new CwshProcessMgr(this);
  state_mgr_     = new CwshStateMgr(this);
  block_mgr_     = new CwshBlockMgr(this);
  alias_mgr_     = new CwshAliasMgr(this);
  auto_exec_mgr_ = new CwshAutoExecMgr(this);
  history_       = new CwshHistory(this);
  shell_cmd_mgr_ = new CwshShellCommandMgr(this);
  input_         = new CwshInput(this);
  read_line_     = new CwshReadLine(this);
  dir_stack_     = new CwshDirStack;
  hash_          = new CwshHash(this);
  resource_      = new CwshResource;

#ifdef USE_SHM
  sh_mem_ = new CwshShMem();

  sh_mem_->purge();
#endif

  //read_line_->enableTimoutHook();

  CwshMgrInst.add(this);
}

Cwsh::
~Cwsh()
{
  cleanup();

  CwshMgrInst.remove(this);
}

void
Cwsh::
cleanup()
{
  input_file_    = NULL;
  function_mgr_  = NULL;
  variable_mgr_  = NULL;
  process_mgr_   = NULL;
  state_mgr_     = NULL;
  block_mgr_     = NULL;
  alias_mgr_     = NULL;
  auto_exec_mgr_ = NULL;
  history_       = NULL;
  shell_cmd_mgr_ = NULL;
  input_         = NULL;
  read_line_     = NULL;
  dir_stack_     = NULL;
  hash_          = NULL;
  resource_      = NULL;
  server_        = NULL;
#ifdef USE_SHM
  sh_mem_        = NULL;
#endif
}

void
Cwsh::
init()
{
  int   argc   = 1;
  char *argv[] = { (char *) "cwsh", NULL };

  init(argc, argv);
}

void
Cwsh::
init(int argc, char **argv)
{
  if (! processArgs(argc, argv))
    exit(1);

  initEnv();
}

bool
Cwsh::
processArgs(int argc, char **argv)
{
  string opts = "\
 -c:s           (Execute Following Commands) \
 -e:f           (Exit On Error) \
 -f:f           (Don't execute .cwshrc On Startup) \
 -i:f           (Interactive Mode) \
 -n:f           (No Execute Mode) \
 -s:f           (Command input from stdin) \
 -t:f           (Exit after executing command) \
 -v:f           (Verbose after execute of .cwshrc) \
 -V:f           (Verbose before execute of .cwshrc) \
 -x:f           (Echo after execute of .cwshrc) \
 -X:f           (Echo before execute of .cwshrc) \
 -h:f           (Display usage information) \
 --compatible:f (C Shell Compatible) \
 --silent:f     (Silent Mode) \
 --server:f     (Enable Server) \
 --debug:f      (Turn On Debug Messages) \
";

  CArgs cargs(opts);

  cargs.parse(&argc, argv);

  if (cargs.getBooleanArg("-h")) {
    cargs.usage(argv[0]);
    return false;
  }

  command_string_ = cargs.getStringArg ("-c");
  exit_on_error_  = cargs.getBooleanArg("-e");
  fast_startup_   = cargs.getBooleanArg("-f");
  interactive_    = cargs.getBooleanArg("-i");
  no_execute_     = cargs.getBooleanArg("-n");
  exit_after_cmd_ = cargs.getBooleanArg("-t");
  verbose1_       = cargs.getBooleanArg("-v");
  verbose2_       = cargs.getBooleanArg("-V");
  echo1_          = cargs.getBooleanArg("-x");
  echo2_          = cargs.getBooleanArg("-X");
  compatible_     = cargs.getBooleanArg("--compatible");
  silentMode_     = cargs.getBooleanArg("--silent");
  debug_          = cargs.getBooleanArg("--debug");

  defineVariable("argv", (const char **) &argv[1], argc - 1);

  argv0_ = argv[0];

  login_shell_ = false;

  if (argv[0][0] == '-')
    login_shell_ = true;

  name_ = argv[0];

  if (argc > 1)
    init_filename_ = argv[1];

  if (cargs.getBooleanArg("--server"))
    enableServer();

  return true;
}

void
Cwsh::
initEnv()
{
  if (debug_)
    CCommandMgrInst->setDebug(true);

  if (init_filename_ != "")
    input_file_ = new CFile(init_filename_);
  else {
    input_file_ = new CFile(stdin);

    interactive_ = true;
  }

  defineVariable("cwsh", "0.1");
  defineVariable("filec");

  //------

  if (CEnvInst.exists("PATH")) {
    string path = CEnvInst.get("PATH");

    vector<string> values;

    CStrUtil::addFields(path, values, ":");

    defineVariable("path", values);
  }

  defineVariable("user" , COSUser::getUserName       ());
  defineVariable("uid"  , COSUser::getEffectiveUserId());
  defineVariable("gid"  , COSUser::getUserGroupId    ());
  defineVariable("home" , COSUser::getUserHome       ());
  defineVariable("shell", COSUser::getUserShell      ());
  defineVariable("cwd"  , COSFile::getCurrentDir     ());

  prompt_type_    = CWSH_PROMPT_TYPE_NORMAL;
  prompt_command_ = "";

  if (interactive_)
    defineVariable("prompt", "> ");

  defineVariable("history", 20);

  defineVariable("status", 0);

  if (CEnvInst.exists("TERM")) {
    string term_env = CEnvInst.get("TERM");

    defineVariable("term", term_env);
  }

  //------

  if (CEnvInst.exists("CWSH_SILENT"))
    silentMode_ = true;

  //------

  CwshSignal::addHandlers();

  //------

  if (verbose2_)
    defineVariable("verbose");

  if (echo2_)
    defineVariable("echo");

  //------

  if (! fast_startup_)
    startup();

  //------

  if (verbose1_)
    defineVariable("verbose");

  if (echo1_)
    defineVariable("echo");

  //------

  if (command_string_ != "")
    processLine(command_string_);
}

void
Cwsh::
enableServer()
{
  server_ = new CwshServer(this);
}

CMessage *
Cwsh::
createServerMessage()
{
  return CwshServer::createMessage();
}

void
Cwsh::
mainLoop()
{
  if (! getExit())
    input_->execute(input_file_);

  CwshMgrInst.term(this, 0);
}

void
Cwsh::
processLine(const string &line)
{
  processInputLine(line);
}

void
Cwsh::
startup()
{
  string home = COSUser::getUserHome();

  CDir dir(home);

  dir.enter();

  if (login_shell_) {
    if (CFile::exists(".login"))
      executeInput(".login");
  }

  if      (CFile::exists(".cwsh++"))
    executeInput(".cwsh++");
  else if (CFile::exists(".cwshrc"))
    executeInput(".cwshrc");
  else if (CFile::exists(".cshrc"))
    executeInput(".cshrc");

  dir.leave();
}

void
Cwsh::
term()
{
  if (getNumActiveProcesses() > 0 && term_tries_ <= 0) {
    std::cerr << "There are suspended jobs." << std::endl;
    ++term_tries_;
    return;
  }

  // TODO: send all foreground and background process groups a SIGHUP, followed
  // by a SIGCONT signal (optional ?) if stopped

  if (login_shell_) {
    string home = COSUser::getUserHome();

    CDir dir(home);

    dir.enter();

    if (CFile::exists(".logout"))
      executeInput(".logout");

    dir.leave();
  }

  cleanup();
}

bool
Cwsh::
changeDir(const string &dirname)
{
  if (! CDir::changeDir(dirname))
    return false;

  defineVariable("cwd", COSFile::getCurrentDir());

#ifdef USE_SHM
  sh_mem_->setPath(COSUser::getCurrentDir().c_str());
#endif

  return true;
}

void
Cwsh::
setDebug(bool flag)
{
  debug_ = flag;
}

//---------------

void
Cwsh::
defineFunction(const CwshFunctionName &name, const CwshLineArray &lines)
{
  function_mgr_->define(name, lines);
}

void
Cwsh::
undefineFunction(const CwshFunctionName &name)
{
  function_mgr_->undefine(name);
}

CwshFunction *
Cwsh::
lookupFunction(const CwshFunctionName &name)
{
  return function_mgr_->lookup(name);
}

void
Cwsh::
listAllFunctions()
{
  function_mgr_->listAll();
}

//---------------

void
Cwsh::
defineVariable(const CwshVariableName &name)
{
  if (variable_mgr_ != NULL)
    variable_mgr_->define(name);
}

void
Cwsh::
defineVariable(const CwshVariableName &name,
               const CwshVariableValue &value)
{
  if (variable_mgr_ != NULL)
    variable_mgr_->define(name, value);
}

void
Cwsh::
defineVariable(const CwshVariableName &name, int value)
{
  if (variable_mgr_ != NULL)
    variable_mgr_->define(name, value);
}

void
Cwsh::
defineVariable(const CwshVariableName &name,
               const CwshVariableValueArray &values)
{
  if (variable_mgr_ != NULL)
    variable_mgr_->define(name, values);
}

void
Cwsh::
defineVariable(const CwshVariableName &name,
               const char **values, int num_values)
{
  if (variable_mgr_ != NULL)
    variable_mgr_->define(name, values, num_values);
}

void
Cwsh::
undefineVariable(const CwshVariableName &name)
{
  if (variable_mgr_ != NULL)
    variable_mgr_->undefine(name);
}

CwshVariable *
Cwsh::
lookupVariable(const CwshVariableName &name) const
{
  if (variable_mgr_ != NULL)
    return variable_mgr_->lookup(name);
  else
    return NULL;
}

CwshVariableList::iterator
Cwsh::
variablesBegin()
{
  assert(variable_mgr_ != NULL);

  return variable_mgr_->variablesBegin();
}

CwshVariableList::iterator
Cwsh::
variablesEnd()
{
  assert(variable_mgr_ != NULL);

  return variable_mgr_->variablesEnd();
}

void
Cwsh::
listVariables() const
{
  if (variable_mgr_ != NULL)
    variable_mgr_->listVariables();
}

void
Cwsh::
saveVariables()
{
  if (variable_mgr_ != NULL)
    variable_mgr_->save();
}

void
Cwsh::
restoreVariables()
{
  if (variable_mgr_ != NULL)
    variable_mgr_->restore();
}

bool
Cwsh::
isEnvironmentVariableLower(const string &name)
{
  if (variable_mgr_ != NULL)
    return variable_mgr_->isEnvironmentVariableLower(name);
  else
    return false;
}

bool
Cwsh::
isEnvironmentVariableUpper(const string &name)
{
  if (variable_mgr_ != NULL)
    return variable_mgr_->isEnvironmentVariableUpper(name);
  else
    return false;
}

void
Cwsh::
updateEnvironmentVariable(CwshVariable *variable)
{
  if (variable_mgr_ != NULL)
    variable_mgr_->updateEnvironmentVariable(variable);
}

//---------------

CwshProcess *
Cwsh::
addProcess(CwshCommandData *command)
{
  return process_mgr_->add(command);
}

void
Cwsh::
removeProcess(CwshProcess *process)
{
  process_mgr_->remove(process);
}

void
Cwsh::
killProcess(int pid, int signal)
{
  process_mgr_->kill(pid, signal);
}

int
Cwsh::
getNumActiveProcesses()
{
  if (! process_mgr_) return 0;

  return process_mgr_->getNumActive();
}

void
Cwsh::
displayActiveProcesses(bool list_pids)
{
  process_mgr_->displayActive(list_pids);
}

void
Cwsh::
displayExitedProcesses()
{
  process_mgr_->displayExited();
}

void
Cwsh::
waitActiveProcesses()
{
  process_mgr_->waitActive();
}

int
Cwsh::
stringToProcessId(const string &str)
{
  return process_mgr_->stringToPid(str);
}

CwshProcess *
Cwsh::
getActiveProcess(const string &str)
{
  return process_mgr_->getActiveProcess(str);
}

CwshProcess *
Cwsh::
getCurrentActiveProcess()
{
  return process_mgr_->getCurrentActiveProcess();
}

CwshProcess *
Cwsh::
lookupProcess(pid_t pid)
{
  return process_mgr_->lookupProcess(pid);
}

//---------------

void
Cwsh::
saveState()
{
  state_mgr_->save(this);
}

void
Cwsh::
restoreState()
{
  state_mgr_->restore();
}

//---------------

void
Cwsh::
startBlock(CwshBlockType type, const CwshLineArray &lines)
{
  block_mgr_->startBlock(type, lines);
}

void
Cwsh::
endBlock()
{
  block_mgr_->endBlock();
}

bool
Cwsh::
inBlock() const
{
  return block_mgr_->inBlock();
}

bool
Cwsh::
blockEof() const
{
  return block_mgr_->eof();
}

CwshLine
Cwsh::
blockReadLine() const
{
  return block_mgr_->readLine();
}

CwshBlock *
Cwsh::
findBlock(CwshBlockType type)
{
  return block_mgr_->find(type);
}

void
Cwsh::
gotoBlockLabel(const string &label)
{
  block_mgr_->gotoLabel(label);
}

bool
Cwsh::
isBlockBreak() const
{
  return block_mgr_->isBreak();
}

bool
Cwsh::
isBlockBreakSwitch() const
{
  return block_mgr_->isBreakSwitch();
}

bool
Cwsh::
isBlockContinue() const
{
  return block_mgr_->isContinue();
}

bool
Cwsh::
isBlockReturn() const
{
  return block_mgr_->isReturn();
}

int
Cwsh::
getBlockGotoDepth() const
{
  return block_mgr_->getGotoDepth();
}

void
Cwsh::
setBlockBreak(bool flag)
{
  return block_mgr_->setBreak(flag);
}

void
Cwsh::
setBlockBreakSwitch(bool flag)
{
  return block_mgr_->setBreakSwitch(flag);
}

void
Cwsh::
setBlockContinue(bool flag)
{
  return block_mgr_->setContinue(flag);
}

void
Cwsh::
setBlockReturn(bool flag)
{
  return block_mgr_->setReturn(flag);
}

//---------------

void
Cwsh::
defineAlias(const CwshAliasName &name, const CwshAliasValue &value)
{
  alias_mgr_->define(name, value);
}

void
Cwsh::
undefineAlias(const CwshAliasName &name)
{
  alias_mgr_->undefine(name);
}

CwshAlias *
Cwsh::
lookupAlias(const CwshAliasName &name) const
{
  return alias_mgr_->lookup(name);
}

bool
Cwsh::
substituteAlias(CwshCmd *cmd, CwshCmdArray &cmds) const
{
  return alias_mgr_->substitute(cmd, cmds);
}

void
Cwsh::
displayAlias() const
{
  alias_mgr_->display();
}

//---------------

void
Cwsh::
defineAutoExec(const CwshAutoExecName &name, const CwshAutoExecValue &value)
{
  auto_exec_mgr_->define(name, value);
}

void
Cwsh::
undefineAutoExec(const CwshAutoExecName &name)
{
  auto_exec_mgr_->undefine(name);
}

CwshAutoExec *
Cwsh::
lookupAutoExec(const CwshAutoExecName &name) const
{
  return auto_exec_mgr_->lookup(name);
}

void
Cwsh::
displayAutoExec() const
{
  auto_exec_mgr_->display();
}

//---------------

int
Cwsh::
getHistoryCommandNum() const
{
  return history_->getCommandNum();
}

bool
Cwsh::
findHistoryCommandStart(const string &text, int &command_num)
{
  return history_->findCommandStart(text, command_num);
}

bool
Cwsh::
findHistoryCommandIn(const string &text, int &command_num)
{
  return history_->findCommandIn(text, command_num);
}

bool
Cwsh::
findHistoryCommandArg(const string &text, int &command_num, int &arg_num)
{
  return history_->findCommandArg(text, command_num, arg_num);
}

string
Cwsh::
getHistoryCommand(int num)
{
  return history_->getCommand(num);
}

string
Cwsh::
getHistoryCommandArg(int num, int arg_num)
{
  return history_->getCommandArg(num, arg_num);
}

void
Cwsh::
addHistoryFile(const string &filename)
{
  history_->addFile(filename);
}

void
Cwsh::
addHistoryCommand(const string &text)
{
  history_->addCommand(text);
}

void
Cwsh::
setHistoryCurrent(const string &text)
{
  history_->setCurrent(text);
}

void
Cwsh::
displayHistory(int num, bool show_numbers, bool show_time, bool reverse)
{
  history_->display(num, show_numbers, show_time, reverse);
}

bool
Cwsh::
hasPrevHistoryCommand()
{
  return history_->hasPrevCommand();
}

bool
Cwsh::
hasNextHistoryCommand()
{
  return history_->hasNextCommand();
}

string
Cwsh::
getPrevHistoryCommand()
{
  return history_->getPrevCommand();
}

string
Cwsh::
getNextHistoryCommand()
{
  return history_->getNextCommand();
}

//------------

CwshShellCommand *
Cwsh::
lookupShellCommand(const string &name) const
{
  return shell_cmd_mgr_->lookup(name);
}

//------------

void
Cwsh::
executeInput(const string &filename)
{
  input_->execute(filename);
}

void
Cwsh::
processInputLine(const CwshLine &line)
{
  input_->processLine(line);
}

void
Cwsh::
getInputBlock(CwshShellCommand *command, CwshLineArray &lines)
{
  input_->getBlock(command, lines);
}

void
Cwsh::
skipInputBlock(const CwshLine &line)
{
  input_->skipBlock(line);
}

bool
Cwsh::
inputEof()
{
  return input_->eof();
}

CwshLine
Cwsh::
getInputLine()
{
  return input_->getLine();
}

string
Cwsh::
getInputPrompt()
{
  if (getSilentMode())
    return "";

  return input_->getPrompt();
}

string
Cwsh::
processInputExprLine(const CwshLine &line)
{
  return input_->processExprLine(line);
}

//------------

string
Cwsh::
readLine()
{
  //struct termios t;

  //if (getSilentMode()) COSPty::set_raw(0, &t);

  string str = read_line_->readLine();

  //if (getSilentMode()) COSPty::reset_raw(0, &t);

  return str;
}

void
Cwsh::
beep()
{
  read_line_->beep();
}

void
Cwsh::
readInterrupt()
{
  read_line_->interrupt();
}

//------------

void
Cwsh::
pushDirStack()
{
  dir_stack_->push();
}

void
Cwsh::
pushDirStack(const string &dirname)
{
  dir_stack_->push(dirname);
}

string
Cwsh::
popDirStack()
{
  return dir_stack_->pop();
}

string
Cwsh::
popDirStack(int pos)
{
  return dir_stack_->pop(pos);
}

int
Cwsh::
sizeDirStack()
{
  return dir_stack_->size();
}

void
Cwsh::
printDirStack(bool /*expand_home*/)
{
  dir_stack_->print();
}

//------------

void
Cwsh::
addFilePath(const string &filename, const string &path)
{
  hash_->addFilePath(filename, path);
}

string
Cwsh::
getFilePath(const string &filename)
{
  return hash_->getFilePath(filename);
}

void
Cwsh::
clearFilePath()
{
  hash_->clearFilePath();
}

void
Cwsh::
printFilePathStats()
{
  hash_->printFilePathStats();
}

void
Cwsh::
setFilePathActive(bool flag)
{
  hash_->setFilePathActive(flag);
}

//------------

void
Cwsh::
limitResource(const string &name, const string &value, bool hard)
{
  resource_->limit(name, value, hard);
}

void
Cwsh::
unlimitAllResources()
{
  resource_->unlimitAll();
}

void
Cwsh::
unlimitResource(const string &name)
{
  resource_->unlimit(name);
}

void
Cwsh::
printAllResources(bool hard)
{
  resource_->printAll(hard);
}

void
Cwsh::
printResource(const string &name, bool hard)
{
  resource_->print(name, hard);
}

void
Cwsh::
readTimeout()
{
#if 0
  string line = read_line_->getBuffer();

  line = colorLine(line);

  read_line_->setBuffer(line);
#endif

  if (server_ != NULL)
    server_->processMessage();
}

string
Cwsh::
colorLine(const string &line)
{
  return "[1m" + line + "[0m";
}

string
Cwsh::
getAliasesMsg() const
{
  return alias_mgr_->getAliasesMsg();
}

string
Cwsh::
getHistoryMsg() const
{
  return history_->getHistoryMsg();
}
##concat##CwshDir.cpp
#include <CwshI.h>

string
CwshDir::
lookup(Cwsh *cwsh, const string &dirname, bool required)
{
  if (CFile::exists(dirname) && CFile::isDirectory(dirname))
    return dirname;

  int len = dirname.size();

  if (len > 0 && (dirname[0] == '/' || dirname[0] == '.')) {
    if (required)
      CWSH_THROWQ(dirname, "No such file or directory.");
    else
      return "";
  }

  CwshVariable *variable = cwsh->lookupVariable("cdpath");

  if (variable == NULL) {
    if (required)
      CWSH_THROWQ(dirname, "No such file or directory.");
    else
      return "";
  }

  int num_values = variable->getNumValues();

  for (int i = 0; i < num_values; ++i) {
    string dirname1 = variable->getValue(i) + "/" + dirname;

    if (CFile::exists(dirname1) && CFile::isDirectory(dirname1)) {
      std::cout << CwshString::replaceHome(dirname1) << std::endl;
      return dirname1;
    }
  }

  if (required)
    CWSH_THROWQ(dirname, "No such file or directory.");
  else
    return "";
}
##concat##CwshDirStack.cpp
#include <CwshI.h>

CwshDirStack::
CwshDirStack()
{
}

void
CwshDirStack::
push()
{
  dir_stack_.push_back(COSFile::getCurrentDir());
}

void
CwshDirStack::
push(const string &dirname)
{
  dir_stack_.push_back(dirname);
}

string
CwshDirStack::
pop()
{
  if (dir_stack_.size() == 0) {
    CTHROW("Directory Stack underflow.");
    return COSFile::getCurrentDir();
  }

  string dirname = dir_stack_[dir_stack_.size() - 1];

  dir_stack_.pop_back();

  return dirname;
}

string
CwshDirStack::
pop(int pos)
{
  int num_dirs = dir_stack_.size();

  if (num_dirs < pos) {
    CTHROW("Directory Stack underflow.");
    return COSFile::getCurrentDir();
  }

  string dirname = dir_stack_[num_dirs - pos - 1];

  for (int i = num_dirs - pos - 1; i < num_dirs - 2; ++i)
    dir_stack_[i] = dir_stack_[i + 1];

  dir_stack_.pop_back();

  return dirname;
}

int
CwshDirStack::
size()
{
  return dir_stack_.size();
}

void
CwshDirStack::
print(ostream &os)
{
  string dirname = COSFile::getCurrentDir();

  os << CwshString::replaceHome(dirname);

  int num_dirs = dir_stack_.size();

  for (int i = num_dirs - 1; i >= 0; i--) {
    os << " ";

    os << CwshString::replaceHome(dir_stack_[i]);
  }

  os << std::endl;
}
##concat##CwshExprEvaluate.cpp
#include <CwshI.h>

CwshExprEvaluate::
CwshExprEvaluate(Cwsh *cwsh, const string &expression) :
 cwsh_(cwsh), expression_(expression)
{
}

int
CwshExprEvaluate::
process()
{
  string value = evaluate();

  if (! CStrUtil::isInteger(value))
    CWSH_THROW("Invalid Expression '" + expression_ + "'");

  int integer = CStrUtil::toInteger(value);

  return integer;
}

string
CwshExprEvaluate::
evaluate()
{
  stack_ = new CwshExprStackStack();

  CwshExprParse parse(cwsh_);

  parse.stack(stack_, expression_);

  string value = evaluateStack();

  stack_ = NULL;

  return value;
}

string
CwshExprEvaluate::
evaluateStack()
{
  stack_->toStart();

  string value = unstack();

  return value;
}

string
CwshExprEvaluate::
unstack()
{
  CwshExprStackNode *initial_stack_node = stack_->getCurrentNode();

  CwshExprStackNode *stack_node = initial_stack_node;

  if (stack_node == NULL)
    CWSH_THROW("Null Expression.");

  bool end_expression = false;
  bool value_on_stack = false;

  while (! end_expression) {
    if      (stack_node->getType() == CWSH_STACK_NODE_TYPE_OPERATOR) {
      if      (stack_node->getOperator()->isUnary()) {
        stack_->toNext();

        value_on_stack = false;
      }
      else if (stack_node->getOperator()->isBinary()) {
        if (checkUnstack(stack_node->getOperator())) {
          stack_->toPrev();

          CwshExprOperator *last_opr = stack_->getLastOperator();

          if      (last_opr->isUnary()) {
            unstackUnary();

            value_on_stack = true;
          }
          else if (last_opr->isBinary()) {
            unstackBinary();

            value_on_stack = true;
          }
          else
            CWSH_THROW("Invalid Operator.");

          stack_->toNext();

          value_on_stack = false;
        }
        else {
          stack_->toNext();

          value_on_stack = false;
        }
      }
      else if (stack_node->getOperator()->getType() ==
                CWSH_EXPR_OPERATOR_TYPE_OPEN_BRACKET) {
        unstackBracketed();

        value_on_stack = true;
      }
      else if (stack_node->getOperator()->isPunctuation())
        end_expression = true;
      else
        CWSH_THROW("Invalid Operator.");
    }
    else if (stack_node->getType() == CWSH_STACK_NODE_TYPE_VALUE) {
      stack_->toNext();

      value_on_stack = true;
    }
    else
      CWSH_THROW("Invalid Character.");

    stack_node = stack_->getCurrentNode();

    if (stack_node == NULL)
      end_expression = true;
  }

  stack_->toPrev();

  if (initial_stack_node == stack_node)
    CWSH_THROW("Null Expression.");

  if (cwsh_->getDebug() && ! value_on_stack)
    std::cerr << "No value on stack" << std::endl;

  string value = backUnstack();

  return value;
}

string
CwshExprEvaluate::
backUnstack()
{
  CwshExprOperator *last_opr = stack_->getLastOperator();

  while (last_opr != NULL &&
         (last_opr->isUnary() || last_opr->isBinary())) {
    if      (last_opr->isUnary())
      unstackUnary();
    else if (last_opr->isBinary())
      unstackBinary();

    last_opr = stack_->getLastOperator();
  }

  string value;

  if (! stack_->pop(value))
    CWSH_THROW("Undefined Value.");

  return value;
}

void
CwshExprEvaluate::
unstackUnary()
{
  string value1;

  if (! stack_->pop(value1))
    CWSH_THROW("Undefined Value.");

  CwshExprOperator *opr;

  if (! stack_->pop(&opr))
    CWSH_THROW("Undefined Operator.");

  CwshExprProcess process;

  string value = process.process(opr, value1);

  stack_->push(value);
}

void
CwshExprEvaluate::
unstackBinary()
{
  string value1;
  string value2;

  if (! stack_->pop(value2))
    CWSH_THROW("Undefined Value.");

  CwshExprOperator *opr;

  if (! stack_->pop(&opr))
    CWSH_THROW("Undefined Operator.");

  if (! stack_->pop(value1))
    CWSH_THROW("Undefined Value.");

  CwshExprProcess process;

  string value = process.process(value1, opr, value2);

  stack_->push(value);
}

void
CwshExprEvaluate::
unstackBracketed()
{
  stack_->toNext();

  string value = unstack();

  stack_->toNext();

  CwshExprOperator *opr;

  if (! stack_->pop(&opr))
    CWSH_THROW("Undefined Operator.");

  if (! stack_->pop(&opr))
    CWSH_THROW("Undefined Operator.");

  stack_->push(value);
}

void
CwshExprEvaluate::
skip()
{
  CwshExprStackNode *stack_node = stack_->getCurrentNode();

  if (stack_node == NULL)
    CWSH_THROW("Null Expression.");

  bool end_expression = false;

  while (! end_expression) {
    if      (stack_node->getType() == CWSH_STACK_NODE_TYPE_OPERATOR) {
      if      (stack_node->getOperator()->isUnary()) {
        stack_->remove(stack_node);

        stack_->toNext();
      }
      else if (stack_node->getOperator()->isBinary()) {
        stack_->remove(stack_node);

        stack_->toNext();
      }
      else if (stack_node->getOperator()->getType() ==
                CWSH_EXPR_OPERATOR_TYPE_OPEN_BRACKET) {
        stack_->remove(stack_node);

        stack_->toNext();

        skip();

        stack_node = stack_->getCurrentNode();

        while (stack_node->getType() != CWSH_STACK_NODE_TYPE_OPERATOR ||
               stack_node->getOperator()->getType() !=
                CWSH_EXPR_OPERATOR_TYPE_CLOSE_BRACKET) {
          stack_->remove(stack_node);

          stack_->toNext();

          skip();

          stack_node = stack_->getCurrentNode();
        }

        stack_->remove(stack_node);

        stack_->toNext();
      }
      else if (stack_node->getOperator()->isPunctuation())
        end_expression = true;
      else
        CWSH_THROW("Invalid Operator.");
    }
    else if (stack_node->getType() == CWSH_STACK_NODE_TYPE_VALUE) {
      stack_->remove(stack_node);

      stack_->toNext();
    }
    else
      CWSH_THROW("Invalid Character.");

    stack_node = stack_->getCurrentNode();

    if (stack_node == NULL)
      end_expression = true;
  }
}

bool
CwshExprEvaluate::
checkUnstack(CwshExprOperator *opr)
{
  CwshExprOperator *last_opr = stack_->getLastOperator();

  if (last_opr != NULL &&
      (last_opr->getPrecedence() > opr->getPrecedence() ||
       (last_opr->getPrecedence() == opr->getPrecedence() &&
        opr->doesAssociateLtoR())))
    return true;
  else
    return false;
}
##concat##CwshExprOperator.cpp
#include <CwshI.h>

/*
 *   Operator Token        | Precedence   | Associativity
 * ------------------------+--------------+--------------
 *                         |              |
 *  (   )                  |  12          |  L -> R
 *  !   ~   +   -          |  11 (unary)  |  R -> L
 *  -d  -e  -f  -o  -r  -w |  11 (unary)  |  R -> L
 *  -x  -z                 |  11 (unary)  |  R -> L
 *  *   /   %              |  10          |  L -> R
 *  +   -                  |   9          |  L -> R
 *  <<  >>                 |   8          |  L -> R
 *  <   <=  >   >=         |   7          |  L -> R
 *  ==  !=                 |   6          |  L -> R
 *  &                      |   5          |  L -> R
 *  ^                      |   4          |  L -> R
 *  |                      |   3          |  L -> R
 *  &&                     |   2          |  L -> R
 *  ||                     |   1          |  L -> R
 *
 */

CwshExprOperator
CwshExprOperator::
operators_[] = {
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_OPEN_BRACKET    , "("  ,
                   12, true , true , false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_CLOSE_BRACKET   , ")"  ,
                   12, true , true , false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_UNARY_PLUS      , "+"  ,
                   11, false, false, true ),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_UNARY_MINUS     , "-"  ,
                   11, false, false, true ),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_LOGICAL_NOT     , "!"  ,
                   11, false, false, true ),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_BIT_NOT         , "~"  ,
                   11, false, false, true ),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_IS_DIRECTORY    , "-d" ,
                   11, false, false, true ),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_IS_FILE         , "-e" ,
                   11, false, false, true ),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_IS_PLAIN        , "-f" ,
                   11, false, false, true ),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_IS_OWNER        , "-o" ,
                   11, false, false, true ),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_IS_READABLE     , "-r" ,
                   11, false, false, true ),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_IS_WRITABLE     , "-w" ,
                   11, false, false, true ),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_IS_EXECUTABLE   , "-x" ,
                   11, false, false, true ),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_IS_ZERO         , "-z" ,
                   11, false, false, true ),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_PLUS            , "+"  ,
                    9, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_MINUS           , "-"  ,
                    9, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_TIMES           , "*"  ,
                   10, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_DIVIDE          , "/"  ,
                   10, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_MODULUS         , "%"  ,
                   10, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_LESS            , "<"  ,
                    7, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_LESS_OR_EQUAL   , "<=" ,
                    7, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_GREATER         , ">"  ,
                    7, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_GREATER_OR_EQUAL, ">=" ,
                    7, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_EQUAL           , "==" ,
                    6, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_NOT_EQUAL       , "!=" ,
                    6, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_MATCH_EQUAL     , "=~" ,
                    6, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_NO_MATCH_EQUAL  , "!~" ,
                    6, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_LOGICAL_AND     , "&&" ,
                    2, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_LOGICAL_OR      , "||" ,
                    1, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_BIT_AND         , "&"  ,
                    5, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_BIT_OR          , "|"  ,
                    3, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_BIT_XOR         , "^"  ,
                    4, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_BIT_LSHIFT      , "<<" ,
                    8, true , false, false),
  CwshExprOperator(CWSH_EXPR_OPERATOR_TYPE_BIT_RSHIFT      , ">>" ,
                    8, true , false, false),
};

int CwshExprOperator::num_operators_ =
  sizeof(CwshExprOperator::operators_)/sizeof(CwshExprOperator);

CwshExprOperator::
CwshExprOperator(CwshExprOperatorType type, const string &token,
                 uint precedence, bool associate_l_to_r,
                 bool punctuation, bool unary) :
 type_(type), token_(token), precedence_(precedence),
 associate_l_to_r_(associate_l_to_r), punctuation_(punctuation),
 unary_(unary)
{
}

CwshExprOperator *
CwshExprOperator::
lookup(CwshExprOperatorType type)
{
  for (int i = 0; i < num_operators_; i++)
    if (operators_[i].type_ == type)
      return &operators_[i];

  CWSH_THROW("Invalid Operator Type");
}
##concat##CwshExprParse.cpp
#include <CwshI.h>

string CwshExprParse::unary_operator_chars_  = "+-!~";
string CwshExprParse::binary_operator_chars_ = "+-*/%<>=!&|^#";
string CwshExprParse::file_operator_chars_   = "deforwxz";

CwshExprParse::
CwshExprParse(Cwsh *cwsh) :
 cwsh_(cwsh)
{
}

string
CwshExprParse::
parse(const string &str, uint *pos)
{
  CStrUtil::skipSpace(str, pos);

  string expr;

  uint len = str.size();

  if (*pos < len && str[*pos] == '(') {
    (*pos)++;

    CStrUtil::skipSpace(str, pos);

    uint j = *pos;

    CwshString::skipWordsToChar(str, pos, ')');

    expr = str.substr(j, *pos - j);

    (*pos)++;
  }
  else
    expr = read(str, pos);

  CStrUtil::skipSpace(str, pos);

  expr = CStrUtil::stripSpaces(expr);

  return expr;
}

string
CwshExprParse::
read(const string &str, uint *pos)
{
  CAutoPtr<CwshExprStackStack> stack;

  stack = new CwshExprStackStack();

  uint j = *pos;

  subStack(stack, str, pos);

  string expr = str.substr(j, *pos - j);

  return expr;
}

void
CwshExprParse::
stack(CwshExprStackStack *stack, const string &expr)
{
  uint pos = 0;

  subStack(stack, expr, &pos);
}

void
CwshExprParse::
subStack(CwshExprStackStack *stack, const string &str, uint *pos)
{
  bool is_expr = false;

  CStrUtil::skipSpace(str, pos);

  uint len = str.size();

  while (*pos < len) {
    /* <expression> := <file_operator> <filename> */

    if      (! is_expr && str[*pos] == '-' &&
             file_operator_chars_.find(str[*pos + 1]) != string::npos) {
      CwshExprOperator *opr = readFileOperator(str, pos);

      stack->push(opr);

      CStrUtil::skipSpace(str, pos);

      string value = readString(str, pos);

      CwshWord word = value;

      CwshWordArray words;

      CwshPattern pattern(cwsh_);

      if (pattern.expandWordToFiles(word, words)) {
        uint num_words = words.size();

        for (uint i = 0; i < num_words; i++)
          stack->push(words[i].getWord());
      }
      else
        stack->push(value);

      is_expr = true;
    }

    /* <expression> := <unary_operator> <expression> */

    else if (! is_expr &&
             unary_operator_chars_.find(str[*pos]) != string::npos) {
      CwshExprOperator *opr = readUnaryOperator(str, pos);

      stack->push(opr);

      subStack(stack, str, pos);

      is_expr = true;
    }

    /* <expression> := <expression> <binary_operator> <expression> */

    else if (is_expr &&
             binary_operator_chars_.find(str[*pos]) != string::npos) {
      CwshExprOperator *opr = readBinaryOperator(str, pos);

      stack->push(opr);

      subStack(stack, str, pos);

      is_expr = true;
    }

    /* <expression> := '(' <expression> ')' */

    else if (! is_expr && str[*pos] == '(') {
      CwshExprOperator *opr =
        CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_OPEN_BRACKET);

      stack->push(opr);

      (*pos)++;

      CStrUtil::skipSpace(str, pos);

      uint pos1 = *pos;

      if (! skipToCloseBracket(str, pos) || str[*pos] != ')')
        CWSH_THROW("Missing Close Round Bracket.");

      string str1 = str.substr(pos1, *pos - pos1);

      (*pos)++;

      pos1 = 0;

      subStack(stack, str1, &pos1);

      CStrUtil::skipSpace(str1, &pos1);

      if (pos1 < str1.size())
        CWSH_THROW("Invalid Expression '" + str1 + "'");

      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_CLOSE_BRACKET);

      stack->push(opr);

      is_expr = true;
    }

    /* <expression> := <integer> */

    else if (! is_expr && isdigit(str[*pos])) {
      string value = readInteger(str, pos);

      stack->push(value);

      is_expr = true;
    }

    /* <expression> := <string_value> */

    else if (! is_expr) {
      string value = readString(str, pos);

      stack->push(value);

      is_expr = true;
    }
    else
      break;

    CStrUtil::skipSpace(str, pos);
  }

  if (! is_expr)
    CWSH_THROW("Null Expression.");
}

CwshExprOperator *
CwshExprParse::
readFileOperator(const string &str, uint *pos)
{
  CwshExprOperator *opr = NULL;

  if (str[*pos] != '-')
    CWSH_THROW("Invalid Operator.");

  (*pos)++;

  switch (str[*pos]) {
    case 'd':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_IS_DIRECTORY);
      break;
    case 'e':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_IS_FILE);
      break;
    case 'f':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_IS_PLAIN);
      break;
    case 'o':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_IS_OWNER);
      break;
    case 'r':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_IS_READABLE);
      break;
    case 'w':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_IS_WRITABLE);
      break;
    case 'x':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_IS_EXECUTABLE);
      break;
    case 'z':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_IS_ZERO);
      break;
    default:
      CWSH_THROW("Invalid Operator.");
      break;
  }

  (*pos)++;

  return opr;
}

CwshExprOperator *
CwshExprParse::
readUnaryOperator(const string &str, uint *pos)
{
  CwshExprOperator *opr = NULL;

  switch (str[*pos]) {
    case '+':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_UNARY_PLUS);

      (*pos)++;

      break;
    case '-':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_UNARY_MINUS);

      (*pos)++;

      break;
    case '!':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_LOGICAL_NOT);

      (*pos)++;

      break;
    case '~':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_BIT_NOT);

      (*pos)++;

      break;
  }

  return opr;
}

CwshExprOperator *
CwshExprParse::
readBinaryOperator(const string &str, uint *pos)
{
  CwshExprOperator *opr = NULL;

  switch (str[*pos]) {
    case '+':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_PLUS);

      (*pos)++;

      break;
    case '-':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_MINUS);

      (*pos)++;

      break;
    case '*':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_TIMES);

      (*pos)++;

      break;
    case '/':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_DIVIDE);

      (*pos)++;

      break;
    case '^':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_BIT_XOR);

      (*pos)++;

      break;
    case '<':
      if      (str[*pos + 1] == '=') {
        opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_LESS_OR_EQUAL);

        (*pos)++;
      }
      else if (str[*pos + 1] == '<') {
        opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_BIT_LSHIFT);

        (*pos)++;
      }
      else
        opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_LESS);

      (*pos)++;

      break;
    case '>':
      if      (str[*pos + 1] == '=') {
        opr = CwshExprOperator::lookup
               (CWSH_EXPR_OPERATOR_TYPE_GREATER_OR_EQUAL);

        (*pos)++;
      }
      else if (str[*pos + 1] == '>') {
        opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_BIT_RSHIFT);

        (*pos)++;
      }
      else
        opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_GREATER);

      (*pos)++;

      break;
    case '=':
      if      (str[*pos + 1] == '=') {
        opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_EQUAL);

        (*pos)++;
        (*pos)++;
      }
      else if (str[*pos + 1] == '~') {
        opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_MATCH_EQUAL);

        (*pos)++;
        (*pos)++;
      }

      break;
    case '!':
      if      (str[*pos + 1] == '=') {
        opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_NOT_EQUAL);

        (*pos)++;
        (*pos)++;
      }
      else if (str[*pos + 1] == '~') {
        opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_NO_MATCH_EQUAL);

        (*pos)++;
        (*pos)++;
      }
      else
        CWSH_THROW("Invalid Operator.");

      break;
    case '&':
      if      (str[*pos + 1] == '&') {
        opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_LOGICAL_AND);

        (*pos)++;
      }
      else
        opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_BIT_AND);

      (*pos)++;

      break;
    case '|':
      if      (str[*pos + 1] == '|') {
        opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_LOGICAL_OR);

        (*pos)++;
      }
      else
        opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_BIT_OR);

      (*pos)++;

      break;
    case '%':
      opr = CwshExprOperator::lookup(CWSH_EXPR_OPERATOR_TYPE_MODULUS);

      (*pos)++;

      break;
    default:
      break;
  }

  return opr;
}

string
CwshExprParse::
readInteger(const string &str, uint *pos)
{
  uint pos1 = *pos;

  if (! CStrUtil::skipInteger(str, pos))
    CWSH_THROW("Invalid Integer Value.");

  string value = str.substr(pos1, *pos - pos1);

  return value;
}

string
CwshExprParse::
readString(const string &str, uint *pos)
{
  string value = "";

  uint len = str.size();

  while (*pos < len) {
    if      (str[*pos] == '\"') {
      uint pos1 = *pos;

      if (! CStrUtil::skipDoubleQuotedString(str, pos))
        CWSH_THROW("Invalid String Value.");

      value += str.substr(pos1, *pos - pos1);
    }
    else if (str[*pos] == '\'') {
      uint pos1 = *pos;

      if (! CStrUtil::skipSingleQuotedString(str, pos))
        CWSH_THROW("Invalid String Value.");

      value += str.substr(pos1, *pos - pos1);
    }
    else if (isspace(str[*pos]))
      break;
    else
      value += str[(*pos)++];
  }

  return value;
}

bool
CwshExprParse::
skipToCloseBracket(const string &str, uint *pos)
{
  uint brackets = 0;

  uint len = str.size();

  while (*pos < len) {
    if      (str[*pos] == '(') {
      ++brackets;

      ++(*pos);
    }
    else if (str[*pos] == ')') {
      if (brackets == 0)
        return true;

      --brackets;

      ++(*pos);
    }
    else if (str[*pos] == '\"') {
      if (! CStrUtil::skipDoubleQuotedString(str, pos))
        CWSH_THROW("Invalid String Value.");
    }
    else if (str[*pos] == '\'') {
      if (! CStrUtil::skipSingleQuotedString(str, pos))
        CWSH_THROW("Invalid String Value.");
    }
    else
      ++(*pos);
  }

  return false;
}
##concat##CwshExprProcess.cpp
#include <CwshI.h>

CwshExprProcess::
CwshExprProcess()
{
}

string
CwshExprProcess::
process(CwshExprOperator *opr, const string &value)
{
  int integer;

  CwshExprProcessValueType type = getValueType(value, &integer);

  switch (opr->getType()) {
    case CWSH_EXPR_OPERATOR_TYPE_UNARY_PLUS:
    case CWSH_EXPR_OPERATOR_TYPE_UNARY_MINUS:
    case CWSH_EXPR_OPERATOR_TYPE_LOGICAL_NOT:
    case CWSH_EXPR_OPERATOR_TYPE_BIT_NOT:
      if (type != CWSH_EXPR_PROCESS_VALUE_TYPE_INTEGER)
        CWSH_THROW("Invalid Type for Operator.");

      break;
    case CWSH_EXPR_OPERATOR_TYPE_IS_DIRECTORY:
    case CWSH_EXPR_OPERATOR_TYPE_IS_FILE:
    case CWSH_EXPR_OPERATOR_TYPE_IS_PLAIN:
    case CWSH_EXPR_OPERATOR_TYPE_IS_OWNER:
    case CWSH_EXPR_OPERATOR_TYPE_IS_READABLE:
    case CWSH_EXPR_OPERATOR_TYPE_IS_WRITABLE:
    case CWSH_EXPR_OPERATOR_TYPE_IS_EXECUTABLE:
    case CWSH_EXPR_OPERATOR_TYPE_IS_ZERO:
      if (type != CWSH_EXPR_PROCESS_VALUE_TYPE_STRING)
        CWSH_THROW("Invalid Type for Operator.");

      break;
    default:
      break;
  }

  switch (opr->getType()) {
    case CWSH_EXPR_OPERATOR_TYPE_UNARY_PLUS:
      break;
    case CWSH_EXPR_OPERATOR_TYPE_UNARY_MINUS:
      integer = -integer;

      break;
    case CWSH_EXPR_OPERATOR_TYPE_LOGICAL_NOT:
      if (! integer)
        integer = true;
      else
        integer = false;

      break;
    case CWSH_EXPR_OPERATOR_TYPE_BIT_NOT:
      integer = ~integer;

      break;
    case CWSH_EXPR_OPERATOR_TYPE_IS_DIRECTORY:
      integer = (CFile::exists(value) && CFile::isDirectory(value));

      break;
    case CWSH_EXPR_OPERATOR_TYPE_IS_FILE:
      integer = CFile::exists(value);

      break;
    case CWSH_EXPR_OPERATOR_TYPE_IS_PLAIN:
      integer = (CFile::exists(value) && CFile::isRegular(value));

      break;
    case CWSH_EXPR_OPERATOR_TYPE_IS_OWNER:
      integer = (CFile::exists(value) && CFile::isOwner(value));

      break;
    case CWSH_EXPR_OPERATOR_TYPE_IS_READABLE:
      integer = (CFile::exists(value) && CFile::isReadable(value));

      break;
    case CWSH_EXPR_OPERATOR_TYPE_IS_WRITABLE:
      integer = (CFile::exists(value) && CFile::isWritable(value));

      break;
    case CWSH_EXPR_OPERATOR_TYPE_IS_EXECUTABLE:
      integer = (CFile::exists(value) && CFile::isExecutable(value));

      break;
    case CWSH_EXPR_OPERATOR_TYPE_IS_ZERO:
      integer = (CFile::exists(value) && CFile::getSize(value) == 0);

      break;
    default:
      break;
  }

  string value1 = CStrUtil::toString(integer);

  return value1;
}

string
CwshExprProcess::
process(const string &value1, CwshExprOperator *opr, const string &value2)
{
  int integer1;
  int integer2;

  CwshExprProcessValueType type1 = getValueType(value1, &integer1);
  CwshExprProcessValueType type2 = getValueType(value2, &integer2);

  switch (opr->getType()) {
    case CWSH_EXPR_OPERATOR_TYPE_PLUS:
    case CWSH_EXPR_OPERATOR_TYPE_MINUS:
    case CWSH_EXPR_OPERATOR_TYPE_TIMES:
    case CWSH_EXPR_OPERATOR_TYPE_DIVIDE:
    case CWSH_EXPR_OPERATOR_TYPE_MODULUS:
    case CWSH_EXPR_OPERATOR_TYPE_LOGICAL_AND:
    case CWSH_EXPR_OPERATOR_TYPE_LOGICAL_OR:
    case CWSH_EXPR_OPERATOR_TYPE_BIT_AND:
    case CWSH_EXPR_OPERATOR_TYPE_BIT_OR:
    case CWSH_EXPR_OPERATOR_TYPE_BIT_XOR:
    case CWSH_EXPR_OPERATOR_TYPE_BIT_LSHIFT:
    case CWSH_EXPR_OPERATOR_TYPE_BIT_RSHIFT:
      if (type1 != CWSH_EXPR_PROCESS_VALUE_TYPE_INTEGER ||
          type2 != CWSH_EXPR_PROCESS_VALUE_TYPE_INTEGER)
        CWSH_THROW("Invalid Type for Operator.");

      break;

    case CWSH_EXPR_OPERATOR_TYPE_MATCH_EQUAL:
    case CWSH_EXPR_OPERATOR_TYPE_NO_MATCH_EQUAL:
      if (type1 != CWSH_EXPR_PROCESS_VALUE_TYPE_STRING ||
          type2 != CWSH_EXPR_PROCESS_VALUE_TYPE_STRING)
        CWSH_THROW("Invalid Type for Operator.");

      break;

    case CWSH_EXPR_OPERATOR_TYPE_LESS:
    case CWSH_EXPR_OPERATOR_TYPE_LESS_OR_EQUAL:
    case CWSH_EXPR_OPERATOR_TYPE_GREATER:
    case CWSH_EXPR_OPERATOR_TYPE_GREATER_OR_EQUAL:
    case CWSH_EXPR_OPERATOR_TYPE_EQUAL:
    case CWSH_EXPR_OPERATOR_TYPE_NOT_EQUAL:
      if (type1 != type2)
        CWSH_THROW("Invalid Type Mix.");

      break;

    default:
      break;
  }

  int integer = 0;

  switch (opr->getType()) {
    case CWSH_EXPR_OPERATOR_TYPE_PLUS:
      integer = integer1 + integer2;

      break;
    case CWSH_EXPR_OPERATOR_TYPE_MINUS:
      integer = integer1 - integer2;

      break;
    case CWSH_EXPR_OPERATOR_TYPE_TIMES:
      integer = integer1 * integer2;

      break;
    case CWSH_EXPR_OPERATOR_TYPE_DIVIDE:
      if (integer2 == 0)
        CWSH_THROW("Divide By Zero.");

      integer = integer1 / integer2;

      break;
    case CWSH_EXPR_OPERATOR_TYPE_MODULUS:
      if (integer2 == 0)
        CWSH_THROW("Divide By Zero.");

      integer = integer1 % integer2;

      break;
    case CWSH_EXPR_OPERATOR_TYPE_LESS:
      if (type1 == CWSH_EXPR_PROCESS_VALUE_TYPE_INTEGER)
        integer = (integer1 < integer2);
      else
        integer = (value1 < value2);

      break;
    case CWSH_EXPR_OPERATOR_TYPE_LESS_OR_EQUAL:
      if (type1 == CWSH_EXPR_PROCESS_VALUE_TYPE_INTEGER)
        integer = (integer1 <= integer2);
      else
        integer = (value1 <= value2);

      break;
    case CWSH_EXPR_OPERATOR_TYPE_GREATER:
      if (type1 == CWSH_EXPR_PROCESS_VALUE_TYPE_INTEGER)
        integer = (integer1 > integer2);
      else
        integer = (value1 > value2);

      break;
    case CWSH_EXPR_OPERATOR_TYPE_GREATER_OR_EQUAL:
      if (type1 == CWSH_EXPR_PROCESS_VALUE_TYPE_INTEGER)
        integer = (integer1 >= integer2);
      else
        integer = (value1 >= value2);

      break;
    case CWSH_EXPR_OPERATOR_TYPE_EQUAL:
      if (type1 == CWSH_EXPR_PROCESS_VALUE_TYPE_INTEGER)
        integer = (integer1 == integer2);
      else
        integer = (value1 == value2);

      break;
    case CWSH_EXPR_OPERATOR_TYPE_NOT_EQUAL:
      if (type1 == CWSH_EXPR_PROCESS_VALUE_TYPE_INTEGER)
        integer = (integer1 != integer2);
      else
        integer = (value1 != value2);

      break;
    case CWSH_EXPR_OPERATOR_TYPE_MATCH_EQUAL: {
      CwshWildCard wildcard(value2);

      integer = wildcard.checkMatch(value1);

      break;
    }
    case CWSH_EXPR_OPERATOR_TYPE_NO_MATCH_EQUAL: {
      CwshWildCard wildcard(value2);

      integer = ! wildcard.checkMatch(value1);

      break;
    }
    case CWSH_EXPR_OPERATOR_TYPE_LOGICAL_AND:
      integer = (integer1 && integer2);

      break;
    case CWSH_EXPR_OPERATOR_TYPE_LOGICAL_OR:
      integer = (integer1 || integer2);

      break;
    case CWSH_EXPR_OPERATOR_TYPE_BIT_AND:
      integer = (integer1 & integer2);

      break;
    case CWSH_EXPR_OPERATOR_TYPE_BIT_OR:
      integer = (integer1 | integer2);

      break;
    case CWSH_EXPR_OPERATOR_TYPE_BIT_XOR:
      integer = (integer1 ^ integer2);

      break;
    case CWSH_EXPR_OPERATOR_TYPE_BIT_LSHIFT:
      integer = (integer1 << integer2);

      break;
    case CWSH_EXPR_OPERATOR_TYPE_BIT_RSHIFT:
      integer = (integer1 >> integer2);

      break;
    default:
      break;
  }

  string value = CStrUtil::toString(integer);

  return value;
}

CwshExprProcessValueType
CwshExprProcess::
getValueType(const string &value, int *integer)
{
  if (CStrUtil::isInteger(value)) {
    *integer = CStrUtil::toInteger(value);

    return CWSH_EXPR_PROCESS_VALUE_TYPE_INTEGER;
  }
  else
    return CWSH_EXPR_PROCESS_VALUE_TYPE_STRING;
}
##concat##CwshExprStack.cpp
#include <CwshI.h>

CwshExprStackStack::
CwshExprStackStack()
{
  current_ = new CwshExprStack();
}

CwshExprStackStack::
~CwshExprStackStack()
{
  std::for_each(stacks_.begin(), stacks_.end(), CDeletePointer());
}

void
CwshExprStackStack::
push(const string &value)
{
  if (current_ != NULL)
    current_->push(value);
}

void
CwshExprStackStack::
push(CwshExprOperator *opr)
{
  if (current_ != NULL)
    current_->push(opr);
}

bool
CwshExprStackStack::
pop(string &value)
{
  if (current_ != NULL) {
    bool flag = current_->pop(value);

    return flag;
  }
  else
    return false;
}

bool
CwshExprStackStack::
pop(CwshExprOperator **opr)
{
  if (current_ != NULL) {
    bool flag = current_->pop(opr);

    return flag;
  }
  else
    return false;
}

void
CwshExprStackStack::
remove(CwshExprStackNode *stack_node)
{
  if (current_ != NULL)
    current_->remove(stack_node);
}

void
CwshExprStackStack::
restart(bool flag)
{
  if (flag) {
    std::for_each(stacks_.begin(), stacks_.end(), CDeletePointer());

    stacks_.clear();
  }

  if (current_ != NULL)
    current_->restart(flag);
}

CwshExprStack *
CwshExprStackStack::
start()
{
  if (current_ != NULL) {
    stacks_.push_back(current_);

    current_.release();
  }

  current_ = new CwshExprStack();

  return current_;
}

void
CwshExprStackStack::
end()
{
  current_ = stacks_[stacks_.size() - 1];

  stacks_.pop_back();
}

void
CwshExprStackStack::
startTemporary()
{
  start();
}

void
CwshExprStackStack::
endTemporary()
{
  end();
}

CwshExprStack *
CwshExprStackStack::
getCurrent() const
{
  return current_;
}

void
CwshExprStackStack::
setCurrent(CwshExprStack *stack)
{
  current_ = stack;
}

void
CwshExprStackStack::
toStart()
{
  if (current_ != NULL)
    current_->toStart();
}

void
CwshExprStackStack::
toEnd()
{
  if (current_ != NULL)
    current_->toEnd();
}

void
CwshExprStackStack::
setInBrackets(bool flag)
{
  if (current_ != NULL)
    current_->setInBrackets(flag);
}

bool
CwshExprStackStack::
getInBrackets()
{
  if (current_ != NULL)
    return current_->getInBrackets();
  else
    return false;
}

void
CwshExprStackStack::
signalRestart()
{
  if (current_ != NULL)
    current_->signalRestart();
}

bool
CwshExprStackStack::
checkRestart()
{
  if (current_ != NULL)
    return current_->checkRestart();
  else
    return false;
}

CwshExprStackNode *
CwshExprStackStack::
getCurrentNode()
{
  if (current_ != NULL)
    return current_->getCurrent();
  else
    return NULL;
}

void
CwshExprStackStack::
toNext()
{
  if (current_ != NULL)
    current_->toNext();
}

void
CwshExprStackStack::
toPrev()
{
  if (current_ != NULL)
    current_->toPrev();
}

void
CwshExprStackStack::
setLastOperator()
{
  if (current_ != NULL)
    current_->setLastOperator();
}

CwshExprOperator *
CwshExprStackStack::
getLastOperator()
{
  if (current_ != NULL)
    return current_->getLastOperator();
  else
    return NULL;
}

//----------

CwshExprStack::
CwshExprStack()
{
  restart_     = false;
  in_bracket_  = false;
  last_opr_    = NULL;
  pstack_node_ = stack_nodes_.begin();
  debug_       = false;
}

CwshExprStack::
~CwshExprStack()
{
  std::for_each(stack_nodes_.begin(), stack_nodes_.end(), CDeletePointer());
}

void
CwshExprStack::
push(const string &value)
{
  if (debug_) {
    dumpStack();
    std::cerr << "Push Value: " << value << std::endl;
  }

  CwshExprStackNode *stack_node = new CwshExprStackNode(value);

  push(stack_node);

  if (debug_)
    dumpStack();
}

void
CwshExprStack::
push(CwshExprOperator *opr)
{
  if (debug_) {
    dumpStack();
    std::cerr << "Push Opr: " << opr->getToken() << std::endl;
  }

  CwshExprStackNode *stack_node = new CwshExprStackNode(opr);

  push(stack_node);

  if (debug_)
    dumpStack();
}

void
CwshExprStack::
push(CwshExprStackNode *stack_node)
{
  if (pstack_node_ != stack_nodes_.end()) {
    pstack_node_++;

    pstack_node_ = stack_nodes_.insert(pstack_node_, stack_node);
  }
  else {
    stack_nodes_.push_front(stack_node);

    pstack_node_ = stack_nodes_.begin();
  }
}

bool
CwshExprStack::
pop(string &value)
{
  if (debug_)
    dumpStack();

  if (pstack_node_ != stack_nodes_.end() &&
      (*pstack_node_)->getType() == CWSH_STACK_NODE_TYPE_VALUE) {
    value = (*pstack_node_)->getValue();

    remove(*pstack_node_);

    if (debug_) {
      std::cerr << "Pop Value: " << value << std::endl;
      dumpStack();
    }

    return true;
  }
  else
    return false;
}

bool
CwshExprStack::
pop(CwshExprOperator **opr)
{
  if (debug_)
    dumpStack();

  if (pstack_node_ != stack_nodes_.end() &&
      (*pstack_node_)->getType() == CWSH_STACK_NODE_TYPE_OPERATOR) {
    *opr = (*pstack_node_)->getOperator();

    remove(*pstack_node_);

    if (debug_) {
      std::cerr << "Pop Opr: " << (*opr)->getToken() << std::endl;
      dumpStack();
    }

    return true;
  }
  else
    return false;
}

void
CwshExprStack::
remove(CwshExprStackNode *stack_node)
{
  pstack_node_--;

  stack_nodes_.remove(stack_node);

  delete stack_node;
}

void
CwshExprStack::
restart(bool flag)
{
  restart_    = flag;
  in_bracket_ = false;
  last_opr_   = NULL;

  std::for_each(stack_nodes_.begin(), stack_nodes_.end(), CDeletePointer());

  stack_nodes_.clear();

  pstack_node_ = stack_nodes_.begin();
}

void
CwshExprStack::
toStart()
{
  restart_    = false;
  in_bracket_ = false;
  last_opr_   = NULL;

  pstack_node_ = stack_nodes_.begin();
}

void
CwshExprStack::
toEnd()
{
  restart_    = false;
  in_bracket_ = false;

  if (stack_nodes_.size() > 0) {
    pstack_node_ = stack_nodes_.end();

    --pstack_node_;
  }
}

void
CwshExprStack::
setInBrackets(bool flag)
{
  in_bracket_ = flag;
}

bool
CwshExprStack::
getInBrackets()
{
  return in_bracket_;
}

void
CwshExprStack::
signalRestart()
{
  restart_ = true;
}

bool
CwshExprStack::
checkRestart()
{
  return restart_;
}

CwshExprStackNode *
CwshExprStack::
getCurrent()
{
  if (pstack_node_ != stack_nodes_.end())
    return *pstack_node_;
  else
    return NULL;
}

void
CwshExprStack::
toNext()
{
  if (pstack_node_ != stack_nodes_.end())
    ++pstack_node_;
}

void
CwshExprStack::
toPrev()
{
  if (pstack_node_ != stack_nodes_.begin())
    --pstack_node_;
}

void
CwshExprStack::
setLastOperator()
{
  last_opr_ = NULL;

  CwshExprStackNodeList::iterator pstack_node1 = stack_nodes_.begin();
  CwshExprStackNodeList::iterator pstack_node2 = stack_nodes_.end  ();

  for ( ; pstack_node1 != pstack_node2; ++pstack_node1) {
    if (pstack_node1 == pstack_node_)
      break;

    if ((*pstack_node1)->getType() == CWSH_STACK_NODE_TYPE_OPERATOR) {
      if ((*pstack_node1)->getOperator()->isPunctuation())
        last_opr_ = NULL;
      else
        last_opr_ = (*pstack_node1)->getOperator();
    }
  }
}

CwshExprOperator *
CwshExprStack::
getLastOperator()
{
  setLastOperator();

  return last_opr_;
}

void
CwshExprStack::
dumpStack()
{
  std::cerr << "Stack: ";

  CwshExprStackNodeList::iterator pstack_node1 = stack_nodes_.begin();
  CwshExprStackNodeList::iterator pstack_node2 = stack_nodes_.end  ();

  for ( ; pstack_node1 != pstack_node2; ++pstack_node1) {
    (*pstack_node1)->dump();

    std::cerr << " ";
  }

  std::cerr << std::endl;

  std::cerr << "Current: ";

  if (pstack_node_ != stack_nodes_.end())
    (*pstack_node_)->dump();
  else
    std::cerr << "End";

  std::cerr << std::endl;
}

CwshExprStackNode::
CwshExprStackNode(const string &value) :
 type_(CWSH_STACK_NODE_TYPE_VALUE), opr_(NULL), value_(value)
{
}

CwshExprStackNode::
CwshExprStackNode(CwshExprOperator *opr) :
 type_(CWSH_STACK_NODE_TYPE_OPERATOR), opr_(opr), value_("")
{
}

CwshExprStackNode::
~CwshExprStackNode()
{
}

void
CwshExprStackNode::
print() const
{
  if (type_ == CWSH_STACK_NODE_TYPE_VALUE)
    std::cout << "Value " << value_ << std::endl;
  else
    std::cout << "Operator " << opr_->getToken() << std::endl;
}

void
CwshExprStackNode::
dump() const
{
  if (type_ == CWSH_STACK_NODE_TYPE_VALUE)
    std::cerr << "<value>" << value_;
  else
    std::cerr << "<opr>" << opr_->getToken();
}
##concat##CwshFunction.cpp
#include <CwshI.h>

CwshFunctionMgr::
CwshFunctionMgr(Cwsh *cwsh) :
 cwsh_(cwsh)
{
}

void
CwshFunctionMgr::
define(const CwshFunctionName &name, const CwshLineArray &lines)
{
  CwshFunction *function = new CwshFunction(cwsh_, name, lines);

  function_list_.setValue(name, function);
}

void
CwshFunctionMgr::
undefine(const CwshFunctionName &name)
{
  function_list_.unsetValue(name);
}

CwshFunction *
CwshFunctionMgr::
lookup(const CwshFunctionName &name)
{
  return function_list_.getValue(name);
}


CwshFunction::
CwshFunction(Cwsh *cwsh, const CwshFunctionName &name, const CwshLineArray &lines) :
 cwsh_(cwsh), name_(name), lines_(lines)
{
}

CwshFunction::
~CwshFunction()
{
}
void
CwshFunction::
runProc(const CwshArgArray &args, CCommand::CallbackData data)
{
  CwshFunction *function = (CwshFunction *) data;

  function->run(args);
}

void
CwshFunction::
run(const CwshArgArray &args)
{
  cwsh_->saveState();

  cwsh_->startBlock(CWSH_BLOCK_TYPE_FUNCTION, lines_);

  cwsh_->defineVariable("argv", args);

  while (! cwsh_->blockEof()) {
    CwshLine line = cwsh_->blockReadLine();

    cwsh_->processInputLine(line);

    if (cwsh_->isBlockReturn())
      break;
  }

  cwsh_->endBlock();

  cwsh_->setBlockReturn(false);

  cwsh_->restoreState();
}

void
CwshFunctionMgr::
listAll()
{
  FunctionList::iterator pfunction1 = function_list_.begin();
  FunctionList::iterator pfunction2 = function_list_.end  ();

  for ( ; pfunction1 != pfunction2; ++pfunction1) {
    CwshFunction *function = (*pfunction1).second;

    std::cout << function->getName() << std::endl;
  }
}
##concat##CwshHash.cpp
#include <CwshI.h>

CwshHash::
CwshHash(Cwsh *cwsh) :
 cwsh_(cwsh), file_path_active_(false)
{
}

void
CwshHash::
addFilePath(const string &filename, const string &path)
{
  if (file_path_active_) {
    file_path_map_[filename] = path;

    if (cwsh_->getDebug())
      std::cerr << "Added (" << filename << "," << path << ") to hash." << std::endl;
  }
}

string
CwshHash::
getFilePath(const string &filename)
{
  if (file_path_active_) {
    CwshHashFilePathMap::iterator p = file_path_map_.find(filename);

    if (p != file_path_map_.end()) {
      if (cwsh_->getDebug())
        std::cerr << "Found (" << filename << "," << (*p).second << ") in hash." << std::endl;

      return (*p).second;
    }

    return "";
  }
  else
    return "";
}

void
CwshHash::
clearFilePath()
{
  file_path_map_.clear();
}

void
CwshHash::
printFilePathStats()
{
  if (file_path_active_)
    std::cout << file_path_map_.size() << " entries." << std::endl;
  else
    std::cout << "inactive." << std::endl;
}

void
CwshHash::
setFilePathActive(bool flag)
{
  file_path_active_ = flag;
}
##concat##CwshHistory.cpp
#include <CwshI.h>
#include <CwshHistoryParser.h>

CwshHistory::
CwshHistory(Cwsh *cwsh) :
 cwsh_(cwsh), command_num_(0)
{
  string filename = getPath();

  addFile(filename);
}

CwshHistory::
~CwshHistory()
{
  updateSize();

  int save_size = getSaveSize();

  if (save_size < getSize())
    history_.resize(save_size);

  if (save_size > 0) {
    string filename = getPath();

    history_.save(filename);
  }
}

bool
CwshHistory::
findCommandStart(const string &str, int &command_num)
{
  string command;

  if (history1_.findCommandStart(str, command, command_num)) {
    command_num = history_.getCommandNum() + 1;
    return true;
  }

  updateSize();

  return history_.findCommandStart(str, command, command_num);
}

bool
CwshHistory::
findCommandIn(const string &str, int &command_num)
{
  string command;

  if (history1_.findCommandIn(str, command, command_num)) {
    command_num = history_.getCommandNum() + 1;
    return true;
  }

  updateSize();

  return history_.findCommandIn(str, command, command_num);
}

bool
CwshHistory::
findCommandArg(const string &str, int &command_num, int &arg_num)
{
  if (history1_.findCommandArg(str, command_num, arg_num)) {
    command_num = history_.getCommandNum() + 1;
    return true;
  }

  updateSize();

  return history_.findCommandArg(str, command_num, arg_num);
}

string
CwshHistory::
getCommand(int num)
{
  updateSize();

  string command;

  if (! history_.getCommand(num, command))
    CWSH_THROW("Invalid history command num");

  return command;
}

string
CwshHistory::
getCommandArg(int num, int arg_num)
{
  updateSize();

  string command, arg;

  if (! history_.getCommandArg(num, arg_num, command, arg))
    CWSH_THROW("Invalid history command/arg num");

  return arg;
}

void
CwshHistory::
addFile(const string &filename)
{
  history_.addFile(filename);

  updateSize();

  command_num_ = history_.getLastCommandNum() + 1;
}

void
CwshHistory::
addCommand(const string &line)
{
  string line1 = CStrUtil::stripSpaces(line);

  if (line1 == "")
    return;

  setCurrent(line1);

  history_.addCommand(line1);

  updateSize();

  command_num_ = history_.getLastCommandNum() + 1;
}

void
CwshHistory::
setCurrent(const string &line)
{
  string line1 = CStrUtil::stripSpaces(line);

  if (line1 == "")
    return;

  history1_.addCommand(line1);

  history1_.resize(1);
}

void
CwshHistory::
display(int num, bool show_numbers, bool show_time, bool reverse)
{
  updateSize();

  if (num > getSize())
    num = -1;

  history_.display(num, show_numbers, show_time, reverse);
}

void
CwshHistory::
updateSize()
{
  int size = getSize();

  history_.resize(size);
}

int
CwshHistory::
getSize() const
{
  CwshVariable *variable = cwsh_->lookupVariable("history");

  if (variable == NULL)
    return 1;

  if (variable->getNumValues() != 1)
    return 1;

  string value = variable->getValue(0);

  if (! CStrUtil::isInteger(value))
    return 1;

  int size = CStrUtil::toInteger(variable->getValue(0));

  if (size < 1)
    return 1;

  return size;
}

int
CwshHistory::
getSaveSize() const
{
  CwshVariable *variable = cwsh_->lookupVariable("savehist");

  if (variable == NULL)
    return 0;

  if (variable->getNumValues() != 1)
    CWSH_THROW("Badly formed number.");

  string value = variable->getValue(0);

  if (! CStrUtil::isInteger(value))
    CWSH_THROW("Badly formed number.");

  return CStrUtil::toInteger(value);
}

bool
CwshHistory::
hasPrevCommand()
{
  string command;

  if (command_num_ <= 0 || ! history_.getCommand(command_num_ - 1, command))
    return false;

  return true;
}

bool
CwshHistory::
hasNextCommand()
{
  return true;
}

string
CwshHistory::
getPrevCommand()
{
  string command;

  if      (  history_.getCommand(command_num_ - 1, command))
    --command_num_;
  else if (! history_.getCommand(command_num_, command))
    command = "";

  return command;
}

string
CwshHistory::
getNextCommand()
{
  string command;

  if (! history_.getCommand(command_num_ + 1, command))
    return "";

  ++command_num_;

  return command;
}

string
CwshHistory::
getPath()
{
  return CStrUtil::concatFileNames(COSUser::getUserHome(), getFilename());
}

string
CwshHistory::
getFilename()
{
  string filename = ".history";

  return filename;
}

string
CwshHistory::
getHistoryMsg() const
{
  string msg;

  CHistory::CommandList::const_iterator p1, p2;

  for (p1 = history_.beginCommand(),
        p2 = history_.endCommand(); p1 != p2; ++p1) {
    if (! msg.empty()) msg += "#";

    msg += CStrUtil::toString((*p1)->getNumber()) + "#";
    msg += (*p1)->getTimeString() + "#";
    msg += (*p1)->getCommand();
  }

  return msg;
}
##concat##CwshHistoryParser.cpp
#include <CwshI.h>
#include <CwshHistoryParser.h>

enum CwshHistoryCommandType {
  CWSH_HISTORY_COMMAND_NONE,
  CWSH_HISTORY_COMMAND_QUICK_SUBSTR,
  CWSH_HISTORY_COMMAND_USE_RESULT,
  CWSH_HISTORY_COMMAND_SEARCH_START,
  CWSH_HISTORY_COMMAND_SEARCH_IN,
  CWSH_HISTORY_COMMAND_SEARCH_ARG
};

enum CwshHistoryModifierType {
  CWSH_HISTORY_MODIFIER_NONE,
  CWSH_HISTORY_MODIFIER_PRINT,
  CWSH_HISTORY_MODIFIER_SUBSTITUTE,
  CWSH_HISTORY_MODIFIER_REPEAT,
  CWSH_HISTORY_MODIFIER_QUOTE_WORDLIST,
  CWSH_HISTORY_MODIFIER_QUOTE_WORDS,
  CWSH_HISTORY_MODIFIER_ROOT,
  CWSH_HISTORY_MODIFIER_EXTENSION,
  CWSH_HISTORY_MODIFIER_HEADER,
  CWSH_HISTORY_MODIFIER_TAIL
};

class CwshHistoryModifier {
 private:
  CwshHistoryModifierType type_;
  bool                    global_;
  string                  old_str_;
  string                  new_str_;

 public:
  CwshHistoryModifier(CwshHistoryModifierType type, bool global,
                      const string &old_str, const string &new_str) :
   type_(type), global_(global), old_str_(old_str), new_str_(new_str) {
  }

  CwshHistoryModifierType getType     () const { return type_   ; }
  bool                    isGlobal    () const { return global_ ; }
  string                  getOldString() const { return old_str_; }
  string                  getNewString() const { return new_str_; }

  void print() const;
};

typedef std::vector<CwshHistoryModifier> CwshHistoryModifierList;

class CwshHistoryOperation {
  CINST_COUNT_MEMBER(CwshHistoryOperation);

 public:
  CwshHistoryOperation(Cwsh *cwsh);
 ~CwshHistoryOperation();

  void setStartPos(int pos) { start_pos_ = pos; }
  void setEndPos  (int pos) { end_pos_   = pos; }

  void setCommandType(CwshHistoryCommandType type) { command_type_ = type; }
  void setCommandNum (int                    num ) { command_num_  = num ; }

  void setNewString(const string &str) { new_str_ = str ; }
  void setOldString(const string &str) { old_str_ = str ; }

  void setStartArgNum(int arg_num) { start_arg_num_ = arg_num; }
  void setEndArgNum  (int arg_num) { end_arg_num_   = arg_num; }

  void setForceArgs(bool flag) { force_args_ = flag; }

  void addModifier(const CwshHistoryModifier &modifier) {
    modifiers_.push_back(modifier);
  }

  string apply(CwshHistoryParser &parser, const string &line);
  string apply(CwshHistoryParser &parser, const string &line, const vector<string> &words);

  void display(const string &str) const;

 private:
  CPtr<Cwsh>              cwsh_;

  int                     start_pos_;
  int                     end_pos_;

  CwshHistoryCommandType  command_type_;
  int                     command_num_;
  string                  old_str_;
  string                  new_str_;

  int                     start_arg_num_;
  int                     end_arg_num_;
  bool                    force_args_;

  CwshHistoryModifierList modifiers_;
};

//---------------

CwshHistoryParser::
CwshHistoryParser(Cwsh *cwsh) :
 cwsh_(cwsh)
{
  pos_       = 0;
  operation_ = NULL;
  print_     = false;
}

CwshHistoryParser::
~CwshHistoryParser()
{
  std::for_each(operations_.begin(), operations_.end(), CDeletePointer());
}

string
CwshHistoryParser::
parseLine(const string &line)
{
  parse(line);

  if (cwsh_->getDebug())
    display();

  string line1 = apply();

  return line1;
}

void
CwshHistoryParser::
parse(const string &str)
{
  str_ = str;

  uint len = str_.size();

  if (len > 0 && str_[0] == '^') {
    operation_ = new CwshHistoryOperation(cwsh_);

    operation_->setStartPos(0);

    operations_.push_back(operation_);

    parseQuickSubStr();

    operation_->setEndPos(pos_);
  }
  else {
    while (pos_ < len) {
      if      (str_[pos_] == '\\') {
        pos_++;

        if (pos_ < len)
          pos_++;
      }
      else if (str_[pos_] == '!') {
        if (isCommand()) {
          operation_ = new CwshHistoryOperation(cwsh_);

          operation_->setStartPos(pos_);

          operations_.push_back(operation_);

          parseCommand();

          operation_->setEndPos(pos_);
        }
        else
          pos_++;
      }
      else
        pos_++;
    }
  }
}

bool
CwshHistoryParser::
isCommand()
{
  int pos1 = pos_;

  int len = str_.size();

  if (pos1 >= len || str_[pos1] != '!')
    return false;

  pos1++;

  if (pos1 >= len)
    return false;

  if (str_[pos1] == '=' || str_[pos1] == '~' || isspace(str_[pos1]))
    return false;

  return true;
}

void
CwshHistoryParser::
parseCommand()
{
  pos_++;

  //------

  parseSubStr();

  //------

  parseArgSelector();

  //------

  while (parseModifier())
    ;
}

void
CwshHistoryParser::
parseSubStr()
{
  uint len = str_.size();

  if (pos_ < len && str_[pos_] == '!') {
    pos_++;

    int command_num = cwsh_->getHistoryCommandNum();

    operation_->setCommandNum(command_num - 1);

    return;
  }

  if (pos_ < len && str_[pos_] == '#') {
    int pos1 = pos_ - 1;

    pos_++;

    operation_->setCommandType(CWSH_HISTORY_COMMAND_USE_RESULT);
    operation_->setNewString  (str_.substr(0, pos1));

    return;
  }

  if (pos_ < len && isdigit(str_[pos_])) {
    int pos1 = pos_;

    bool numeric = true;

    while (pos_ < len && isSubStrChar(str_[pos_])) {
      if (! isdigit(str_[pos_]))
        numeric = false;

      pos_++;
    }

    string str = str_.substr(pos1, pos_ - pos1);

    if (numeric)
      operation_->setCommandNum(CStrUtil::toInteger(str));
    else {
      operation_->setCommandType(CWSH_HISTORY_COMMAND_SEARCH_START);
      operation_->setNewString  (str);
    }

    return;
  }

  if (pos_ < len - 1 &&
      str_[pos_] == '-' && isdigit(str_[pos_ + 1])) {
    pos_++;

    int pos1 = pos_;

    bool numeric = true;

    while (pos_ < len && isSubStrChar(str_[pos_])) {
      if (! isdigit(str_[pos_]))
        numeric = false;

      pos_++;
    }

    string str = str_.substr(pos1, pos_ - pos1);

    if (numeric) {
      int command_num = cwsh_->getHistoryCommandNum();

      operation_->setCommandNum(command_num - CStrUtil::toInteger(str));
    }
    else {
      operation_->setCommandType(CWSH_HISTORY_COMMAND_SEARCH_START);
      operation_->setNewString  (str);
    }

    return;
  }

  if (pos_ < len && str_[pos_] == '?') {
    pos_++;

    int pos1 = pos_;

    while (pos_ < len && str_[pos_] != '?')
      pos_++;

    string str = str_.substr(pos1, pos_ - pos1);

    if (str_[pos_] == '?')
      pos_++;

    if (pos_ < len && str_[pos_] == '%') {
      pos_++;

      int command_num = cwsh_->getHistoryCommandNum();

      operation_->setCommandType(CWSH_HISTORY_COMMAND_SEARCH_ARG);
      operation_->setCommandNum (command_num - 1);
      operation_->setNewString  (str);
    }
    else {
      operation_->setCommandType(CWSH_HISTORY_COMMAND_SEARCH_IN);
      operation_->setNewString  (str);
    }

    return;
  }

  if (pos_ < len && str_[pos_] == '{') {
    pos_++;

    int pos1 = pos_;

    while (pos_ < len && str_[pos_] != '}')
      pos_++;

    string str = str_.substr(pos1, pos_ - pos1);

    if (str_[pos_] == '}')
      pos_++;

    operation_->setCommandType(CWSH_HISTORY_COMMAND_SEARCH_START);
    operation_->setNewString  (str);

    return;
  }

  if (str_[pos_] == '^' || str_[pos_] == '$' ||
      str_[pos_] == '*' || str_[pos_] == ':') {
    int command_num = cwsh_->getHistoryCommandNum();

    operation_->setCommandNum(command_num - 1);

    return;
  }

  int pos1 = pos_;

  while (pos_ < len && isSubStrChar(str_[pos_]))
    pos_++;

  string str = str_.substr(pos1, pos_ - pos1);

  operation_->setCommandType(CWSH_HISTORY_COMMAND_SEARCH_START);
  operation_->setNewString  (str);
}

void
CwshHistoryParser::
parseArgSelector()
{
  bool colon_found = false;

  // Check if we have a Arg Selector

  uint len = str_.size();

  uint pos1 = pos_;

  if (pos1 >= len)
    return;

  if (str_[pos1] == ':') {
    colon_found = true;

    pos1++;
  }

  if (pos1 >= len)
    return;

  if (! (colon_found && isdigit(str_[pos1])) &&
      str_[pos1] != '^' && str_[pos1] != '$' &&
      str_[pos1] != '-' && str_[pos1] != '*')
    return;

  //------

  pos1 = pos_;

  if (str_[pos_] == ':')
    pos_++;

  if      (str_[pos_] == '^') {
    pos_++;

    operation_->setStartArgNum(1);

    if      (pos_ < len && str_[pos_] == '-') {
      pos_++;

      if (pos_ < len && isdigit(str_[pos_])) {
        int integer;

        CStrUtil::readInteger(str_, &pos_, &integer);

        operation_->setEndArgNum(integer);
      }
      else
        pos_--;
    }
    else if (pos_ < len && str_[pos_] == '$') {
      pos_++;

      operation_->setEndArgNum(-1);
    }
    else
      operation_->setEndArgNum(1);
  }
  else if (str_[pos_] == '$') {
    pos_++;

    operation_->setStartArgNum(-1);
    operation_->setEndArgNum  (-1);
  }
  else if (str_[pos_] == '*') {
    pos_++;

    operation_->setStartArgNum(1);
    operation_->setEndArgNum  (-1);
    operation_->setForceArgs  (true);
  }
  else if (str_[pos_] == '-') {
    operation_->setStartArgNum(0);

    pos_++;

    if      (pos_ < len && isdigit(str_[pos_])) {
      int integer;

      CStrUtil::readInteger(str_, &pos_, &integer);

      operation_->setEndArgNum(integer);
    }
    else if (pos_ < len && str_[pos_] == '$') {
      pos_++;

      operation_->setEndArgNum(-1);
    }
    else
      pos_--;
  }
  else if (isdigit(str_[pos_])) {
    int integer;

    CStrUtil::readInteger(str_, &pos_, &integer);

    operation_->setStartArgNum(integer);
    operation_->setEndArgNum  (integer);

    if      (pos_ < len && str_[pos_] == '-') {
      pos_++;

      if      (pos_ < len && isdigit(str_[pos_])) {
        int integer;

        CStrUtil::readInteger(str_, &pos_, &integer);

        operation_->setEndArgNum(integer);
      }
      else if (pos_ < len && str_[pos_] == '$') {
        pos_++;

        operation_->setEndArgNum(-1);
      }
      else
        operation_->setEndArgNum(-2);
    }
    else if (pos_ < len && str_[pos_] == '*')
      operation_->setEndArgNum(-1);
  }
}

bool
CwshHistoryParser::
parseModifier()
{
  // Check if we have a History Modifier

  uint len = str_.size();

  uint pos1 = pos_;

  if (pos1 >= len)
    return false;

  if (str_[pos1] != ':')
    return false;

  pos1++;

  if (pos1 >= len)
    return false;

  if (str_[pos1] == 'g') {
    pos1++;

    if (pos1 >= len)
      return false;

    if (str_[pos1] != 's' && str_[pos1] != 'r' && str_[pos1] != 'e' &&
        str_[pos1] != 'h' && str_[pos1] != 't')
      return false;
  }
  else {
    if (str_[pos1] != 'p' && str_[pos1] != 's' && str_[pos1] != '&' &&
        str_[pos1] != 'q' && str_[pos1] != 'x' && str_[pos1] != 'r' &&
        str_[pos1] != 'e' && str_[pos1] != 'h' && str_[pos1] != 't')
      return false;
  }

  //------

  // Parse History Modifier

  bool global = false;

  pos_++;

  if (str_[pos_] == 'g') {
    pos_++;

    global = true;
  }

  CwshHistoryModifierType type = CWSH_HISTORY_MODIFIER_NONE;

  string old_str;
  string new_str;

  if      (str_[pos_] == 'p') {
    pos_++;

    type = CWSH_HISTORY_MODIFIER_PRINT;
  }
  else if (str_[pos_] == 's') {
    pos_++;

    type = CWSH_HISTORY_MODIFIER_SUBSTITUTE;

    if (pos_ >= len || str_[pos_] != '/')
      CWSH_THROW("Bad substitute.");

    pos_++;

    int pos1 = pos_;

    while (pos_ < len && str_[pos_] != '/')
      pos_++;

    old_str = str_.substr(pos1, pos_ - pos1);

    if (pos_ < len)
      pos_++;

    pos1 = pos_;

    while (pos_ < len && str_[pos_] != '/')
      pos_++;

    new_str = str_.substr(pos1, pos_ - pos1);

    if (pos_ < len)
      pos_++;
  }
  else if (str_[pos_] == '&') {
    pos_++;

    type = CWSH_HISTORY_MODIFIER_REPEAT;
  }
  else if (str_[pos_] == 'q') {
    pos_++;

    type = CWSH_HISTORY_MODIFIER_QUOTE_WORDLIST;
  }
  else if (str_[pos_] == 'x') {
    pos_++;

    type = CWSH_HISTORY_MODIFIER_QUOTE_WORDS;
  }
  else if (str_[pos_] == 'r') {
    pos_++;

    type = CWSH_HISTORY_MODIFIER_ROOT;
  }
  else if (str_[pos_] == 'e') {
    pos_++;

    type = CWSH_HISTORY_MODIFIER_EXTENSION;
  }
  else if (str_[pos_] == 'h') {
    pos_++;

    type = CWSH_HISTORY_MODIFIER_HEADER;
  }
  else if (str_[pos_] == 't') {
    pos_++;

    type = CWSH_HISTORY_MODIFIER_TAIL;
  }
  else
    CWSH_THROW("Bad modifier.");

  CwshHistoryModifier modifier(type, global, old_str, new_str);

  operation_->addModifier(modifier);

  return true;
}

void
CwshHistoryParser::
parseQuickSubStr()
{
  int command_num = cwsh_->getHistoryCommandNum();

  operation_->setCommandNum (command_num - 1);
  operation_->setCommandType(CWSH_HISTORY_COMMAND_QUICK_SUBSTR);

  //------

  uint len = str_.size();

  pos_++;

  //------

  uint pos1 = pos_;

  while (pos_ < len && str_[pos_] != '^')
    pos_++;

  operation_->setOldString(str_.substr(pos1, pos_ - pos1));

  if (pos_ < len)
    pos_++;

  //------

  pos1 = pos_;

  while (pos_ < len && str_[pos_] != '^')
    pos_++;

  operation_->setNewString(str_.substr(pos1, pos_ - pos1));

  if (pos_ < len)
    pos_++;
}

string
CwshHistoryParser::
apply()
{
  string str = str_;

  uint num_operations = operations_.size();

  for (int i = num_operations - 1; i >= 0; i--)
    str = operations_[i]->apply(*this, str);

  if (print_) {
    std::cout << str << std::endl;

    throw CwshHistoryIgnore();
  }

  return str;
}

string
CwshHistoryParser::
apply(const vector<string> &words)
{
  string str = str_;

  uint num_operations = operations_.size();

  if (num_operations > 0) {
    for (int i = num_operations - 1; i >= 0; i--)
      str = operations_[i]->apply(*this, str, words);
  }
  else
    str += " " + CStrUtil::toString(words, 1);

  if (print_) {
    std::cout << str << std::endl;

    throw CwshHistoryIgnore();
  }

  return str;
}

void
CwshHistoryParser::
display() const
{
  uint num_operations = operations_.size();

  for (uint i = 0; i < num_operations; i++)
    operations_[i]->display(str_);
}

bool
CwshHistoryParser::
isSubStrChar(char c)
{
  if (c != '^' && c != '$' && c != '-' && c != '*' &&
      c != '#' && c != ':' && ! isspace(c))
    return true;

  return false;
}

//---------------

CwshHistoryOperation::
CwshHistoryOperation(Cwsh *cwsh) :
 cwsh_(cwsh)
{
  start_pos_     = 0;
  end_pos_       = 0;
  command_num_   = 0;
  start_arg_num_ = 0;
  end_arg_num_   = -1;
  force_args_    = false;
  command_type_  = CWSH_HISTORY_COMMAND_NONE;
  old_str_       = "";
  new_str_       = "";
}

CwshHistoryOperation::
~CwshHistoryOperation()
{
}

string
CwshHistoryOperation::
apply(CwshHistoryParser &parser, const string &line)
{
  string lstr = line.substr(0, start_pos_);

  string rstr;

  uint len = line.size();

  if (end_pos_ < (int) len)
    rstr = line.substr(end_pos_);

  string command;

  if      (command_type_ == CWSH_HISTORY_COMMAND_QUICK_SUBSTR) {
    command = cwsh_->getHistoryCommand(command_num_);

    string::size_type pos = command.find(old_str_);

    if (pos == string::npos)
      CWSH_THROW("Modifier failed.");

    string::size_type pos1 = pos + old_str_.size() - 1;

    string commandl = command.substr(0, pos);

    string commandr;

    if (pos1 + 1 < command.size())
      commandr = command.substr(pos1 + 1);

    command = commandl + new_str_ + commandr;
  }
  else if (command_type_ == CWSH_HISTORY_COMMAND_USE_RESULT)
    command = new_str_;
  else if      (command_type_ == CWSH_HISTORY_COMMAND_SEARCH_START) {
    if (! cwsh_->findHistoryCommandStart(new_str_, command_num_))
      CWSH_THROW(new_str_ + ": Event not found.");

    command = cwsh_->getHistoryCommand(command_num_);
  }
  else if (command_type_ == CWSH_HISTORY_COMMAND_SEARCH_IN) {
    if (! cwsh_->findHistoryCommandIn(new_str_, command_num_))
      CWSH_THROW(new_str_ + ": Event not found.");

    command = cwsh_->getHistoryCommand(command_num_);
  }
  else if (command_type_ == CWSH_HISTORY_COMMAND_SEARCH_ARG) {
    int arg_num;

    if (! cwsh_->findHistoryCommandArg(new_str_, command_num_, arg_num))
      CWSH_THROW(new_str_ + ": Event not found.");

    command = cwsh_->getHistoryCommandArg(command_num_, arg_num);
  }
  else
    command = cwsh_->getHistoryCommand(command_num_);

  CStrWords words = CStrUtil::toWords(command, NULL);

  if (start_arg_num_ < 0)
    start_arg_num_ += words.size();

  if (end_arg_num_ < 0)
    end_arg_num_ += words.size();

  if (start_arg_num_ < 0 || start_arg_num_ >= words.size() ||
      end_arg_num_   < 0 || end_arg_num_   >= words.size() ||
      start_arg_num_ > end_arg_num_) {
    if (! force_args_)
      CWSH_THROW("Bad ! arg selector.");

    command = "";
  }
  else {
    if (start_arg_num_ != 0 || end_arg_num_ != words.size() - 1)
      words.truncate(start_arg_num_, end_arg_num_);
  }

  command = CStrUtil::toString(words, " ");

  int num_modifiers = modifiers_.size();

  for (int i = 0; i < num_modifiers; i++) {
    CwshHistoryModifierType  type    = modifiers_[i].getType();
    bool                     global  = modifiers_[i].isGlobal();
    const string            &new_str = modifiers_[i].getNewString();
    const string            &old_str = modifiers_[i].getOldString();

    if      (type == CWSH_HISTORY_MODIFIER_PRINT)
      parser.setPrint(true);
    else if (type == CWSH_HISTORY_MODIFIER_SUBSTITUTE) {
      if (! global) {
        string::size_type pos = command.find(old_str);

        if (pos == string::npos)
          CWSH_THROW("Modifier failed.");

        string::size_type pos1 = pos + old_str.size() - 1;

        string commandl = command.substr(0, pos);

        string commandr;

        if (pos1 + 1 < command.size())
          commandr = command.substr(pos1 + 1);

        command = commandl + new_str + commandr;
      }
      else {
        string::size_type pos = command.rfind(old_str);

        if (pos == string::npos)
          CWSH_THROW("Modifier failed.");

        string::size_type pos1 = pos + old_str.size() - 1;

        string commandl = command.substr(0, pos);

        string commandr;

        if (pos1 + 1 < command.size())
          commandr = command.substr(pos1 + 1);

        command = commandl + new_str + commandr;

        string::size_type last_pos = pos;

        pos = command.rfind(old_str);

        while (pos != string::npos && pos < last_pos) {
          string::size_type pos1 = pos + old_str.size() - 1;

          string commandl = command.substr(0, pos);

          string commandr;

          if (pos1 + 1 < command.size())
            commandr = command.substr(pos1 + 1);

          command = commandl + new_str + commandr;

          last_pos = pos;

          pos = command.rfind(old_str);
        }
      }
    }
    else if (type == CWSH_HISTORY_MODIFIER_REPEAT) {
    }
    else if (type == CWSH_HISTORY_MODIFIER_QUOTE_WORDLIST) {
    }
    else if (type == CWSH_HISTORY_MODIFIER_QUOTE_WORDS) {
    }
    else if (type == CWSH_HISTORY_MODIFIER_ROOT) {
      CStrWords words = CStrUtil::toWords(command, NULL);

      int num_words = words.size();

      for (int i = 0; i < num_words; i++) {
        string word = words[i].getWord();

        string::size_type pos = word.rfind('.');

        if (pos != string::npos)
          words.truncateWord(i, 0, pos - 1);

        if (! global)
          break;
      }

      command = CStrUtil::toString(words, " ");
    }
    else if (type == CWSH_HISTORY_MODIFIER_EXTENSION) {
      CStrWords words = CStrUtil::toWords(command, NULL);

      int num_words = words.size();

      for (int i = 0; i < num_words; i++) {
        string word = words[i].getWord();

        string::size_type pos = word.rfind('.');

        if (pos != string::npos)
          words.truncateWord(i, pos + 1, words.size() - 1);

        if (! global)
          break;
      }

      command = CStrUtil::toString(words, " ");
    }
    else if (type == CWSH_HISTORY_MODIFIER_HEADER) {
      CStrWords words = CStrUtil::toWords(command, NULL);

      int num_words = words.size();

      for (int i = 0; i < num_words; i++) {
        string word = words[i].getWord();

        string::size_type pos = word.rfind('/');

        if (pos != string::npos)
          words.truncateWord(i, 0, pos - 1);

        if (! global)
          break;
      }

      command = CStrUtil::toString(words, " ");
    }
    else if (type == CWSH_HISTORY_MODIFIER_TAIL) {
      CStrWords words = CStrUtil::toWords(command, NULL);

      int num_words = words.size();

      for (int i = 0; i < num_words; i++) {
        string word = words[i].getWord();

        string::size_type pos = word.rfind('/');

        if (pos != string::npos)
          words.truncateWord(i, pos + 1, words.size() - 1);

        if (! global)
          break;
      }

      command = CStrUtil::toString(words, " ");
    }
  }

  string line1 = lstr + command + rstr;

  return line1;
}

string
CwshHistoryOperation::
apply(CwshHistoryParser &parser, const string &line,
      const vector<string> &words)
{
  int command_num = cwsh_->getHistoryCommandNum();

  if (command_num_ != command_num - 1)
    CWSH_THROW("Bad ! arg selector.");

  string lstr = line.substr(0, start_pos_);

  string rstr;

  int len = line.size();

  if (end_pos_ < len)
    rstr = line.substr(end_pos_);

  int num_words = words.size();

  if (start_arg_num_ < 0)
    start_arg_num_ += num_words;

  if (end_arg_num_ < 0)
    end_arg_num_ += num_words;

  string command;

  if (start_arg_num_ < 0 || start_arg_num_ >= num_words ||
      end_arg_num_   < 0 || end_arg_num_   >= num_words ||
      start_arg_num_ > end_arg_num_) {
    if (! force_args_)
      CWSH_THROW("Bad ! arg selector.");
  }
  else {
    if (start_arg_num_ != 0 || end_arg_num_ != num_words - 1)
      command = CStrUtil::toString(words, start_arg_num_, end_arg_num_);
    else
      command = CStrUtil::toString(words, " ");
  }

  int num_modifiers = modifiers_.size();

  for (int i = 0; i < num_modifiers; i++) {
    CwshHistoryModifierType  type    = modifiers_[i].getType();
    bool                     global  = modifiers_[i].isGlobal();
    const string            &new_str = modifiers_[i].getNewString();
    const string            &old_str = modifiers_[i].getOldString();

    if      (type == CWSH_HISTORY_MODIFIER_PRINT)
      parser.setPrint(true);
    else if (type == CWSH_HISTORY_MODIFIER_SUBSTITUTE) {
      if (! global) {
        string::size_type pos = command.find(old_str);

        if (pos == string::npos)
          CWSH_THROW("Modifier failed.");

        string::size_type pos1 = pos + old_str.size() - 1;

        string commandl = command.substr(0, pos);

        string commandr;

        if (pos1 + 1 < command.size())
          commandr = command.substr(pos1 + 1);

        command = commandl + new_str + commandr;
      }
      else {
        string::size_type pos = command.rfind(old_str);

        if (pos == string::npos)
          CWSH_THROW("Modifier failed.");

        string::size_type pos1 = pos + old_str.size() - 1;

        string commandl = command.substr(0, pos);

        string commandr;

        if (pos1 + 1 < command.size())
          commandr = command.substr(pos1 + 1);

        command = commandl + new_str + commandr;

        string::size_type last_pos = pos;

        pos = command.rfind(old_str);

        while (pos != string::npos && pos < last_pos) {
          string::size_type pos1 = pos + old_str.size() - 1;

          string commandl = command.substr(0, pos);

          string commandr;

          if (pos1 + 1 < command.size())
            commandr = command.substr(pos1 + 1);

          command = commandl + new_str + commandr;

          last_pos = pos;

          pos = command.rfind(old_str);
        }
      }
    }
    else if (type == CWSH_HISTORY_MODIFIER_REPEAT) {
    }
    else if (type == CWSH_HISTORY_MODIFIER_QUOTE_WORDLIST) {
    }
    else if (type == CWSH_HISTORY_MODIFIER_QUOTE_WORDS) {
    }
    else if (type == CWSH_HISTORY_MODIFIER_ROOT) {
      CStrWords words1 = CStrUtil::toWords(command, NULL);

      int num_words1 = words1.size();

      for (int i = 0; i < num_words1; i++) {
        string word = words1[i].getWord();

        string::size_type pos = word.rfind('.');

        if (pos != string::npos)
          words1.truncateWord(i, 0, pos - 1);

        if (! global)
          break;
      }

      command = CStrUtil::toString(words1, " ");
    }
    else if (type == CWSH_HISTORY_MODIFIER_EXTENSION) {
      CStrWords words1 = CStrUtil::toWords(command, NULL);

      int num_words1 = words1.size();

      for (int i = 0; i < num_words1; i++) {
        string word = words1[i].getWord();

        string::size_type pos = word.rfind('.');

        if (pos != string::npos)
          words1.truncateWord(i, pos + 1, words1.size() - 1);

        if (! global)
          break;
      }

      command = CStrUtil::toString(words1, " ");
    }
    else if (type == CWSH_HISTORY_MODIFIER_HEADER) {
      CStrWords words1 = CStrUtil::toWords(command, NULL);

      int num_words1 = words1.size();

      for (int i = 0; i < num_words1; i++) {
        string word = words1[i].getWord();

        string::size_type pos = word.rfind('/');

        if (pos != string::npos)
          words1.truncateWord(i, 0, pos - 1);

        if (! global)
          break;
      }

      command = CStrUtil::toString(words1, " ");
    }
    else if (type == CWSH_HISTORY_MODIFIER_TAIL) {
      CStrWords words1 = CStrUtil::toWords(command, NULL);

      int num_words1 = words1.size();

      for (int i = 0; i < num_words1; i++) {
        string word = words1[i].getWord();

        string::size_type pos = word.rfind('/');

        if (pos != string::npos)
          words1.truncateWord(i, pos + 1, words1.size() - 1);

        if (! global)
          break;
      }

      command = CStrUtil::toString(words1, " ");
    }
  }

  string line1 = lstr + command + rstr;

  return line1;
}

void
CwshHistoryOperation::
display(const string &str) const
{
  string command = str.substr(start_pos_, end_pos_ - start_pos_);

  std::cout << "Command " << command << std::endl;

  if      (command_type_ == CWSH_HISTORY_COMMAND_QUICK_SUBSTR)
    std::cout << "Replace " << old_str_ << " with " << new_str_ << std::endl;
  else if (command_type_ == CWSH_HISTORY_COMMAND_USE_RESULT)
    std::cout << "Result " << new_str_ << std::endl;
  else {
    if      (command_type_ == CWSH_HISTORY_COMMAND_SEARCH_START)
      std::cout << "Last Command with " << new_str_ << " at start" << std::endl;
    else if (command_type_ == CWSH_HISTORY_COMMAND_SEARCH_IN)
      std::cout << "Last Command with " << new_str_ << " anywhere" << std::endl;
    else if (command_type_ == CWSH_HISTORY_COMMAND_SEARCH_ARG)
      std::cout << "Last Arg with " << new_str_ << " anywhere" << std::endl;
    else
      std::cout << "Command Num " << command_num_ << std::endl;

    std::cout << "Args " << start_arg_num_ << " " << end_arg_num_ << std::endl;
  }

  int num_modifiers = modifiers_.size();

  for (int i = 0; i < num_modifiers; i++)
    modifiers_[i].print();
}

void
CwshHistoryModifier::
print() const
{
  if      (type_ == CWSH_HISTORY_MODIFIER_PRINT)
    std::cout << "Print" << std::endl;
  else if (type_ == CWSH_HISTORY_MODIFIER_SUBSTITUTE) {
    if (global_)
      std::cout << "Globally ";

    std::cout << "Substitute " << old_str_ << " with " << new_str_ << std::endl;
  }
  else if (type_ == CWSH_HISTORY_MODIFIER_REPEAT) {
    if (global_)
      std::cout << "Globally ";

    std::cout << "Repeat" << std::endl;
  }
  else if (type_ == CWSH_HISTORY_MODIFIER_QUOTE_WORDLIST)
    std::cout << "Quote Wordlist";
  else if (type_ == CWSH_HISTORY_MODIFIER_QUOTE_WORDS)
    std::cout << "Quote Words";
  else if (type_ == CWSH_HISTORY_MODIFIER_ROOT) {
    if (global_)
      std::cout << "Globally ";

    std::cout << "Root" << std::endl;
  }
  else if (type_ == CWSH_HISTORY_MODIFIER_EXTENSION) {
    if (global_)
      std::cout << "Globally ";

    std::cout << "Extension" << std::endl;
  }
  else if (type_ == CWSH_HISTORY_MODIFIER_HEADER) {
    if (global_)
      std::cout << "Globally ";

    std::cout << "Header" << std::endl;
  }
  else if (type_ == CWSH_HISTORY_MODIFIER_TAIL) {
    if (global_)
      std::cout << "Globally ";

    std::cout << "Tail" << std::endl;
  }
}
##concat##CwshInPlaceCommand.cpp
#include <CwshI.h>

CwshInPlaceCommand::
CwshInPlaceCommand(Cwsh *cwsh, const CwshWord &word) :
 cwsh_(cwsh), word_(word)
{
}

bool
CwshInPlaceCommand::
expand(CwshWordArray &words)
{
  bool flag = false;

  const CwshSubWordArray &sub_words = word_.getSubWords();

  string str1;

  int num_sub_words = sub_words.size();

  for (int i = 0; i < num_sub_words; i++) {
    CwshSubWordType type = sub_words[i].getType();

    string sub_str;

    if      (type == CWSH_SUB_WORD_TYPE_BACK_QUOTED) {
      sub_str = expandCommand(sub_words[i].getWord());

      flag = true;
    }
    else if (type == CWSH_SUB_WORD_TYPE_DOUBLE_QUOTED) {
      string sub_str1;

      if (expandQuotedWord(CwshWord(sub_words[i].getWord()), sub_str1)) {
        sub_str = '"' + sub_str1 + '"';

        flag = true;
      }
      else
        sub_str = sub_words[i].getString();
    }
    else
      sub_str = sub_words[i].getString();

    str1 += sub_str;
  }

  if (flag) {
    CwshWord::toWords(str1, words);

    if (cwsh_->getDebug()) {
      std::cerr << "Expand In Place String to Words" << std::endl;

      CwshWord::printWords(words);
    }
  }

  return flag;
}

bool
CwshInPlaceCommand::
expandQuotedWord(const CwshWord &word, string &word1)
{
  bool flag = false;

  const CwshSubWordArray &sub_words = word.getSubWords();

  int num_sub_words = sub_words.size();

  for (int i = 0; i < num_sub_words; i++) {
    CwshSubWordType type = sub_words[i].getType();

    string sub_word;

    if (type == CWSH_SUB_WORD_TYPE_BACK_QUOTED) {
      sub_word = expandCommand(sub_words[i].getWord());

      flag = true;
    }
    else
      sub_word = sub_words[i].getString();

    word1 += sub_word;
  }

  return flag;
}

string
CwshInPlaceCommand::
expandCommand(const string &str)
{
  // Convert Line to Command Groups

  CwshCmdGroupArray groups;

  CwshCommandUtil::parseCommandGroups(cwsh_, str, groups);

  //------

  string output;

  int num_groups = groups.size();

  for (int i = 0; i < num_groups; i++) {
    CwshCmdArray cmds = CwshCommandUtil::parseCommandGroup(cwsh_, groups[i]);

    //------

    // Execute Commands

    output = executeCommands(cmds);
  }

  //------

  std::for_each(groups.begin(), groups.end(), CDeletePointer());

  //------

  if (cwsh_->getDebug()) {
    std::cerr << "Expand Command '" << str << "' to '" << output << "'" << std::endl;
  }

  return output;
}

string
CwshInPlaceCommand::
executeCommands(const CwshCmdArray &cmds)
{
  string output;

  //------

  // Execute Commands

  vector<CwshCommandData *> pcommands;

  int num_cmds = cmds.size();

  for (int i = 0; i < num_cmds; i++) {
    if (cwsh_->getDebug()) {
      std::cerr << "Execute Command: ";

      cmds[i]->display();
    }

    CwshCmdSeparatorType separator = cmds[i]->getSeparator().getType();

    // Get Command

    vector<string> words;

    int num_words = cmds[i]->getNumWords();

    for (int j = 0; j < num_words; j++)
      words.push_back(cmds[i]->getWord(j).getWord());

    CAutoPtr<CwshCommandData> command;

    command = new CwshCommandData(cwsh_, words);

    CwshCommand *command1 = command->getCommand();

    if (command1 == NULL)
      continue;

    // Set Redirection

    if (cmds[i]->hasStdInFile())
      command1->addFileSrc(cmds[i]->getStdInFile());

    if (cmds[i]->hasStdOutFile()) {
      command1->addFileDest(cmds[i]->getStdOutFile(), 1);

      CwshVariable *variable = cwsh_->lookupVariable("noclobber");

      if (cmds[i]->getStdOutClobber() || variable == NULL)
        command1->setFileDestOverwrite(true, 1);
      else
        command1->setFileDestOverwrite(false, 1);

      if (cmds[i]->getStdOutAppend())
        command1->setFileDestAppend(true, 1);
    }

    if (cmds[i]->hasStdErrFile()) {
      if (! cmds[i]->hasStdOutFile()) {
        command1->addFileDest(cmds[i]->getStdErrFile(), 1);

        CwshVariable *variable = cwsh_->lookupVariable("noclobber");

        if (cmds[i]->getStdErrClobber() || variable == NULL)
          command1->setFileDestOverwrite(true, 1);
        else
          command1->setFileDestOverwrite(false, 1);

        if (cmds[i]->getStdErrAppend())
          command1->setFileDestAppend(true, 1);
      }

      command1->addFileDest(cmds[i]->getStdErrFile(), 2);

      CwshVariable *variable = cwsh_->lookupVariable("noclobber");

      if (cmds[i]->getStdErrClobber() || variable == NULL)
        command1->setFileDestOverwrite(true, 2);
      else
        command1->setFileDestOverwrite(false, 2);

      if (cmds[i]->getStdErrAppend())
        command1->setFileDestAppend(true, 2);
    }

    // Run Command

    if (separator != CWSH_COMMAND_SEPARATOR_PIPE &&
        separator != CWSH_COMMAND_SEPARATOR_PIPE_ERR) {
      int num_pcommands = pcommands.size();

      if (num_pcommands > 0) {
        command1->addPipeSrc();

        for (int k = 0; k < num_pcommands - 1; k++)
          pcommands[k]->getCommand()->start();

        pcommands[num_pcommands - 1]->getCommand()->start();

        int num_cmds = cmds.size();

        if (i == num_cmds - 1) {
          command1->addStringDest(output);

          separator = CWSH_COMMAND_SEPARATOR_NORMAL;
        }

        command1->start();

        for (int k = 0; k < num_pcommands; k++)
          pcommands[k]->getCommand()->wait();

        if (separator != CWSH_COMMAND_SEPARATOR_BACKGROUND) {
          command1->wait();

          int status = command1->getReturnCode();

          cwsh_->defineVariable("status", status);

          std::for_each(pcommands.begin(), pcommands.end(), CDeletePointer());

          if (separator == CWSH_COMMAND_SEPARATOR_AND && status != 0)
            break;

          if (separator == CWSH_COMMAND_SEPARATOR_OR && status == 0)
            break;
        }
        else {
          CwshProcess *process = cwsh_->addProcess(command.release());

          int pid = command1->getPid();

          std::cout << "[" << process->getNum() << "] " << pid << std::endl;
        }

        pcommands.clear();
      }
      else {
        int num_cmds = cmds.size();

        if (i == num_cmds - 1) {
          command1->addStringDest(output);

          separator = CWSH_COMMAND_SEPARATOR_NORMAL;
        }

        command1->start();

        if (separator != CWSH_COMMAND_SEPARATOR_BACKGROUND) {
          command1->wait();

          int status = command1->getReturnCode();

          cwsh_->defineVariable("status", status);

          if (separator == CWSH_COMMAND_SEPARATOR_AND && status != 0)
            break;

          if (separator == CWSH_COMMAND_SEPARATOR_OR && status == 0)
            break;
        }
        else {
          CwshProcess *process = cwsh_->addProcess(command.release());

          int pid = command1->getPid();

          std::cout << "[" << process->getNum() << "] " << pid << std::endl;
        }
      }
    }
    else {
      if (pcommands.size() > 0)
        command1->addPipeSrc();

      if (separator == CWSH_COMMAND_SEPARATOR_PIPE)
        command1->addPipeDest(1);
      else {
        command1->addPipeDest(1);
        command1->addPipeDest(2);
      }

      pcommands.push_back(command.release());
    }
  }

  return CStrUtil::compressSpaces(output);
}
##concat##CwshInput.cpp
#include <CwshI.h>
#include <CwshHistoryParser.h>
#include <CRGBName.h>
#include <CEscape.h>
#include <cstdio>

CwshInput::
CwshInput(Cwsh *cwsh) :
 cwsh_(cwsh)
{
  history_active_  = false;
  input_file_      = NULL;
  current_command_ = NULL;
}

CwshInput::
~CwshInput()
{
}

void
CwshInput::
execute(const string &filename)
{
  CFile file(filename);

  execute(&file);
}

void
CwshInput::
execute(CFile *file)
{
  bool save_history_active = history_active_;

  CFile *save_file = input_file_;

  input_file_ = file;

  if (! file->isStdIn())
    executeFile();
  else
    executeStdIn();

  input_file_ = save_file;

  history_active_ = save_history_active;
}

void
CwshInput::
executeFile()
{
  history_active_ = false;

  CwshLineArray lines;

  string line, line1;

  while (input_file_->readLine(line)) {
    uint len = line.size();

    if (len == 0)
      continue;

    if (line[len - 1] == '\\') {
      if (line1 != "")
        line1 += " " + line.substr(0, len - 1);
      else
        line1 = line.substr(0, len - 1);

      continue;
    }

    if (line1 != "")
      line = line1 + " " + line;

    lines.push_back(line);

    line1 = "";
  }

  if (line1 != "")
    lines.push_back(line1);

  if (lines.empty())
    return;

  executeLines(lines);
}

void
CwshInput::
executeStdIn()
{
  history_active_ = true;

  executeLines(true);
}

void
CwshInput::
executeLine(string &line)
{
  vector<string> lines;

  lines.push_back(line);

  executeLines(lines);
}

void
CwshInput::
executeLines(vector<string> &lines)
{
  cwsh_->startBlock(CWSH_BLOCK_TYPE_FILE, lines);

  executeLines(false);

  cwsh_->endBlock();
}

void
CwshInput::
executeLines(bool interactive)
{
  string line;

  while (! eof()) {
    line = getLine();

    if (interactive && cwsh_->getSilentMode()) {
      printf("%s", CEscape::commandToEscape(line, COSFile::getCurrentDir(), true).c_str());
      fflush(stdout);
    }

    processLine(line);

    if (interactive && cwsh_->getSilentMode()) {
      printf("%s", CEscape::commandToEscape(line, COSFile::getCurrentDir(), false).c_str());
      fflush(stdout);
    }

    if (cwsh_->getExit())
      break;
  }
}

bool
CwshInput::
eof()
{
  if (cwsh_->inBlock())
    return cwsh_->blockEof();

  return false;
}

void
CwshInput::
getBlock(CwshShellCommand *shell_command, CwshLineArray &lines)
{
  CwshPromptType prompt_type    = cwsh_->getPromptType();
  string         prompt_command = cwsh_->getPromptCommand();

  cwsh_->setPromptType   (CWSH_PROMPT_TYPE_EXTRA);
  cwsh_->setPromptCommand(shell_command->getName());

  while (! eof()) {
    string line = getLine();

    vector<string> words;

    CwshString::addWords(line, words);

    if (words.size() > 0) {
      string name = words[0];

      if (name == shell_command->getEndName())
        break;

      lines.push_back(line);

      CwshShellCommand *shell_command1 = cwsh_->lookupShellCommand(name);

      if (shell_command1 != NULL && shell_command1->isBlockCommand()) {
        CwshLineArray lines1;

        getBlock(shell_command1, lines1);

        copy(lines1.begin(), lines1.end(), back_inserter(lines));

        lines.push_back(shell_command1->getEndName());
      }
    }
    else
      lines.push_back(line);
  }

  cwsh_->setPromptType   (prompt_type);
  cwsh_->setPromptCommand(prompt_command);
}

void
CwshInput::
skipBlock(const string &line)
{
  vector<string> words;

  CwshString::addWords(line, words);

  if (words.size() == 0)
    return;

  CwshShellCommand *shell_command = cwsh_->lookupShellCommand(words[0]);

  if (shell_command == NULL || ! shell_command->isBlockCommand())
    return;

  CwshLineArray lines;

  getBlock(shell_command, lines);
}

string
CwshInput::
getLine()
{
  if (cwsh_->inBlock())
    return cwsh_->blockReadLine();

  string line;

  if (input_file_->isStdIn()) {
    line = cwsh_->readLine();

    if (line.size() > 0 && line[line.size() - 1] == '\\') {
      CwshPromptType prompt_type    = cwsh_->getPromptType();
      string         prompt_command = cwsh_->getPromptCommand();

      cwsh_->setPromptType   (CWSH_PROMPT_TYPE_EXTRA);
      cwsh_->setPromptCommand("");

      while (line.size() > 0 && line[line.size() - 1] == '\\') {
        string line1 = cwsh_->readLine();

        line = line.substr(0, line.size() - 1) + "\n" + line1;
      }

      cwsh_->setPromptType   (prompt_type);
      cwsh_->setPromptCommand(prompt_command);
    }

    cwsh_->displayExitedProcesses();
  }
  else {
    line = CwshString::readLineFromFile(input_file_);

    while (line.size() > 0 && line[line.size() - 1] == '\\') {
      string line1 = CwshString::readLineFromFile(input_file_);

      line = line.substr(0, line.size() - 1) + "\n" + line1;
    }
  }

  return line;
}

void
CwshInput::
processLine(const string &line)
{
  try {
    string line1;

    //------

    uint i = 0;

    CStrUtil::skipSpace(line, &i);

    uint len = line.size();

    if (i < len && line[i] != '#')
      line1 = line;

    //------

    // History Substitution

    bool output = false;

    CwshHistoryParser parser(cwsh_);

    string line2 = parser.parseLine(line1);

    if (line2 != line1) {
      output = true;

      line1 = line2;
    }

    //------

    // Remove Extra Spaces

    vector<string> words1;

    CwshString::addWords(line1, words1);

    line1 = CStrUtil::toString(words1, " ");

    //------

    // Output Line if Verbose

    CwshVariable *variable = cwsh_->lookupVariable("verbose");

    if (variable != NULL)
      output = true;

    if (output)
      std::cout << line1 << std::endl;

    //------

    // Set Current History Command

    cwsh_->setHistoryCurrent(line1);

    //------

    // Ignore if Blank Line or Comment

    if (line1 == "")
      return;

    //------

    // Add Command To History

    if (history_active_)
      cwsh_->addHistoryCommand(line1);

    //------

    // Convert Line to Command Lines

    CwshCmdGroupArray groups;

    CwshCommandUtil::parseCommandGroups(cwsh_, line1, groups);

    //------

    uint num_groups = groups.size();

    for (uint i = 0; i < num_groups; i++) {
      // Parse Command

      CwshCmdArray cmds = CwshCommandUtil::parseCommandGroup(cwsh_, groups[i]);

      // Execute Commands

      executeCommands(cmds);
    }

    //------

    std::for_each(groups.begin(), groups.end(), CDeletePointer());
  }
  catch (CwshHistoryIgnore i) {
    ;
  }
  catch (struct CwshErr *cthrow) {
    string qualifier = cthrow->qualifier;

    if (qualifier == "" && current_command_ != NULL)
      qualifier = current_command_->getCommand()->getName();

    if (cwsh_->getDebug())
      std::cerr << "[" << cthrow->file << ":" << cthrow->line << "] ";

    if (qualifier != "")
      std::cerr << qualifier << ": " << cthrow->message << std::endl;
    else
      std::cerr << cthrow->message << std::endl;
  }
  catch (...) {
    std::cerr << "Unhandled Exception thrown" << std::endl;
  }
}

void
CwshInput::
executeCommands(const CwshCmdArray &cmds)
{
  vector<CwshCommandData *>  pcommands;
  vector<string>             delete_files;
  CwshCommandData           *first_command = NULL;

  int num_cmds = cmds.size();

  for (int i = 0; i < num_cmds; i++) {
    if (cwsh_->getDebug()) {
      std::cerr << "Execute Command: ";

      cmds[i]->display();
    }

    //-----

    // Get Command

    vector<string> words;

    int num_words = cmds[i]->getNumWords();

    for (int j = 0; j < num_words; j++)
      words.push_back(cmds[i]->getWord(j).getWord());

    CwshCommandData *command = new CwshCommandData(cwsh_, words);

    CwshCommand *ccommand = command->getCommand();

    if (ccommand == NULL) {
      delete command;
      continue;
    }

    current_command_ = command;

    //-----

    // Echo Command

    CwshVariable *variable = cwsh_->lookupVariable("echo");

    if (variable != NULL)
      std::cout << ccommand->getCommandString() << std::endl;

    //-----

    // Set Redirection

    if      (cmds[i]->hasStdInToken()) {
      const string &filename = readStdInToken(cmds[i]->getStdInToken());

      ccommand->addFileSrc(filename);

      delete_files.push_back(filename);
    }
    else if (cmds[i]->hasStdInFile())
      ccommand->addFileSrc(cmds[i]->getStdInFile());

    if (cmds[i]->hasStdOutFile()) {
      ccommand->addFileDest(cmds[i]->getStdOutFile(), 1);

      CwshVariable *variable = cwsh_->lookupVariable("noclobber");

      if (cmds[i]->getStdOutClobber() || variable == NULL)
        ccommand->setFileDestOverwrite(true, 1);
      else
        ccommand->setFileDestOverwrite(false, 1);

      if (cmds[i]->getStdOutAppend())
        ccommand->setFileDestAppend(true, 1);
    }

    if (cmds[i]->hasStdErrFile()) {
      if (! cmds[i]->hasStdOutFile()) {
        ccommand->addFileDest(cmds[i]->getStdErrFile(), 1);

        CwshVariable *variable = cwsh_->lookupVariable("noclobber");

        if (cmds[i]->getStdErrClobber() || variable == NULL)
          ccommand->setFileDestOverwrite(true, 1);
        else
          ccommand->setFileDestOverwrite(false, 1);

        if (cmds[i]->getStdErrAppend())
          ccommand->setFileDestAppend(true, 1);
      }

      ccommand->addFileDest(cmds[i]->getStdErrFile(), 2);

      CwshVariable *variable = cwsh_->lookupVariable("noclobber");

      if (cmds[i]->getStdErrClobber() || variable == NULL)
        ccommand->setFileDestOverwrite(true, 2);
      else
        ccommand->setFileDestOverwrite(false, 2);

      if (cmds[i]->getStdErrAppend())
        ccommand->setFileDestAppend(true, 2);
    }

    // Run Command

    CwshCmdSeparatorType separator = cmds[i]->getSeparator().getType();

    if (separator != CWSH_COMMAND_SEPARATOR_PIPE &&
        separator != CWSH_COMMAND_SEPARATOR_PIPE_ERR) {
      int num_pcommands = pcommands.size();

      if (num_pcommands > 0) {
        ccommand->addPipeSrc();

        for (int k = 0; k < num_pcommands - 1; k++) {
          CwshCommand *pccommand = pcommands[k]->getCommand();

          if (first_command == NULL) {
            first_command = pcommands[k];

            pccommand->setProcessGroupLeader();
          }
          else
            pccommand->setProcessGroup(first_command->getCommand());

          pccommand->start();
        }

        CwshCommand *pccommand = pcommands[num_pcommands - 1]->getCommand();

        if (first_command == NULL) {
          first_command = pcommands[num_pcommands - 1];

          pccommand->setProcessGroupLeader();
        }
        else
          pccommand->setProcessGroup(first_command->getCommand());

        pccommand->start();

        ccommand->setProcessGroup(first_command->getCommand());

        ccommand->start();

        //------

        CwshProcess *process = cwsh_->addProcess(first_command);

        for (int k = 0; k < num_pcommands; k++)
          if (pcommands[k] != first_command)
            process->addSubCommand(pcommands[k]);

        if (first_command != command)
          process->addSubCommand(command);

        //------

        if (separator != CWSH_COMMAND_SEPARATOR_BACKGROUND) {
          for (int k = 0; k < num_pcommands; k++) {
            CwshCommand *pccommand = pcommands[k]->getCommand();

            pccommand->wait();
          }

          ccommand->wait();

          int status = ccommand->getReturnCode();

          cwsh_->defineVariable("status", status);

          std::for_each(pcommands.begin(), pcommands.end(), CDeletePointer());

          cwsh_->removeProcess(process);

          current_command_ = NULL;

          if (separator == CWSH_COMMAND_SEPARATOR_AND && status != 0)
            break;

          if (separator == CWSH_COMMAND_SEPARATOR_OR && status == 0)
            break;
        }
        else {
          std::cout << "[" << process->getNum() << "]";

          for (int k = 0; k < num_pcommands; k++) {
            CwshCommand *pccommand = pcommands[k]->getCommand();

            std::cout << " " << pccommand->getPid();
          }

          std::cout << " " << ccommand->getPid() << std::endl;
        }

        pcommands.clear();
      }
      else {
        if (ccommand->getDoFork()) {
          if (first_command == NULL) {
            first_command = command;

            ccommand->setProcessGroupLeader();
          }
          else
            ccommand->setProcessGroup(first_command->getCommand());
        }

        ccommand->start();

        CwshProcess *process = cwsh_->addProcess(first_command);

        if (separator != CWSH_COMMAND_SEPARATOR_BACKGROUND) {
          ccommand->wait();

          if (ccommand->getState() == CCommand::EXITED_STATE) {
            int status = ccommand->getReturnCode();

            cwsh_->defineVariable("status", status);

            cwsh_->removeProcess(process);

            current_command_ = NULL;

            if (separator == CWSH_COMMAND_SEPARATOR_AND && status != 0)
              break;

            if (separator == CWSH_COMMAND_SEPARATOR_OR && status == 0)
              break;
          }
          else {
            int pid = ccommand->getPid();

            std::cout << "[" << process->getNum() << "] " << pid << std::endl;
          }
        }
        else {
          int pid = ccommand->getPid();

          std::cout << "[" << process->getNum() << "] " << pid << std::endl;
        }
      }
    }
    else {
      if (pcommands.size() > 0)
        ccommand->addPipeSrc();

      ccommand->addPipeDest(1);

      if (separator == CWSH_COMMAND_SEPARATOR_PIPE_ERR)
        ccommand->addPipeDest(2);

      pcommands.push_back(command);
    }
  }

  int num_delete_files = delete_files.size();

  for (int i = 0; i < num_delete_files; i++)
    unlink(delete_files[i].c_str());
}

string
CwshInput::
readStdInToken(const string &token)
{
  CTempFile temp_file;

  cwsh_->setPromptType(CWSH_PROMPT_TYPE_EXTRA);

  while (1) {
    string line = cwsh_->readLine();

    if (line == token)
      break;

    if (token[0] != '"') {
      string line1 = processStdInLine(line);

      temp_file.getFile()->write(line1 + "\n");
    }
    else
      temp_file.getFile()->write(line + "\n");
  }

  temp_file.getFile()->close();

  cwsh_->setPromptType(CWSH_PROMPT_TYPE_NORMAL);

  return temp_file.getFile()->getPath();
}

string
CwshInput::
processStdInLine(const string &line)
{
  CwshWordArray words;

  CwshWord::toWords(line, words);

  if (cwsh_->getDebug()) {
    std::cerr << "Std In Line to Words" << std::endl;

    CwshWord::printWords(words);
  }

  int num_words = words.size();

  //------

  // Replace Variables

  CwshWordArray variable_words;

  for (int i = 0; i < num_words; i++) {
    CwshWordArray words2;

    CwshVariableParser vparser(cwsh_, words[i]);

    if (vparser.expandVariables(words2))
      copy(words2.begin(), words2.end(), back_inserter(variable_words));
    else
      variable_words.push_back(words[i]);
  }

  int num_variable_words = variable_words.size();

  //------

  // Replace backquotes

  CwshWordArray cmd_words;

  for (int i = 0; i < num_variable_words; i++) {
    const CwshWord &word = variable_words[i];

    CwshWordArray in_place_words;

    CwshInPlaceCommand icmd(cwsh_, word);

    if (icmd.expand(in_place_words)) {
      int num_in_place_words = in_place_words.size();

      for (int k = 0; k < num_in_place_words; ++k)
        cmd_words.push_back(in_place_words[k]);
    }
    else
      cmd_words.push_back(word);
  }

  //------

  return CwshWord::toString(cmd_words);
}

string
CwshInput::
processExprLine(const string &line)
{
  CwshWordArray words;

  CwshWord::toWords(line, words);

  if (cwsh_->getDebug()) {
    std::cerr << "Expr Line to Words" << std::endl;

    CwshWord::printWords(words);
  }

  int num_words = words.size();

  //------

  // Replace Variables

  CwshWordArray variable_words;

  for (int i = 0; i < num_words; i++) {
    CwshWordArray twords;

    CwshVariableParser vparser(cwsh_, words[i]);

    if (vparser.expandVariables(twords))
      copy(twords.begin(), twords.end(), back_inserter(variable_words));
    else
      variable_words.push_back(words[i]);
  }

  int num_variable_words = variable_words.size();

  //------

  // Replace backquotes

  CwshWordArray cmd_words;

  for (int i = 0; i < num_variable_words; i++) {
    const CwshWord &word = variable_words[i];

    CwshWordArray twords;

    CwshInPlaceCommand icmd(cwsh_, variable_words[i]);

    if (icmd.expand(twords))
      copy(twords.begin(), twords.end(), back_inserter(cmd_words));
    else
      cmd_words.push_back(word);
  }

  int num_cmd_words = cmd_words.size();

  //------

  // Expand Tildes

  for (int i = 0; i < num_cmd_words; i++) {
    string str;

    if (CFile::expandTilde(cmd_words[i].getWord(), str))
      cmd_words[i] = CwshWord(str);
  }

  //------

  // Expand Braces

  CwshWordArray brace_words;

  for (int i = 0; i < num_cmd_words; i++) {
    const CwshWord &word = cmd_words[i];

    CwshWordArray twords;

    if (CwshBraces::expand(word, twords))
      copy(twords.begin(), twords.end(), back_inserter(brace_words));
    else
      brace_words.push_back(word);
  }

  int num_brace_words = brace_words.size();

  //------

  // Expand Wildcards

  CwshWordArray wildcard_words;

  for (int i = 0; i < num_brace_words; i++) {
    const CwshWord &word = brace_words[i];

    CwshWordArray twords;

    CwshPattern pattern(cwsh_);

    if (pattern.expandWordToFiles(word, twords))
      copy(twords.begin(), twords.end(), back_inserter(wildcard_words));
    else
      wildcard_words.push_back(word);
  }

  //------

  return CwshWord::toString(wildcard_words);
}

string
CwshInput::
getPrompt()
{
  CwshVariable *prompt_var;

  if (cwsh_->getPromptType() == CWSH_PROMPT_TYPE_NORMAL)
    prompt_var = cwsh_->lookupVariable("prompt");
  else
    prompt_var = cwsh_->lookupVariable("prompt1");

  CwshVariable *color_var = cwsh_->lookupVariable("prompt_color");

  string prompt_string;

  if (cwsh_->getPromptType() != CWSH_PROMPT_TYPE_NORMAL)
    prompt_string += cwsh_->getPromptCommand();

  if (prompt_var)
    prompt_string += prompt_var->getValue(0);
  else {
    if (cwsh_->getPromptType() == CWSH_PROMPT_TYPE_NORMAL)
      prompt_string += "> ";
    else
      prompt_string += "? ";
  }

  if (color_var) {
    double r, g, b;

    if (CRGBName::lookup(color_var->getValue(0), &r, &g, &b)) {
      int fg = (b >= 0.5 ? 4 : 0) | (g >= 0.5 ? 2 : 0) | (r >= 0.5 ? 1 : 0);

      prompt_string = CStrUtil::strprintf("[%dm", 30 + fg) + prompt_string + "[0m";
    }
  }

  return prompt_string;
}
##concat##CwshMain.cpp
#include <CwshLib.h>

int
main(int argc, char **argv)
{
  Cwsh *cwsh = new Cwsh;

  try {
    cwsh->init(argc, argv);

    cwsh->mainLoop();
  }
  catch (struct CwshErr *err) {
    err->print();
  }
  catch (...) {
    std::cerr << "Unhandled exception" << std::endl;
  }

  return 0;
}
##concat##CwshMatch.cpp
#include <CwshI.h>
#include <CFileMatch.h>

#ifdef COS_TERM
#include <COSTerm.h>
#endif

CwshMatch::
CwshMatch(Cwsh *cwsh) :
 cwsh_(cwsh) {
}

bool
CwshMatch::
showMatch(const string &line)
{
  string word;

  CwshComplete complete(cwsh_, line);

  CwshCompletionType type = complete.getCompletionType(&word);

  if (type == CWSH_COMPLETION_TYPE_NONE) {
    cwsh_->beep();

    return false;
  }

  word += "*";

  vector<string> words;

  if      (type == CWSH_COMPLETION_TYPE_COMMAND)
    getPathMatch(word, words);
  else if (type == CWSH_COMPLETION_TYPE_FILE) {
    string::size_type pos = word.rfind('/');

    if (pos != string::npos) {
      string lhs = word.substr(0, pos);
      string rhs = word.substr(pos + 1);

      CDir::enter(lhs);

      getFileMatch(rhs, words);

      CDir::leave();
    }
    else
      getFileMatch(word, words);
  }
  else if (type == CWSH_COMPLETION_TYPE_VAR)
    getVarMatch(word, words);
  else if (type == CWSH_COMPLETION_TYPE_USERS)
    getUsersMatch(word, words);
  else
    return false;

  CStrUtil::sort(words);

  vector<string> uniq_words;

  CStrUtil::uniq(words, uniq_words);

  std::cout << std::endl;

  print(uniq_words);

  return true;
}

bool
CwshMatch::
getPathMatch(const string &pattern_str, vector<string> &words)
{
  CwshPattern pattern(cwsh_, pattern_str);

  if (! pattern.expandPath(words)) {
    cwsh_->beep();

    return false;
  }

  return true;
}

bool
CwshMatch::
getFileMatch(const string &pattern_str, vector<string> &words)
{
  CFileMatch fileMatch;

  if (! fileMatch.matchPrefix(pattern_str, words)) {
    cwsh_->beep();

    return false;
  }

  return true;
}

bool
CwshMatch::
getVarMatch(const string &pattern_str, vector<string> &words)
{
  CwshPattern pattern(cwsh_, pattern_str);

  if (! pattern.expandVar(words)) {
    cwsh_->beep();

    return false;
  }

  return true;
}

bool
CwshMatch::
getUsersMatch(const string &pattern_str, vector<string> &words)
{
  if (! CwshString::matchUsers(pattern_str, words)) {
    cwsh_->beep();

    return false;
  }

  return true;
}

void
CwshMatch::
print(vector<string> &words)
{
  int max_len = CStrUtil::maxLen(words);

  int screen_width = 80;

#ifdef COS_TERM
  int screen_height;

  COSTerm::getCharSize(&screen_width, &screen_height);
#endif

  int num_words = words.size();

  int words_per_line = std::max(screen_width / (max_len + 1), 1);

  int num_lines = num_words / words_per_line;

  if ((num_words % words_per_line) != 0)
    ++num_lines;

  int i = 0;
  int j = 0;

  while (i < num_words && j < num_lines) {
    int len = words[i].size();

    std::cout << words[i];

    for (int k = 0; k <= max_len - len; ++k)
      std::cout << " ";

    i += num_lines;

    if (i >= num_words) {
      std::cout << std::endl;

      ++j;

      i = j;
    }
  }
}
##concat##CwshPattern.cpp
#include <CwshI.h>
#include <CFileMatch.h>
#include <CPathList.h>

CwshPattern::
CwshPattern(Cwsh *cwsh, const string &pattern) :
 cwsh_(cwsh), pattern_(pattern)
{
}

bool
CwshPattern::
expandWordToFiles(const CwshWord &word, CwshWordArray &words)
{
  CwshVariable *variable = cwsh_->lookupVariable("noglob");

  if (variable != NULL)
    return false;

  //------

  const CwshSubWordArray &sub_words = word.getSubWords();

  string word1;

  int num_sub_words = sub_words.size();

  for (int i = 0; i < num_sub_words; i++) {
    CwshSubWordType type = sub_words[i].getType();

    if      (type == CWSH_SUB_WORD_TYPE_BACK_QUOTED)
      word1 += sub_words[i].getWord();
    else if (type == CWSH_SUB_WORD_TYPE_DOUBLE_QUOTED ||
             type == CWSH_SUB_WORD_TYPE_SINGLE_QUOTED) {
      string word2 = CStrUtil::addEscapeChars(sub_words[i].getWord(), "*?[]");

      word1 += word2;
    }
    else
      word1 += sub_words[i].getWord();
  }

  CwshWildCard wildcard(word1);

  if (! wildcard.isValid())
    return false;

  vector<string> words1;

  CFileMatch fileMatch;

  if (! fileMatch.matchPattern(word.getWord(), words1))
    return false;

  if (words1.size() == 0) {
    CwshVariable *variable = cwsh_->lookupVariable("nonomatch");

    if (variable == NULL)
      CWSH_THROW("No match.");

    return false;
  }

  CStrUtil::sort(words1);

  int num_words1 = words1.size();

  for (int i = 0; i < num_words1; i++)
    words.push_back(CwshWord(words1[i]));

  return true;
}

bool
CwshPattern::
expandPath(vector<string> &files)
{
  CPathList pathList;

  pathList.addEnvValue("PATH");

  vector<string> dirs;

  return pathList.matchPattern(pattern_, dirs, files);
}

bool
CwshPattern::
expandVar(vector<string> &names)
{
  CwshWildCard compile(pattern_);

  CwshVariableList::iterator pvariable1 = cwsh_->variablesBegin();
  CwshVariableList::iterator pvariable2 = cwsh_->variablesEnd  ();

  for ( ; pvariable1 != pvariable2; ++pvariable1) {
    if (compile.checkMatch((*pvariable1)->getName()))
      names.push_back((*pvariable1)->getName());
  }

  vector<string> env_names;
  vector<string> env_values;

  CEnvInst.getNameValues(env_names, env_values);

  int num_env_names = env_names.size();

  for (int i = 0; i < num_env_names; i++) {
    if (compile.checkMatch(env_names[i]))
      names.push_back(env_names[i]);
  }

  return true;
}
##concat##CwshProcess.cpp
#include <CwshI.h>
#include <COSProcess.h>
#include <cstring>
#include <cerrno>

CwshProcessMgr::
CwshProcessMgr(Cwsh *cwsh) :
 cwsh_(cwsh)
{
}

CwshProcess *
CwshProcessMgr::
add(CwshCommandData *command)
{
  int num = 1;

  if (processes_.size() > 0)
    num = processes_.back()->getNum() + 1;

  CwshProcess *process = new CwshProcess(command, num);

  processes_.push_back(process);

  return process;
}

void
CwshProcessMgr::
remove(CwshProcess *process)
{
  processes_.remove(process);

  delete process;
}

void
CwshProcessMgr::
kill(pid_t pid, int signal)
{
  CwshProcess *process = lookupProcess(pid);

  if (process == NULL) {
    int error = COSProcess::killProcess(pid, signal);

    if (error < 0)
      CWSH_THROW("No such process");

    return;
  }

  CCommand::State state = process->getCommandState();

  if (state == CCommand::RUNNING_STATE || state == CCommand::STOPPED_STATE) {
    int error_code = COSProcess::killProcess(pid, signal);

    if (error_code != 0)
      CWSH_THROW(string("kill: ") + strerror(errno) + ".");
  }
}

int
CwshProcessMgr::
getNumActive()
{
  int count  = 0;

  ProcessList::iterator p1 = processes_.begin();
  ProcessList::iterator p2 = processes_.end  ();

  for ( ; p1 != p2; ++p1) {
    CCommand::State state = (*p1)->getCommandState();

    if (state != CCommand::RUNNING_STATE && state != CCommand::STOPPED_STATE)
      continue;

    count++;
  }

  return count;
}

void
CwshProcessMgr::
displayActive(bool list_pids)
{
  vector<CwshProcess *> active_processes;

  ProcessList::iterator p1 = processes_.begin();
  ProcessList::iterator p2 = processes_.end  ();

  for ( ; p1 != p2; ++p1) {
    CCommand::State state = (*p1)->getCommandState();

    if (state == CCommand::EXITED_STATE)
      continue;

    if (! (*p1)->getCommand()->getCommand()->getDoFork())
      continue;

    active_processes.push_back(*p1);
  }

  uint num_active_processes = active_processes.size();

  for (uint i = 0; i < num_active_processes; i++) {
    CwshProcess *process = active_processes[i];

    std::cout << "[" << process->getNum() << "]  ";

    if      (i == num_active_processes - 1)
      std::cout << "+ ";
    else if (i == num_active_processes - 2)
      std::cout << "- ";
    else
      std::cout << "  ";

    if (list_pids)
      std::cout << " " << process->getCommandPid() << " ";

    if      (process->getCommandState() == CCommand::STOPPED_STATE)
      std::cout << "Suspended             ";
    else
      std::cout << "Running               ";

    process->print();

    std::cout << std::endl;
  }

  deleteExited();
}

void
CwshProcessMgr::
displayExited()
{
  int count = 0;

  ProcessList::iterator p1 = processes_.begin();
  ProcessList::iterator p2 = processes_.end  ();

  while (p1 != p2) {
    CwshProcess *process = *p1;

    CCommand::State state = process->getCommandState();

    if (state == CCommand::RUNNING_STATE || state == CCommand::STOPPED_STATE ||
        state == CCommand::EXITED_STATE)
      count++;

    if (state == CCommand::EXITED_STATE) {
      std::cout << "[" << process->getNum() << "]    Done                  ";

      process->print();

      std::cout << std::endl;

      remove(process);

      p1 = processes_.begin();
    }
    else
      ++p1;
  }
}

void
CwshProcessMgr::
deleteExited()
{
  ProcessList::iterator p1, p2;

  for (p1 = processes_.begin(), p2 = processes_.end (); p1 != p2; ++p1) {
    CwshProcess *process = *p1;

    CCommand::State state = process->getCommandState();

    if (state == CCommand::EXITED_STATE)
      remove(process);
  }
}

void
CwshProcessMgr::
waitActive()
{
  ProcessList::iterator p1, p2;

  for (p1 = processes_.begin(), p2 = processes_.end (); p1 != p2; ++p1) {
    CwshProcess *process = *p1;

    CwshCommand *command = process->getCommand()->getCommand();

    if (! command->getDoFork())
      continue;

    command->wait();
  }

  displayExited();
}

pid_t
CwshProcessMgr::
stringToPid(const string &str)
{
  CwshProcess *process = getActiveProcess(str);

  return process->getCommandPid();
}

CwshProcess *
CwshProcessMgr::
getActiveProcess(const string &str)
{
  if (str.size() < 1 || str[0] != '%')
    CWSH_THROW("No current job.");

  CwshProcess *process = NULL;

  if      (str.size() == 1 ||
           (str.size() == 2 && (str[1] == '%' || str[1] == '+')))
    process = getCurrentActiveProcess();
  else if (str.size() == 2 && str[1] == '-')
    process = getPreviousActiveProcess();
  else if (str.size() > 1 && CStrUtil::isInteger(str.substr(1))) {
    int process_num = CStrUtil::toInteger(str.substr(1));

    process = getActiveProcess(process_num);
  }
  else if (str[1] == '?')
    process = matchActiveProcess(str.substr(1), CWSH_PROCESS_MATCH_ANY);
  else
    process = matchActiveProcess(str.substr(1), CWSH_PROCESS_MATCH_START);

  if (process == NULL)
    CWSH_THROW("No such job.");

  return process;
}

CwshProcess *
CwshProcessMgr::
getCurrentActiveProcess()
{
  CwshProcess *process = NULL;

  ProcessList::iterator p1 = processes_.begin();
  ProcessList::iterator p2 = processes_.end  ();

  for ( ; p1 != p2; ++p1) {
    CwshCommand *command = (*p1)->getCommand()->getCommand();

    CCommand::State state = command->getState();

    if (state != CCommand::RUNNING_STATE && state != CCommand::STOPPED_STATE)
      continue;

    process = *p1;
  }

  return process;
}

CwshProcess *
CwshProcessMgr::
getPreviousActiveProcess()
{
  CwshProcess *process1 = NULL;
  CwshProcess *process2 = NULL;

  ProcessList::iterator p1 = processes_.begin();
  ProcessList::iterator p2 = processes_.end  ();

  for ( ; p1 != p2; ++p1) {
    CwshCommand *command = (*p1)->getCommand()->getCommand();

    CCommand::State state = command->getState();

    if (state != CCommand::RUNNING_STATE && state != CCommand::STOPPED_STATE)
      continue;

    process1 = process2;
    process2 = *p1;
  }

  return process1;
}

CwshProcess *
CwshProcessMgr::
getActiveProcess(int num)
{
  vector<CwshProcess *> active_processes;

  ProcessList::iterator p1 = processes_.begin();
  ProcessList::iterator p2 = processes_.end  ();

  for ( ; p1 != p2; ++p1) {
    CwshCommand *command = (*p1)->getCommand()->getCommand();

    CCommand::State state = command->getState();

    if (state != CCommand::RUNNING_STATE && state != CCommand::STOPPED_STATE)
      continue;

    active_processes.push_back(*p1);
  }

  int num_active_processes = active_processes.size();

  if (num > num_active_processes)
    return NULL;

  return active_processes[num_active_processes - num];
}

CwshProcess *
CwshProcessMgr::
matchActiveProcess(const string &str, CwshProcessMatchType match_type)
{
  CwshProcess *process = NULL;

  ProcessList::iterator p1 = processes_.begin();
  ProcessList::iterator p2 = processes_.end  ();

  for ( ; p1 != p2; ++p1) {
    CwshCommand *command = (*p1)->getCommand()->getCommand();

    CCommand::State state = command->getState();

    if (state != CCommand::RUNNING_STATE && state != CCommand::STOPPED_STATE)
      continue;

    string command_str = command->getCommandString();

    string::size_type pos = command_str.find(str);

    if ((match_type == CWSH_PROCESS_MATCH_START && pos == 0) ||
        (match_type == CWSH_PROCESS_MATCH_ANY   && pos != string::npos))
      process = *p1;
  }

  return process;
}

CwshProcess *
CwshProcessMgr::
lookupProcess(pid_t pid)
{
  ProcessList::iterator p1 = processes_.begin();
  ProcessList::iterator p2 = processes_.end  ();

  for ( ; p1 != p2; ++p1) {
    CwshProcess *process = *p1;

    if (process->isPid(pid))
      return process;
  }

  return NULL;
}

//--------

CwshProcess::
CwshProcess(CwshCommandData *command, int num) :
 command_(command), num_(num)
{
}

CwshProcess::
~CwshProcess()
{
}

void
CwshProcess::
addSubCommand(CwshCommandData *command)
{
  subCommands_.push_back(command);
}

CCommand::State
CwshProcess::
getCommandState() const
{
  return command_->getCommand()->getState();
}

string
CwshProcess::
getCommandString() const
{
  return command_->getCommand()->getCommandString();
}

pid_t
CwshProcess::
getCommandPid() const
{
  return command_->getCommand()->getPid();
}

void
CwshProcess::
start()
{
  command_->getCommand()->start();
}

void
CwshProcess::
stop()
{
  command_->getCommand()->stop();
}

void
CwshProcess::
tstop()
{
  command_->getCommand()->tstop();
}

void
CwshProcess::
pause()
{
  command_->getCommand()->pause();
}

void
CwshProcess::
resume()
{
  uint numSubCommands = subCommands_.size();

  for (uint i = 0; i < numSubCommands; ++i)
    subCommands_[i]->getCommand()->resume();

  command_->getCommand()->resume();
}

void
CwshProcess::
wait()
{
  command_->getCommand()->wait();
}

void
CwshProcess::
setNotify(bool flag)
{
  command_->getCommand()->setNotify(flag);
}

bool
CwshProcess::
isPid(pid_t pid) const
{
  pid_t pid1 = command_->getCommand()->getPid();

  if (pid1 == pid)
    return true;

  uint numSubCommands = subCommands_.size();

  for (uint i = 0; i < numSubCommands; ++i) {
    pid1 = subCommands_[i]->getCommand()->getPid();

    if (pid1 == pid)
      return true;
  }

  return false;
}

void
CwshProcess::
print() const
{
  std::cout << " " << command_->getCommand()->getCommandString();

  uint numSubCommands = subCommands_.size();

  for (uint i = 0; i < numSubCommands; ++i)
    std::cout << " | " << subCommands_[i]->getCommand()->getCommandString();
}
##concat##CwshReadLine.cpp
#include <CwshI.h>
#include <CReadLine.h>
#include <cstdio>

CwshReadLine::
CwshReadLine(Cwsh *cwsh) :
 cwsh_(cwsh)
{
}

string
CwshReadLine::
readLine()
{
  string prompt = cwsh_->getInputPrompt();

  setPrompt(prompt);

  fflush(stdout);
  fflush(stderr);

  string line;

  try {
    line = CReadLine::readLine();

    if (eof()) {
      std::cout << std::endl;

      CwshVariable *variable = cwsh_->lookupVariable("ignoreeof");

      if (variable == NULL)
        cwsh_->setExit(true, 0);
      else
        CWSH_THROW("Use \"exit\" to leave shell.");
    }
  }
  catch (struct CwshErr *cthrow) {
    if (cwsh_->getDebug())
      std::cerr << "[" << cthrow->file << ":" << cthrow->line << "] ";

    if (cthrow->qualifier != "")
      std::cerr << cthrow->qualifier << ": " << cthrow->message << std::endl;
    else
      std::cerr << cthrow->message << std::endl;
  }
  catch (...) {
    std::cerr << "Unhandled Exception thrown" << std::endl;
  }

  return line;
}

bool
CwshReadLine::
completeLine(const string &line, string &line1)
{
  CwshComplete complete(cwsh_, line);

  if (! complete.complete(line1))
    cwsh_->beep();

  return true;
}

bool
CwshReadLine::
showComplete(const string &line)
{
  CwshMatch match(cwsh_);

  return match.showMatch(line);
}

bool
CwshReadLine::
getPrevCommand(string &line)
{
  if (! cwsh_->hasPrevHistoryCommand())
    return false;

  line = cwsh_->getPrevHistoryCommand();

  return true;
}

bool
CwshReadLine::
getNextCommand(string &line)
{
  if (! cwsh_->hasNextHistoryCommand())
    return false;

  line = cwsh_->getNextHistoryCommand();

  return true;
}

void
CwshReadLine::
beep()
{
  CwshVariable *nobeep = cwsh_->lookupVariable("nobeep");

  if (nobeep == NULL)
    CReadLine::beep();
}

void
CwshReadLine::
interrupt()
{
  CReadLine::interrupt();
}

void
CwshReadLine::
timeout()
{
  cwsh_->readTimeout();
}
##concat##CwshResource.cpp
#include <CwshI.h>
#include <COSLimit.h>

enum CwshResourceType {
  CWSH_RESOURCE_TYPE_NONE,
  CWSH_RESOURCE_TYPE_TIME,
  CWSH_RESOURCE_TYPE_SIZE,
  CWSH_RESOURCE_TYPE_DATA,
};

struct CwshResourceLimit {
  string                   name;
  COSLimit::LimitSetProc   setProc;
  COSLimit::LimitGetProc   getProc;
  COSLimit::LimitUnsetProc unsetProc;
  CwshResourceType         type;
};

#define limitProcs(p) \
  COSLimit::set##p##Limit, COSLimit::get##p##Limit, COSLimit::unset##p##Limit

CwshResourceLimit
CwshResource::limits_[] = {
  { "cputime"     , limitProcs(CPU         ), CWSH_RESOURCE_TYPE_TIME, },
  { "filesize"    , limitProcs(FileSize    ), CWSH_RESOURCE_TYPE_SIZE, },
  { "datasize"    , limitProcs(DataSize    ), CWSH_RESOURCE_TYPE_SIZE, },
  { "stacksize"   , limitProcs(StackSize   ), CWSH_RESOURCE_TYPE_SIZE, },
  { "coredumpsize", limitProcs(CoreDumpSize), CWSH_RESOURCE_TYPE_SIZE, },
  { "memoryuse"   , limitProcs(MemoryUse   ), CWSH_RESOURCE_TYPE_SIZE, },
  { "vmemoryuse"  , limitProcs(VMemoryUse  ), CWSH_RESOURCE_TYPE_SIZE, },
  { "descriptors" , limitProcs(Descriptors ), CWSH_RESOURCE_TYPE_DATA, },
  { "memorylocked", limitProcs(MemoryLocked), CWSH_RESOURCE_TYPE_SIZE, },
  { "maxproc"     , limitProcs(MaxProc     ), CWSH_RESOURCE_TYPE_DATA, },
  { "openfiles"   , limitProcs(OpenFiles   ), CWSH_RESOURCE_TYPE_DATA, },
  { "addressspace", limitProcs(AddressSpace), CWSH_RESOURCE_TYPE_SIZE, },
  { ""            , NULL, NULL, NULL        , CWSH_RESOURCE_TYPE_NONE, },
};

CwshResource::
CwshResource()
{
}

void
CwshResource::
limit(const string &name, const string &value, bool hard)
{
  CwshResourceLimit *rlimit = getLimit(name);

  if (rlimit == NULL)
    CWSH_THROW("No such limit.");

  int ivalue = convertValue(rlimit, value);

  if (! (*rlimit->setProc)(ivalue, hard))
    CWSH_THROW(name + ": Can't get limit.");
}

void
CwshResource::
unlimitAll()
{
  for (int i = 0; limits_[i].type != CWSH_RESOURCE_TYPE_NONE; i++)
    (*limits_[i].unsetProc)();
}

void
CwshResource::
unlimit(const string &name)
{
  CwshResourceLimit *rlimit = getLimit(name);

  if (rlimit == NULL)
    CWSH_THROW("No such limit.");

  (*rlimit->unsetProc)();
}

void
CwshResource::
printAll(bool hard)
{
  for (int i = 0; limits_[i].type != CWSH_RESOURCE_TYPE_NONE; i++)
    print(&limits_[i], hard);
}

void
CwshResource::
print(const string &name, bool hard)
{
  CwshResourceLimit *rlimit = getLimit(name);

  if (rlimit == NULL)
    CWSH_THROW("No such limit.");

  print(rlimit, hard);
}

void
CwshResource::
print(CwshResourceLimit *rlimit, bool hard)
{
  COSLimit::LimitVal value;

  if (! (*rlimit->getProc)(&value, hard))
    CWSH_THROW(rlimit->name + ": Can't get limit.");

  std::cout << rlimit->name;

  int name_len = rlimit->name.size();

  for (int i = name_len; i < 16; i++)
    std::cout << " ";

  if (COSLimit::isLimitValueInfinity(value)) {
    std::cout << "unlimited" << std::endl;
    return;
  }

  if      (rlimit->type == CWSH_RESOURCE_TYPE_TIME) {
    int value1 = value/3600;
    int value2 = (value - value1*3600)/60;
    int value3 = value - value1*3600 - value2*60;

    if (value1 > 0)
      std::cout << value1 << value2 << value3 << std::endl;
    else
      std::cout << value2 << value3 << std::endl;
  }
  else if (rlimit->type == CWSH_RESOURCE_TYPE_SIZE)
    std::cout << (int) (value/1024) << " kbytes" << std::endl;
  else
    std::cout << value << std::endl;
}

int
CwshResource::
convertValue(CwshResourceLimit *rlimit, const string &value)
{
  uint len = value.size();

  if (len == 0 || ! isdigit(value[0]))
    CWSH_THROW("Invalid Value.");

  uint i = 0;

  int ivalue;

  if (! CStrUtil::readInteger(value, &i, &ivalue))
    CWSH_THROW("Invalid Value.");

  if      (rlimit->type == CWSH_RESOURCE_TYPE_TIME) {
    if      (i < len && value[i] == 'h') {
      i++;

      ivalue *= 3600;
    }
    else if (i < len && value[i] == 'm') {
      i++;

      ivalue *= 60;
    }
    else if (i < len && value[i] == ':') {
      i++;

      ivalue *= 60;

      int ivalue1;

      if (! CStrUtil::readInteger(value, &i, &ivalue1))
        CWSH_THROW("Invalid Value.");

      ivalue += ivalue1;
    }
  }
  else if (rlimit->type == CWSH_RESOURCE_TYPE_SIZE) {
    if      (i < len && value[i] == 'k') {
      i++;

      ivalue <<= 10;
    }
    else if (i < len && value[i] == 'm') {
      i++;

      ivalue <<= 20;
    }
    else
      ivalue <<= 10;
  }

  if (i != len)
    CWSH_THROW("Invalid Value.");

  return ivalue;
}

CwshResourceLimit *
CwshResource::
getLimit(const string &name)
{
  for (int i = 0; limits_[i].type != CWSH_RESOURCE_TYPE_NONE; i++)
    if (limits_[i].name == name)
      return &limits_[i];

  CWSH_THROW("Bad Resource Name " + name);
}
##concat##CwshServer.cpp
#include <CwshI.h>

#ifdef USE_MESSAGES
#include <CMessage.h>
#endif

CwshServer::
CwshServer(Cwsh *cwsh) :
 cwsh_(cwsh)
{
#ifdef USE_MESSAGES
  message_ = createMessage();
#endif
}

CwshServer::
~CwshServer()
{
}

CMessage *
CwshServer::
createMessage()
{
#ifdef USE_MESSAGES
  return new CMessage("CwshServer");
#else
  return 0;
#endif
}

bool
CwshServer::
processMessage()
{
#ifdef USE_MESSAGES
  string msg;

  if (! message_->recvClientMessage(msg))
    return false;

  uint len = msg.size();

  string reply;

  if      (msg == "get_aliases")
    reply = cwsh_->getAliasesMsg();
  else if (len > 10 && msg.substr(0, 10) == "set_alias ") {
    string nameValue = CStrUtil::stripSpaces(msg.substr(10));

    string::size_type pos = nameValue.find(' ');

    if (pos != string::npos) {
      string name  = nameValue.substr(0, pos);
      string value = CStrUtil::stripSpaces(nameValue.substr(pos));

      cwsh_->defineAlias(name, value);

      reply = "1";
    }
    else
      reply = "1";
  }
  else if (len > 12 && msg.substr(0, 12) == "unset_alias ") {
    string name = CStrUtil::stripSpaces(msg.substr(12));

    cwsh_->undefineAlias(name);

    reply = "1";
  }
  else if (msg == "get_history")
    reply = cwsh_->getHistoryMsg();
  else if (len > 3 && msg.substr(0, 3) == "cd ") {
    string dirname = CStrUtil::stripSpaces(msg.substr(3));

    cwsh_->changeDir(dirname);

    reply = dirname;
  }
  else if (msg == "pwd")
    reply = COSFile::getCurrentDir();
  else
    reply = "<Unknown Command> " + msg;

  message_->sendServerMessage(reply, 0);

  return true;
#else
  return false;
#endif
}
##concat##CwshSet.cpp
#include <CwshI.h>

CwshSet::
CwshSet(Cwsh *cwsh) :
 cwsh_(cwsh)
{
}

void
CwshSet::
parseSet(const string &str, string &name, int *index,
         CwshVariableType *type, vector<string> &values)
{
  uint i = 0;

  parseVariable(str, &i, name, index);

  uint len = str.size();

  if (i >= len || str[i] != '=')
    return;

  i++;

  setValues(str, &i, type, values);
}

void
CwshSet::
processSet(const string &name, int index, CwshVariableType type,
           vector<string> &values)
{
  if (index != -1) {
    int num_values = values.size();

    if (num_values != 1)
      CWSH_THROW("Syntax Error.");

    if (type == CWSH_VARIABLE_TYPE_WORDLIST || num_values != 1)
      CWSH_THROW("Expression Syntax.");

    CwshVariable *variable = cwsh_->lookupVariable(name);

    if (variable == NULL)
      CWSH_THROW("Undefined variable");

    if (index >= variable->getNumValues())
      CWSH_THROW("Subscript out of range.");

    variable->setValue(index - 1, values[0]);
  }
  else
    cwsh_->defineVariable(name, values);
}

void
CwshSet::
parseAssign(const string &str, string &name, int *index,
            CwshSetAssignType *assign_type, string &expr_str)
{
  uint i = 0;

  parseVariable(str, &i, name, index);

  *assign_type = parseAssignType(str, &i);

  if (*assign_type != CWSH_SET_ASSIGN_TYPE_INCREMENT &&
      *assign_type != CWSH_SET_ASSIGN_TYPE_DECREMENT) {
    CwshExprParse parse(cwsh_);

    expr_str = parse.parse(str, &i);
  }
}

void
CwshSet::
processAssign(const string &name, int index,
              CwshSetAssignType assign_type, const string &expr_str)
{
  int integer = 0;

  if (assign_type != CWSH_SET_ASSIGN_TYPE_INCREMENT &&
      assign_type != CWSH_SET_ASSIGN_TYPE_DECREMENT) {
    CwshExprEvaluate expr(cwsh_, expr_str);

    integer = expr.process();
  }

  CwshVariable *variable = cwsh_->lookupVariable(name);

  int integer1 = 0;

  if (index != -1) {
    if (variable == NULL)
      CWSH_THROW("Undefined variable.");

    if (index >= variable->getNumValues())
      CWSH_THROW("Subscript out of range.");

    string str = variable->getValue(index - 1);

    if (! CStrUtil::isInteger(str))
      CWSH_THROW("Expression Syntax.");

    integer1 = CStrUtil::toInteger(str);
  }
  else {
    if (assign_type != CWSH_SET_ASSIGN_TYPE_EQUALS && variable == NULL)
      CWSH_THROW("Undefined variable.");

    if (variable != NULL && variable->getNumValues() > 0) {
      string str = variable->getValue(0);

      if (! CStrUtil::isInteger(str))
        CWSH_THROW("Expression Syntax.");

      integer1 = CStrUtil::toInteger(str);
    }
  }

  switch (assign_type) {
    case CWSH_SET_ASSIGN_TYPE_EQUALS:
      break;
    case CWSH_SET_ASSIGN_TYPE_PLUS_EQUALS:
      integer = integer1 + integer;
      break;
    case CWSH_SET_ASSIGN_TYPE_MINUS_EQUALS:
      integer = integer1 - integer;
      break;
    case CWSH_SET_ASSIGN_TYPE_TIMES_EQUALS:
      integer = integer1 * integer;
      break;
    case CWSH_SET_ASSIGN_TYPE_DIVIDE_EQUALS:
      if (integer == 0)
        CWSH_THROW("Division by 0.");

      integer = integer1 / integer;
      break;
    case CWSH_SET_ASSIGN_TYPE_MODULUS_EQUALS:
      if (integer == 0)
        CWSH_THROW("Mod by 0.");

      integer = integer1 % integer;
      break;
    case CWSH_SET_ASSIGN_TYPE_AND_EQUALS:
      integer = integer1 & integer;
      break;
    case CWSH_SET_ASSIGN_TYPE_OR_EQUALS:
      integer = integer1 | integer;
      break;
    case CWSH_SET_ASSIGN_TYPE_XOR_EQUALS:
      integer = integer1 ^ integer;
      break;
    case CWSH_SET_ASSIGN_TYPE_INCREMENT:
      integer = ++integer1;
      break;
    case CWSH_SET_ASSIGN_TYPE_DECREMENT:
      integer = --integer1;
      break;
    default:
      break;
  }

  if (index != -1)
    variable->setValue(index - 1, CStrUtil::toString(integer));
  else
    cwsh_->defineVariable(name, integer);
}

void
CwshSet::
parseVariable(const string &str, uint *i, string &name, int *index)
{
  CStrUtil::skipSpace(str, i);

  uint len = str.size();

  if (*i >= len || (str[*i] != '_' && ! isalpha(str[*i])))
    CWSH_THROW("Variable name must begin with a letter.");

  int j = *i;

  (*i)++;

  while (*i < len && (str[*i] == '_' || isalnum(str[*i])))
    (*i)++;

  name = str.substr(j, *i - j);

  CStrUtil::skipSpace(str, i);

  if (*i < len || str[*i] != '[') {
    *index = -1;
    return;
  }

  (*i)++;

  if (*i >= len || ! isdigit(str[*i]))
    CWSH_THROW("Subscript error.");

  j = *i;

  while (str[*i] != '\0' && isdigit(str[*i]))
    (*i)++;

  string istr = str.substr(j, *i - j);

  if (! CStrUtil::isInteger(istr))
    throw "set: Subscript error.";

  *index = CStrUtil::toInteger(istr);

  CStrUtil::skipSpace(str, i);

  if (*i >= len || str[*i] != ']')
    CWSH_THROW("Subscript error.");

  (*i)++;
}

CwshSetAssignType
CwshSet::
parseAssignType(const string &str, uint *i)
{
  CwshSetAssignType type = CWSH_SET_ASSIGN_TYPE_NONE;

  CStrUtil::skipSpace(str, i);

  switch (str[*i]) {
    case '=':
      (*i)++;

      type = CWSH_SET_ASSIGN_TYPE_EQUALS;

      break;
    case '+':
      (*i)++;

      switch (str[*i]) {
        case '=':
          (*i)++;

          type = CWSH_SET_ASSIGN_TYPE_PLUS_EQUALS;

          break;
        case '+':
          (*i)++;

          type = CWSH_SET_ASSIGN_TYPE_INCREMENT;

          break;
      }

      break;
    case '-':
      (*i)++;

      switch (str[*i]) {
        case '=':
          (*i)++;

          type = CWSH_SET_ASSIGN_TYPE_MINUS_EQUALS;

          break;
        case '-':
          (*i)++;

          type = CWSH_SET_ASSIGN_TYPE_DECREMENT;

          break;
      }

      break;
    case '*':
      (*i)++;

      switch (str[*i]) {
        case '=':
          (*i)++;

          type = CWSH_SET_ASSIGN_TYPE_TIMES_EQUALS;

          break;
      }

      break;
    case '/':
      (*i)++;

      switch (str[*i]) {
        case '=':
          (*i)++;

          type = CWSH_SET_ASSIGN_TYPE_DIVIDE_EQUALS;

          break;
      }

      break;
    case '%':
      (*i)++;

      switch (str[*i]) {
        case '=':
          (*i)++;

          type = CWSH_SET_ASSIGN_TYPE_MODULUS_EQUALS;

          break;
      }

      break;
    case '&':
      (*i)++;

      switch (str[*i]) {
        case '=':
          (*i)++;

          type = CWSH_SET_ASSIGN_TYPE_AND_EQUALS;

          break;
      }

      break;
    case '|':
      (*i)++;

      switch (str[*i]) {
        case '=':
          (*i)++;

          type = CWSH_SET_ASSIGN_TYPE_OR_EQUALS;

          break;
      }

      break;
    case '^':
      (*i)++;

      switch (str[*i]) {
        case '=':
          (*i)++;

          type = CWSH_SET_ASSIGN_TYPE_XOR_EQUALS;

          break;
      }

      break;
  }

  if (type == -1)
    CWSH_THROW("Syntax error.");

  CStrUtil::skipSpace(str, i);

  return type;
}

void
CwshSet::
setValues(const string &str, uint *i, CwshVariableType *type,
          vector<string> &values)
{
  CStrUtil::skipSpace(str, i);

  uint len = str.size();

  if (*i < len && str[*i] == '(') {
    *type = CWSH_VARIABLE_TYPE_WORDLIST;

    (*i)++;

    int j = *i;

    CwshString::skipWordsToChar(str, i, ')');

    string str1 = str.substr(j, *i - j);

    (*i)++;

    CwshString::addWords(str1, values);
  }
  else {
    *type = CWSH_VARIABLE_TYPE_WORD;

    int j = *i;

    CwshString::skipWord(str, i);

    string str1 = str.substr(j, *i - j);

    values.push_back(str1);
  }

  CStrUtil::skipSpace(str, i);
}
##concat##CwshShellCommand.cpp
#include <CwshI.h>
#include <COSProcess.h>
#include <COSSignal.h>
#include <CFileMatch.h>
#include <cerrno>

#include <sys/resource.h>
#include <sys/times.h>

#define CWSH_SHELL_CMD_DATA1(n,p) \
  { n , NULL, &CwshShellCommandMgr::p, CWSH_SHELL_COMMAND_FLAGS_NONE }
#define CWSH_SHELL_CMD_DATA2(ns,ne,p) \
  { ns, ne, &CwshShellCommandMgr::p, CWSH_SHELL_COMMAND_FLAGS_NONE }
#define CWSH_SHELL_CMD_DATA1_NW(n,p) \
  { n , NULL, &CwshShellCommandMgr::p, CWSH_SHELL_COMMAND_FLAGS_NO_WILDCARDS }
#define CWSH_SHELL_CMD_DATA2_NE(ns,ne,p) \
  { ns, ne, &CwshShellCommandMgr::p, CWSH_SHELL_COMMAND_FLAGS_NO_EXPAND }

CwshShellCommandData
CwshShellCommandMgr::
commands_data_[] = {
 CWSH_SHELL_CMD_DATA2("foreach", "end"    , foreachCmd),
 CWSH_SHELL_CMD_DATA2("func"   , "endfunc", funcCmd   ),
 CWSH_SHELL_CMD_DATA2("if"     , "endif"  , ifCmd     ),
 CWSH_SHELL_CMD_DATA2("switch" , "endsw"  , switchCmd ),

 CWSH_SHELL_CMD_DATA2_NE("while"  , "end"    , whileCmd  ),

 CWSH_SHELL_CMD_DATA1(":"       , colonCmd   ),
 CWSH_SHELL_CMD_DATA1("bg"      , bgCmd      ),
 CWSH_SHELL_CMD_DATA1("break"   , breakCmd   ),
 CWSH_SHELL_CMD_DATA1("breaksw" , breakswCmd ),
 CWSH_SHELL_CMD_DATA1("case"    , caseCmd    ),
 CWSH_SHELL_CMD_DATA1("cd"      , cdCmd      ),
 CWSH_SHELL_CMD_DATA1("chdir"   , cdCmd      ),
 CWSH_SHELL_CMD_DATA1("continue", continueCmd),
 CWSH_SHELL_CMD_DATA1("default" , defaultCmd ),
 CWSH_SHELL_CMD_DATA1("dirs"    , dirsCmd    ),
 CWSH_SHELL_CMD_DATA1("echo"    , echoCmd    ),
 CWSH_SHELL_CMD_DATA1("else"    , elseCmd    ),
 CWSH_SHELL_CMD_DATA1("end"     , endCmd     ),
 CWSH_SHELL_CMD_DATA1("endfunc" , endfuncCmd ),
 CWSH_SHELL_CMD_DATA1("endif"   , endifCmd   ),
 CWSH_SHELL_CMD_DATA1("endsw"   , endswCmd   ),
 CWSH_SHELL_CMD_DATA1("eval"    , evalCmd    ),
 CWSH_SHELL_CMD_DATA1("exec"    , execCmd    ),
 CWSH_SHELL_CMD_DATA1("expr"    , exprCmd    ),
 CWSH_SHELL_CMD_DATA1("exit"    , exitCmd    ),
 CWSH_SHELL_CMD_DATA1("fg"      , fgCmd      ),
 CWSH_SHELL_CMD_DATA1("glob"    , globCmd    ),
 CWSH_SHELL_CMD_DATA1("goto"    , gotoCmd    ),
 CWSH_SHELL_CMD_DATA1("hashstat", hashstatCmd),
 CWSH_SHELL_CMD_DATA1("help"    , helpCmd    ),
 CWSH_SHELL_CMD_DATA1("history" , historyCmd ),
 CWSH_SHELL_CMD_DATA1("jobs"    , jobsCmd    ),
 CWSH_SHELL_CMD_DATA1("kill"    , killCmd    ),
 CWSH_SHELL_CMD_DATA1("limit"   , limitCmd   ),
 CWSH_SHELL_CMD_DATA1("login"   , badCmd     ),
 CWSH_SHELL_CMD_DATA1("logout"  , badCmd     ),
 CWSH_SHELL_CMD_DATA1("nice"    , niceCmd    ),
 CWSH_SHELL_CMD_DATA1("nohup"   , nohupCmd   ),
 CWSH_SHELL_CMD_DATA1("notify"  , notifyCmd  ),
 CWSH_SHELL_CMD_DATA1("onintr"  , onintrCmd  ),
 CWSH_SHELL_CMD_DATA1("popd"    , popdCmd    ),
 CWSH_SHELL_CMD_DATA1("printenv", printenvCmd),
 CWSH_SHELL_CMD_DATA1("pushd"   , pushdCmd   ),
 CWSH_SHELL_CMD_DATA1("rehash"  , rehashCmd  ),
 CWSH_SHELL_CMD_DATA1("repeat"  , repeatCmd  ),
 CWSH_SHELL_CMD_DATA1("return"  , returnCmd  ),
 CWSH_SHELL_CMD_DATA1("setenv"  , setenvCmd  ),
 CWSH_SHELL_CMD_DATA1("shift"   , shiftCmd   ),
 CWSH_SHELL_CMD_DATA1("source"  , sourceCmd  ),
 CWSH_SHELL_CMD_DATA1("stop"    , stopCmd    ),
 CWSH_SHELL_CMD_DATA1("suspend" , suspendCmd ),
 CWSH_SHELL_CMD_DATA1("time"    , timeCmd    ),
 CWSH_SHELL_CMD_DATA1("umask"   , umaskCmd   ),
 CWSH_SHELL_CMD_DATA1("unhash"  , unhashCmd  ),
 CWSH_SHELL_CMD_DATA1("unlimit" , unlimitCmd ),
 CWSH_SHELL_CMD_DATA1("unset"   , unsetCmd   ),
 CWSH_SHELL_CMD_DATA1("unsetenv", unsetenvCmd),
 CWSH_SHELL_CMD_DATA1("wait"    , waitCmd    ),
 CWSH_SHELL_CMD_DATA1("which"   , whichCmd   ),

 CWSH_SHELL_CMD_DATA1_NW("alias"   , aliasCmd   ),
 CWSH_SHELL_CMD_DATA1_NW("unalias" , unaliasCmd ),
 CWSH_SHELL_CMD_DATA1_NW("set"     , setCmd     ),
 CWSH_SHELL_CMD_DATA1_NW("complete", completeCmd),
 CWSH_SHELL_CMD_DATA1_NW("autoexec", autoExecCmd),
 CWSH_SHELL_CMD_DATA1_NW("@"       , atCmd      ),
};

CwshShellCommandMgr::
CwshShellCommandMgr(Cwsh *cwsh) :
 cwsh_(cwsh)
{
  uint num_commands = sizeof(commands_data_)/sizeof(commands_data_[0]);

  commands_.resize(num_commands);

  for (uint i = 0; i < num_commands; ++i)
    commands_[i] = new CwshShellCommand(cwsh_, &commands_data_[i]);
}

CwshShellCommandMgr::
~CwshShellCommandMgr()
{
  std::for_each(commands_.begin(), commands_.end(), CDeletePointer());
}

CwshShellCommand *
CwshShellCommandMgr::
lookup(const string &name) const
{
  if (name.size() > 0 && name[0] == '\\')
    return lookup(name.substr(1));

  uint num_commands = commands_.size();

  for (uint i = 0; i < num_commands; i++)
    if (commands_[i]->getName() == name)
      return commands_[i];

  return NULL;
}

void
CwshShellCommandMgr::
runProc(const CwshArgArray &args, CCommand::CallbackData data)
{
  CwshShellCommand *shell_command = (CwshShellCommand *) data;

  if (shell_command->getCwsh()->getDebug()) {
    std::cerr << shell_command->getName();

    int num_args = args.size();

    for (int i = 0; i < num_args; i++)
      std::cerr << " " << args[i];

    std::cerr << std::endl;
  }

  (shell_command->getProc())(shell_command->getCwsh(), args);
}

void
CwshShellCommandMgr::
colonCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    return;
  }
}

void
CwshShellCommandMgr::
aliasCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "alias               ; list all aliases" << std::endl;
    std::cout << "alias <name>        ; list named alias" << std::endl;
    std::cout << "alias <name> <args> ; define alias to args" << std::endl;
    return;
  }

  int num_args = args.size();

  if      (num_args == 0)
    cwsh->displayAlias();
  else if (num_args == 1) {
    CwshAlias *alias = cwsh->lookupAlias(args[0]);

    if (alias != NULL)
      std::cout << alias->getValue() << std::endl;
  }
  else {
    string cmd = CStrUtil::toString(args, 1);

    cwsh->defineAlias(args[0], cmd);
  }
}

void
CwshShellCommandMgr::
autoExecCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "autoexec                 ; list all auto exec rules" << std::endl;
    std::cout << "autoexec <suffix>        ; list named auto exec" << std::endl;
    std::cout << "autoexec <suffix> <args> ; define auto exec for suffix to args" << std::endl;
    return;
  }

  int num_args = args.size();

  if      (num_args == 0)
    cwsh->displayAutoExec();
  else if (num_args == 1) {
    CwshAutoExec *autoExec = cwsh->lookupAutoExec(args[0]);

    if (autoExec != NULL)
      std::cout << autoExec->getValue() << std::endl;
  }
  else {
    string cmd = CStrUtil::toString(args, 1);

    cwsh->defineAutoExec(args[0], cmd);
  }
}

void
CwshShellCommandMgr::
bgCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "bg           ; move current process to backgroud" << std::endl;
    std::cout << "bg <job> ... ; move specified jobs to background" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 0) {
    for (int i = 0; i < num_args; i++) {
      CwshProcess *process = cwsh->getActiveProcess(args[i]);

      if (process == NULL)
        CWSH_THROW("No such job.");

      std::cout << "[" << process->getNum() << "]    ";

      process->print();

      std::cout << " &" << std::endl;

      process->resume();
    }
  }
  else {
    CwshProcess *process = cwsh->getCurrentActiveProcess();

    if (process == NULL)
      CWSH_THROW("No current job.");

    std::cout << "[" << process->getNum() << "]    ";

    process->print();

    std::cout << " &" << std::endl;

    process->resume();
  }
}

void
CwshShellCommandMgr::
breakCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "break ; break out of while/foreach" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 0)
    CWSH_THROW("Too many arguments.");

  CwshBlock *block = cwsh->findBlock(CWSH_BLOCK_TYPE_WHILE);

  if (block == NULL)
    block = cwsh->findBlock(CWSH_BLOCK_TYPE_FOREACH);

  if (block == NULL)
    CWSH_THROW("Not in while/foreach.");

  cwsh->setBlockBreak(true);
}

void
CwshShellCommandMgr::
breakswCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "breaksw ; break out of switch" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 0)
    CWSH_THROW("Too many arguments.");

  CwshBlock *block = cwsh->findBlock(CWSH_BLOCK_TYPE_SWITCH);

  if (block == NULL)
    CWSH_THROW("Not in switch.");

  cwsh->setBlockBreakSwitch(true);
}

void
CwshShellCommandMgr::
caseCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "case <expr> ; switch case statement" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args != 2)
    CWSH_THROW("Syntax Error.");

  if (args[1] != ":")
    CWSH_THROW("Syntax Error.");

  CWSH_THROW("Not in switch.");
}

void
CwshShellCommandMgr::
cdCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "cd           ; change to home directory" << std::endl;
    std::cout << "cd <dir>     ; change to specified directory" << std::endl;
    std::cout << "cd <dir> ... ; change to first valid directory" << std::endl;

    return;
  }

  int num_args = args.size();

  if (num_args == 0) {
    string dirname = COSUser::getUserHome();

    cwsh->changeDir(dirname);
  }
  else {
    for (int i = 0; i < num_args; ++i) {
      string dirname = CStrUtil::stripSpaces(args[i]);

      if (dirname == "")
        dirname = COSUser::getUserHome();

      if (i == num_args - 1)
        dirname = CwshDir::lookup(cwsh, dirname, true);
      else {
        dirname = CwshDir::lookup(cwsh, dirname, false);

        if (dirname == "") continue;
      }

      cwsh->changeDir(dirname);
    }
  }
}

void
CwshShellCommandMgr::
completeCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "complete [-all|-best|-command|-file|-var] <pattern> ... ; "
                 "complete pattern" << std::endl;
    return;
  }

  enum CwshCompleteShow {
    COMPLETE_SHOW_ALL,
    COMPLETE_SHOW_BEST
  };

  enum CwshCompleteType {
    COMPLETE_TYPE_COMMAND,
    COMPLETE_TYPE_FILE,
    COMPLETE_TYPE_VAR
  };

  vector<string> args1;

  CwshCompleteShow show = COMPLETE_SHOW_ALL;
  CwshCompleteType type = COMPLETE_TYPE_COMMAND;

  int num_args = args.size();

  for (int i = 0; i < num_args; i++) {
    if (args[i][0] == '-') {
      string name = args[i].substr(1);

      if      (name == "all")
        show = COMPLETE_SHOW_ALL;
      else if (name == "best")
        show = COMPLETE_SHOW_BEST;
      else if (name == "command")
        type = COMPLETE_TYPE_COMMAND;
      else if (name == "file")
        type = COMPLETE_TYPE_FILE;
      else if (name == "var")
        type = COMPLETE_TYPE_VAR;
      else
        CWSH_THROW("Invalid argument.");
    }
    else
      args1.push_back(args[i]);
  }

  int num_args1 = args1.size();

  if (num_args1 < 1)
    CWSH_THROW("Too few arguments.");

  if (num_args1 > 1)
    CWSH_THROW("Too many arguments.");

  if (show == COMPLETE_SHOW_ALL) {
    string pattern_str = args1[0] + "*";

    vector<string> names;

    if      (type == COMPLETE_TYPE_COMMAND) {
      CwshPattern pattern(cwsh, pattern_str);

      pattern.expandPath(names);
    }
    else if (type == COMPLETE_TYPE_FILE) {
      CFileMatch fileMatch;

      fileMatch.matchPattern(pattern_str, names);
    }
    else {
      CwshPattern pattern(cwsh, pattern_str);

      pattern.expandVar(names);
    }

    int num_names = names.size();

    for (int i = 0; i < num_names; i++)
      std::cout << names[i] << std::endl;
  }
  else {
    string word;

    CwshComplete complete(cwsh, args1[0]);

    bool flag;

    if      (type == COMPLETE_TYPE_COMMAND)
      flag = complete.completeCommand (word);
    else if (type == COMPLETE_TYPE_FILE)
      flag = complete.completeFile    (word);
    else
      flag = complete.completeVariable(word);

    if (! flag)
      cwsh->beep();

    std::cout << word << std::endl;
  }
}

void
CwshShellCommandMgr::
continueCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "continue ; continue to next iteration of while/foreach" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 0)
    CWSH_THROW("Too many arguments.");

  CwshBlock *block = cwsh->findBlock(CWSH_BLOCK_TYPE_WHILE);

  if (block == NULL)
    block = cwsh->findBlock(CWSH_BLOCK_TYPE_FOREACH);

  if (block == NULL)
    CWSH_THROW("Not in while/foreach.");

  cwsh->setBlockContinue(true);
}

void
CwshShellCommandMgr::
defaultCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "default ; switch default statement" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args != 1)
    CWSH_THROW("Syntax Error.");

  if (args[0] != ":")
    CWSH_THROW("Syntax Error.");

  CWSH_THROW("Not in switch.");
}

void
CwshShellCommandMgr::
dirsCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "dirs [-l] ; print directory stack" << std::endl;
    return;
  }

  int num_args = args.size();

  int i = 0;

  bool expand_home = false;

  if (num_args > 0 && args[i] == "-l") {
    expand_home = true;

    i++;
  }

  if (i > num_args)
    CWSH_THROW("Too many arguments.");

  cwsh->printDirStack(expand_home);
}

void
CwshShellCommandMgr::
echoCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "echo [-n] args ; print arguments" << std::endl;
    return;
  }

  int num_args = args.size();

  int i = 0;

  bool new_line = true;

  if (num_args > 0 && args[0] == "-n") {
    new_line = false;

    i++;
  }

  if (i < num_args) {
    std::cout << args[i++];

    for ( ; i < num_args; i++)
      std::cout << " " << args[i];
  }
  else
    new_line = false;

  if (new_line)
    std::cout << std::endl;

  std::cout.flush();
}

void
CwshShellCommandMgr::
elseCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "else ; else clause of if" << std::endl;
    return;
  }

  CWSH_THROW("Not in if.");
}

void
CwshShellCommandMgr::
endCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "end ; end of while/foreach" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 0)
    CWSH_THROW("Too many arguments.");

  CWSH_THROW("Not in while/foreach.");
}

void
CwshShellCommandMgr::
endfuncCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "endfunc ; end of func" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 0)
    CWSH_THROW("Too many arguments.");

  CWSH_THROW("Not in func.");
}

void
CwshShellCommandMgr::
endifCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "endif ; end of if" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 0)
    CWSH_THROW("Too many arguments.");

  CWSH_THROW("Not in if.");
}

void
CwshShellCommandMgr::
endswCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "endsw ; end of switch" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 0)
    CWSH_THROW("Too many arguments.");

  CWSH_THROW("Not in switch.");
}

void
CwshShellCommandMgr::
evalCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "eval <arg> ... ; evaluate arg as if entered as input" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args == 0)
    CWSH_THROW("Too few arguments.");

  string line = CStrUtil::toString(args, " ");

  cwsh->processInputLine(line);
}

void
CwshShellCommandMgr::
execCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "exec <arg> ... ; execute command to replace shell" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args == 0)
    CWSH_THROW("Too few arguments.");

  vector<char *> cargs;

  cargs.resize(num_args + 1);

  int i = 0;

  for ( ; i < num_args; i++)
    cargs[i] = (char *) args[i].c_str();
  cargs[i] = NULL;

  execvp(cargs[0], &cargs[0]);

  _exit(255);
}

void
CwshShellCommandMgr::
exitCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "exit            ; exit shell" << std::endl;
    std::cout << "exit <expr> ... ; exit shell with specified return value" << std::endl;
    return;
  }

  int num_args = args.size();

  int status = 1;

  if (num_args > 0) {
    string expr_str = CStrUtil::toString(args, " ");

    CwshExprEvaluate expr(cwsh, expr_str);

    status = expr.process();
  }
  else {
    CwshVariable *variable = cwsh->lookupVariable("status");

    if (variable != NULL && variable->getNumValues() == 1) {
      if (CStrUtil::isInteger(variable->getValue(0)))
        status = CStrUtil::toInteger(variable->getValue(0));
    }
  }

  cwsh->setExit(true, status);
}

void
CwshShellCommandMgr::
exprCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "expr <expr> ... ; evaluate expression" << std::endl;
    return;
  }

  string expr_str = CStrUtil::toString(args, " ");

  CwshExprEvaluate expr(cwsh, expr_str);

  std::cout << expr.process() << std::endl;
}

void
CwshShellCommandMgr::
fgCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "fg           ; move current process to foreground" << std::endl;
    std::cout << "fg <job> ... ; move specified jobs to foreground" << std::endl;
    return;
  }

  uint num_args = args.size();

  if (num_args > 0) {
    for (uint i = 0; i < num_args; ++i) {
      CwshProcess *process = cwsh->getActiveProcess(args[i]);

      if (process == NULL)
        CWSH_THROW("No such job.");

      process->print();

      std::cout << std::endl;

      process->resume();

      process->wait();
    }
  }
  else {
    CwshProcess *process = cwsh->getCurrentActiveProcess();

    if (process == NULL)
      CWSH_THROW("No current job.");

    process->print();

    std::cout << std::endl;

    process->resume();

    process->wait();
  }
}

void
CwshShellCommandMgr::
foreachCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "foreach <arg> (<expr>) ; "
                 "loop for each value of <expr> setting <arg> to value" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args < 3)
    CWSH_THROW("Too few arguments.");

  string varname = args[0];

  if (args[1] != "(" || args[num_args - 1] != ")")
    CWSH_THROW("Words not parenthesized.");

  vector<string> values;

  for (int i = 2; i < num_args - 1; i++)
    values.push_back(args[i]);

  CwshLineArray lines;

  CwshShellCommand *command = cwsh->lookupShellCommand("foreach");

  cwsh->getInputBlock(command, lines);

  int num_values = values.size();

  for (int i = 0; i < num_values; i++) {
    cwsh->defineVariable(varname, values[i]);

    cwsh->startBlock(CWSH_BLOCK_TYPE_FOREACH, lines);

    while (! cwsh->inputEof()) {
      string line = cwsh->getInputLine();

      cwsh->processInputLine(line);

      if (cwsh->isBlockBreak   () ||
          cwsh->isBlockContinue() ||
          cwsh->isBlockReturn  ())
        break;

      if (cwsh->getBlockGotoDepth() > 0) {
        cwsh->setBlockBreak(true);
        break;
      }
    }

    cwsh->endBlock();

    if (cwsh->isBlockContinue() ||
        cwsh->isBlockReturn  ())
      break;
  }

  cwsh->setBlockContinue(false);
  cwsh->setBlockBreak(false);
}

void
CwshShellCommandMgr::
funcCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "func <name> <args> ; define function <name>" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args == 0) {
    cwsh->listAllFunctions();

    return;
  }

  if (num_args != 3)
    CWSH_THROW("Too few arguments.");

  if (args[1] != "(" || args[2] != ")")
    CWSH_THROW("Syntax Error.");

  CwshShellCommand *command = cwsh->lookupShellCommand("func");

  CwshLineArray lines;

  cwsh->getInputBlock(command, lines);

  cwsh->defineFunction(args[0], lines);
}

void
CwshShellCommandMgr::
globCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "glob <arg> ... ; expand supplied arguments" << std::endl;
    return;
  }

  int num_args = args.size();

  string str;

  for (int i = 0; i < num_args; i++)
    str += args[i];

  std::cout << str;
}

void
CwshShellCommandMgr::
gotoCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "goto <label> ; goto specified label" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args == 0)
    CWSH_THROW("Too few arguments.");

  if (num_args > 1)
    CWSH_THROW("Too many arguments.");

  cwsh->gotoBlockLabel(args[0]);
}

void
CwshShellCommandMgr::
hashstatCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "hashstat ; display command hashing statistics" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args != 0)
    CWSH_THROW("Too many arguments.");

  cwsh->printFilePathStats();
}

void
CwshShellCommandMgr::
helpCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "help       ; display commands" << std::endl;
    std::cout << "help <cmd> ; display help for specified command" << std::endl;
    return;
  }

  bool show_all = false;

  vector<string> cmds;

  uint num_args = args.size();

  for (uint i = 0; i < num_args; ++i) {
    if (args[i][0] == '-') {
      string name = args[i].substr(1);

      if      (name == "a")
        show_all = true;
      else
        CWSH_THROW("Invalid argument.");
    }
    else
      cmds.push_back(args[i]);
  }

  CwshShellCommandMgr *mgr = cwsh->getShellCommandMgr();

  uint num_cmds = cmds.size();

  if (num_cmds == 0) {
    set<string> cmds;

    uint num_commands = mgr->commands_.size();

    uint i = 0;

    for ( ; i < num_commands; ++i)
      cmds.insert(mgr->commands_[i]->getName());

    set<string>::const_iterator p1, p2;

    for (i = 0, p1 = cmds.begin(), p2 = cmds.end(); p1 != p2; ++i, ++p1) {
      if (show_all) {
        CwshShellCommand *command = mgr->lookup(*p1);

        CwshArgArray args;

        args.push_back("--help");

        (command->getProc())(cwsh, args);
      }
      else {
        if (i > 0) std::cout << " ";

        std::cout << *p1;
      }
    }

    if (! show_all)
      std::cout << std::endl;
  }
  else {
    for (uint i = 0; i < num_cmds; ++i) {
      CwshShellCommand *command = mgr->lookup(args[i]);

      if (command != NULL) {
        CwshArgArray args;

        args.push_back("--help");

        (command->getProc())(cwsh, args);
      }
      else
        CWSH_THROW("Unknown command " + args[0]);
    }
  }
}

void
CwshShellCommandMgr::
historyCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "history [-h|-r] ; display history" << std::endl;
    std::cout << "history <num>   ; display numbered history event" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 2)
    CWSH_THROW("Too many arguments.");

  bool show_numbers = true;
  bool show_time    = true;
  bool reverse      = false;
  int  num          = -1;

  for (int i = 0; i < num_args; i++) {
    if      (args[i] == "-h") {
      show_numbers = false;
      show_time    = false;
    }
    else if (args[i] == "-r")
      reverse = true;
    else {
      if (! CStrUtil::isInteger(args[i]))
        CWSH_THROW("Badly formed number.");

      num = CStrUtil::toInteger(args[i]);
    }
  }

  cwsh->displayHistory(num, show_numbers, show_time, reverse);
}

void
CwshShellCommandMgr::
ifCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "if (<expr>) then ; start of if statement" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args == 0)
    CWSH_THROW("Too few arguments.");

  string str = CStrUtil::toString(args, " ");

  uint i = 0;

  CwshExprParse parse(cwsh);

  string expr_str = parse.parse(str, &i);

  CStrUtil::skipSpace(str, &i);

  uint j = i;

  CStrUtil::skipNonSpace(str, &j);

  string word = str.substr(i, j - i);

  if (word == "then") {
    i = j;

    CStrUtil::skipSpace(str, &i);

    uint len = str.size();

    if (i < len)
      CWSH_THROW("Improper then.");

    CwshShellCommand *command = cwsh->lookupShellCommand("if");

    CwshLineArray lines;

    cwsh->getInputBlock(command, lines);

    if (cwsh->getDebug()) {
      std::cerr << "if ( " << expr_str << " ) then" << std::endl;

      uint num_lines = lines.size();

      for (i = 0; i < num_lines; i++)
        std::cerr << lines[i] << std::endl;

      std::cerr << "endif" << std::endl;
    }

    CwshExprEvaluate expr(cwsh, expr_str);

    int processing = expr.process();

    bool if_processed = processing;

    cwsh->startBlock(CWSH_BLOCK_TYPE_IF, lines);

    while (! cwsh->inputEof()) {
      string line = cwsh->getInputLine();

      vector<string> words;

      CwshString::addWords(line, words);

      if (words.size() > 0 && words[0] == "else") {
        if (words.size() > 1 && words[1] == "if") {
          string str = CStrUtil::toString(words, 2, -1);

          uint i = 0;

          CwshExprParse parse(cwsh);

          string expr_str = parse.parse(str, &i);

          CStrUtil::skipSpace(str, &i);

          uint j = i;

          CStrUtil::skipNonSpace(str, &j);

          string word = str.substr(i, j - i);

          if (word == "then") {
            i = j;

            CStrUtil::skipSpace(str, &i);

            uint len = str.size();

            if (i < len)
              CWSH_THROW("Improper then.");

            CwshExprEvaluate expr(cwsh, expr_str);

            int processing1 = expr.process();

            if (! if_processed)
              processing = processing1;

            if (processing)
              if_processed = true;
          }
          else {
            string line = str.substr(i);

            CwshExprEvaluate expr(cwsh, expr_str);

            int processing1 = expr.process();

            if (! if_processed)
              processing = processing1;
            else
              processing = false;

            if (processing)
              if_processed = true;

            if (processing) {
              cwsh->processInputLine(line);

              processing = false;
            }
          }
        }
        else {
          processing = ! if_processed;

          if (processing)
            if_processed = true;

          if (words.size() > 1) {
            string line = CStrUtil::toString(words, 1, -1);

            cwsh->processInputLine(line);

            processing = false;
          }
        }
      }
      else {
        if (processing)
          cwsh->processInputLine(line);
        else
          cwsh->skipInputBlock(line);
      }

      if (cwsh->isBlockBreak   () ||
          cwsh->isBlockContinue() ||
          cwsh->isBlockReturn  ())
        break;

      if (cwsh->getBlockGotoDepth() > 0)
        break;
    }

    cwsh->endBlock();
  }
  else {
    string line = str.substr(i);

    if (cwsh->getDebug())
      std::cerr << "if ( " << expr_str << " ) " << line << std::endl;

    CwshExprEvaluate expr(cwsh, expr_str);

    int processing = expr.process();

    if (processing)
      cwsh->processInputLine(line);
  }
}

void
CwshShellCommandMgr::
jobsCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "jobs [-l] ; display jobs" << std::endl;
    return;
  }

  int num_args = args.size();

  bool list_pids = false;

  for (int i = 0; i < num_args; i++) {
    if      (args[i] == "-l")
      list_pids = true;
    else
      CWSH_THROW("Usage: jobs [ -l ].");
  }

  cwsh->displayActiveProcesses(list_pids);
}

void
CwshShellCommandMgr::
killCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "kill -l                       ; list signals" << std::endl;
    std::cout << "kill [-<num>|-<signal>] <pid> ; kill process" << std::endl;
    return;
  }

  int num_args = args.size();

  bool list_signals = false;

  int signal_num = -1;

  int i = 0;

  for ( ; i < num_args; i++) {
    if      (args[i] == "-l")
      list_signals = true;
    else if (args[i].size() > 0 && args[i][0] == '-') {
      string arg = args[i].substr(1);

      if (args[i].size() > 1 && isdigit(args[i][1])) {
        if (! CStrUtil::isInteger(arg))
          CWSH_THROW("Badly formed number.");

        signal_num = CStrUtil::toInteger(arg);

        CwshSignal *signal = CwshSignal::lookup(signal_num);

        if (signal == NULL)
          CWSH_THROW("Bad signal number.");
      }
      else {
        CwshSignal *signal = CwshSignal::lookup(arg);

        if (signal == NULL)
          CWSH_THROW("Unknown signal name.");

        signal_num = signal->getNum();
      }
    }
    else
      break;
  }

  if (list_signals) {
    int num_signals = CwshSignal::getNumSignals();

    for (int j = 0; j < num_signals; j++) {
      CwshSignal *signal = CwshSignal::getSignal(j);

      std::cout << signal->getName() << " ";
    }

    std::cout << std::endl;

    return;
  }

  if (signal_num == -1)
    signal_num = SIGTERM;

  if (i >= num_args)
    CWSH_THROW("Too few arguments.");

  vector<int> pids;

  for ( ; i < num_args; i++) {
    int pid;

    if (args[i].size() > 0 && args[i][0] == '%')
      pid = cwsh->stringToProcessId(args[i]);
    else {
      if (! CStrUtil::isInteger(args[i]))
        CWSH_THROW("Arguments should be jobs or process id's.");

      pid = CStrUtil::toInteger(args[i]);
    }

    pids.push_back(pid);
  }

  uint num_pids = pids.size();

  for (uint i = 0; i < num_pids; ++i)
    cwsh->killProcess(pids[i], signal_num);
}

void
CwshShellCommandMgr::
limitCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "limit [-h] <name> <value> ; set named limit ti value" << std::endl;
    return;
  }

  int num_args = args.size();

  bool   hard  = false;
  string name  = "";
  string value = "";

  for (int i = 0; i < num_args; i++) {
    if      (args[i] == "-h")
      hard = true;
    else if (name == "")
      name = args[i];
    else if (value == "")
      value = args[i];
    else
      CWSH_THROW("Too many arguments.");
  }

  if (name == "") {
    cwsh->printAllResources(hard);

    return;
  }

  if (value == "") {
    cwsh->printResource(name, hard);

    return;
  }

  cwsh->limitResource(name, value, hard);
}

void
CwshShellCommandMgr::
niceCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "nice                       ; "
                 "get priority of current process" << std::endl;
    std::cout << "nice [+<num>|-<num>        ; "
                 "increase/decrease priority of current process" << std::endl;
    std::cout << "nice [+<num>|-<num>] <pid> ; "
                 "run command as specified priority" << std::endl;
    return;
  }

  int num_args = args.size();

  int pid = COSProcess::getProcessId();

  errno = 0;

  int priority = getpriority(PRIO_PROCESS, pid);

  if (priority == -1 && errno != 0)
    CWSH_THROW("getpriority failed.");

  if (num_args == 0) {
    std::cout << "Current Priority " << priority << std::endl;

    return;
  }

  int dpriority = 0;

  int i = 0;

  if (num_args > 0 && (args[i][0] == '+' || args[i][0] == '-')) {
    string istr = args[i].substr(1);

    if (! CStrUtil::isInteger(istr))
      CWSH_THROW("Invalid argument.");

    dpriority = CStrUtil::toInteger(istr);

    if (args[i][0] == '-')
      priority -= dpriority;
    else
      priority += dpriority;

    if (priority < -20 || priority > 20)
      CWSH_THROW("Invalid priority.");

    i++;
  }

  if (i < num_args) {
    CWSH_THROW("Not implemented.");

    int error = nice(dpriority);

    if (error < 0)
      CWSH_THROW("nice failed.");

    string command = CStrUtil::toString(args, i);

    cwsh->processInputLine(command);
  }
  else {
    int error = nice(dpriority);

    if (error < 0)
      CWSH_THROW("nice failed.");
  }
}

void
CwshShellCommandMgr::
nohupCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "nohup           ; set no hangup" << std::endl;
    std::cout << "nohup <command> ; run command with no hangup" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args == 0)
    CwshSignal::nohup();
  else {
    // TODO: start command with SIGHUP disabled

    CWSH_THROW("Not implemented.");

    string command = CStrUtil::toString(args, " ");

    cwsh->processInputLine(command);
  }
}

void
CwshShellCommandMgr::
notifyCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "notify       ; notify current processs" << std::endl;
    std::cout << "notify <pid> ; notify processs" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 0) {
    for (int i = 0; i < num_args; i++) {
      CwshProcess *process = cwsh->getActiveProcess(args[i]);

      if (process == NULL)
        CWSH_THROW("No such job.");

      process->setNotify(true);
    }
  }
  else {
    CwshProcess *process = cwsh->getCurrentActiveProcess();

    if (process == NULL)
      CWSH_THROW("No current job.");

    process->setNotify(true);
  }
}

void
CwshShellCommandMgr::
onintrCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "onintr         ; reset interrupts" << std::endl;
    std::cout << "onintr -       ; ignore interrupts" << std::endl;
    std::cout << "onintr <label> ; goto label on interrupt" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 1)
    CWSH_THROW("Too many arguments.");

  if (num_args == 0)
    CwshSignal::interruptReset();
  else {
    if (args[0] == "-")
      CwshSignal::interruptIgnore();
    else
      CwshSignal::interruptGoto(args[0]);
  }
}

void
CwshShellCommandMgr::
popdCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "popd        ; pop directory stack" << std::endl;
    std::cout << "popd +<num> ; pop directory stack by num" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 0 && args[0][0] == '+') {
    if (num_args > 1)
      CWSH_THROW("Too many arguments.");

    string arg = args[0].substr(1);

    if (! CStrUtil::isInteger(arg))
      CWSH_THROW("Invalid argument.");

    int num = CStrUtil::toInteger(arg);

    if (num > cwsh->sizeDirStack())
      CWSH_THROW("Directory stack not that deep.");

    string dirname = cwsh->popDirStack(num);

    cwsh->changeDir(dirname);
  }
  else {
    if (num_args > 0)
      CWSH_THROW("Too many arguments.");

    if (cwsh->sizeDirStack() == 0)
      CWSH_THROW("Directory stack empty.");

    string dirname = cwsh->popDirStack();

    cwsh->changeDir(dirname);
  }

  cwsh->printDirStack();
}

void
CwshShellCommandMgr::
printenvCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "printenv        ; print all environment variables" << std::endl;
    std::cout << "printenv <name> ; print named environment variable" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 1)
    CWSH_THROW("Too many arguments.");

  if (num_args == 1) {
    if (CEnvInst.exists(args[0]))
      std::cout << CEnvInst.get(args[0]) << std::endl;
    else
      CWSH_THROW("Undefined variable.");
  }
  else {
    vector<string> names;
    vector<string> values;

    CEnvInst.getSortedNameValues(names, values);

    int num_names = names.size();

    for (int i = 0; i < num_names; i++)
      std::cout << names[i] << "=" << values[i] << std::endl;
  }
}

void
CwshShellCommandMgr::
pushdCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "pushd        ; change to directory on top of directory stack" << std::endl;
    std::cout << "pushd <name> ; push specified directory" << std::endl;
    std::cout << "pushd +<num> ; push to numbers directory on stack" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 1)
    CWSH_THROW("Too many arguments.");

  if (num_args > 0) {
    if (args[0][0] == '+') {
      string arg = args[0].substr(1);

      if (! CStrUtil::isInteger(arg))
        CWSH_THROW("Invalid argument.");

      int num = CStrUtil::toInteger(arg);

      if (cwsh->sizeDirStack() < num)
        CWSH_THROW("Directory stack not that deep.");

      string dirname = cwsh->popDirStack(num);

      cwsh->pushDirStack();

      cwsh->changeDir(dirname);
    }
    else {
      string dirname = args[0];

      dirname = CwshDir::lookup(cwsh, dirname);

      cwsh->pushDirStack();

      cwsh->changeDir(dirname);
    }
  }
  else {
    if (cwsh->sizeDirStack() < 1)
      CWSH_THROW("No other directory.");

    string dirname = cwsh->popDirStack();

    cwsh->pushDirStack();

    cwsh->changeDir(dirname);
  }

  cwsh->printDirStack();
}

void
CwshShellCommandMgr::
rehashCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "rehash ; rehash command lookup from path" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args != 0)
    CWSH_THROW("Too many arguments.");

  cwsh->setFilePathActive(true);

  cwsh->clearFilePath();
}

void
CwshShellCommandMgr::
repeatCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "repeat <n> <command> ; repeat command <n> times" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args < 2)
    CWSH_THROW("Too few arguments.");

  if (! CStrUtil::isInteger(args[0]))
    throw "repeat: Badly formed number.";

  int count = CStrUtil::toInteger(args[0]);

  vector<string> words;

  for (int i = 1; i < num_args; i++)
    words.push_back(args[i]);

  for (int i = 0; i < count; i++) {
    CAutoPtr<CwshCommandData> command;

    command = new CwshCommandData(cwsh, words);

    CwshCommand *command1 = command->getCommand();

    if (command1 != NULL) {
      command1->start();

      command1->wait();
    }
  }
}

void
CwshShellCommandMgr::
returnCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "return ; return from function" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 0)
    CWSH_THROW("Too many arguments.");

  CwshBlock *block = cwsh->findBlock(CWSH_BLOCK_TYPE_FUNCTION);

  if (block == NULL)
    CWSH_THROW("Not in function.");

  cwsh->setBlockReturn(true);
}

void
CwshShellCommandMgr::
setCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "set                     ; list variables" << std::endl;
    std::cout << "set <var> = <value>     ; set variable to value" << std::endl;
    std::cout << "set <var> = ( <value> ) ; set variable to array value" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args == 0) {
    cwsh->listVariables();

    return;
  }

  vector<string> args1;

  for (int i = 0; i < num_args; i++) {
    const string &arg = args[i];

    string::size_type pos = arg.find('=');

    if (pos != string::npos) {
      if (pos > 0)
        args1.push_back(arg.substr(0, pos));

      args1.push_back("=");

      if (pos + 1 < arg.size())
        args1.push_back(arg.substr(pos + 1));
    }
    else
      args1.push_back(arg);
  }

  int num_args1 = args1.size();

  int i1 = 0;

  while (i1 < num_args1) {
    string name = args1[i1];

    i1++;

    if (i1 < num_args1 && args1[i1] == "=") {
      i1++;

      if (i1 < num_args1) {
        if (args1[i1] == "(") {
          i1++;

          vector<string> values;

          while (i1 < num_args1 && args1[i1] != ")") {
            values.push_back(args1[i1]);

            i1++;
          }

          if (i1 < num_args1)
            i1++;

          cwsh->defineVariable(name, values);
        }
        else {
          cwsh->defineVariable(name, args1[i1]);

          i1++;
        }
      }
      else
        cwsh->defineVariable(name, "");
    }
    else
      cwsh->defineVariable(name, "");
  }
}

void
CwshShellCommandMgr::
setenvCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "setenv                ; print all environment variables" << std::endl;
    std::cout << "setenv <name>         ; print environment variable value" << std::endl;
    std::cout << "setenv <name> <value> ; set environment variable to value" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 2)
    CWSH_THROW("Too many arguments.");

  if (num_args == 0) {
    vector<string> names;
    vector<string> values;

    CEnvInst.getSortedNameValues(names, values);

    int num_names = names.size();

    for (int i = 0; i < num_names; i++)
      std::cout << names[i] << "=" << values[i] << std::endl;

    return;
  }

  const string &name = args[0];

  string value = "";

  if (num_args == 2)
    value = args[1];

  if (cwsh->isEnvironmentVariableUpper(name)) {
    string name1 = CStrUtil::toLower(name);

    CStrWords words = CStrUtil::toFields(value, ":");

    if (words.size() > 1) {
      vector<string> values;

      int num_words = words.size();

      for (int i = 0; i < num_words; i++)
        values.push_back(words[i].getWord());

      cwsh->defineVariable(name1, values);
    }
    else
      cwsh->defineVariable(name1, value);
  }
  else
    CEnvInst.set(name, value);
}

void
CwshShellCommandMgr::
shiftCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "shift        ; shift out next value from argv" << std::endl;
    std::cout << "shift <name> ; shift out next value from array variable" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 1)
    CWSH_THROW("Too many arguments.");

  string name = "argv";

  if (num_args == 1)
    name = args[0];

  CwshVariable *variable = cwsh->lookupVariable(name);

  if (variable == NULL)
    CWSH_THROW("Undefined variable.");

  if (variable->getNumValues() <= 0)
    CWSH_THROW("No more words.");

  variable->shift();
}

void
CwshShellCommandMgr::
sourceCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "source [-h] <file> ... ; source specified files" << std::endl;
    return;
  }

  int num_args = args.size();

  bool   history  = false;
  string filename = "";

  for (int i = 0; i < num_args; i++) {
    if (args[i][0] == '-') {
      if (args[i] == "-h")
        history = true;
      else
        CWSH_THROW("Invalid Option " + args[i] + ".");
    }
    else {
      if (filename == "")
        filename = args[i];
      else
        CWSH_THROW("Too many arguments.");
    }
  }

  if (filename == "")
    CWSH_THROW("Too few arguments.");

  if (history)
    cwsh->addHistoryFile(filename);
  else
    cwsh->executeInput(filename);
}

void
CwshShellCommandMgr::
stopCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "stop       ; stop current process" << std::endl;
    std::cout << "stop <job> ; stop specified job" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 0) {
    for (int i = 0; i < num_args; i++) {
      CwshProcess *process = cwsh->getActiveProcess(args[i]);

      if (process == NULL)
        CWSH_THROW("No such job.");

      process->stop();
    }
  }
  else {
    CwshProcess *process = cwsh->getCurrentActiveProcess();

    if (process == NULL)
      CWSH_THROW("No current job.");

    process->stop();
  }
}

void
CwshShellCommandMgr::
suspendCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "suspend ; suspend current process" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 0)
    CWSH_THROW("Too many arguments.");

  int pid = COSProcess::getProcessId();

  COSSignal::sendSignal(pid, SIGTSTP);
}

void
CwshShellCommandMgr::
switchCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "switch ( <expr> ) ; switch on specified expression value" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args != 3)
    CWSH_THROW("Syntax Error.");

  if (args[0] != "(" || args[2] != ")")
    CWSH_THROW("Syntax Error.");

  CwshLineArray lines;

  CwshShellCommand *command = cwsh->lookupShellCommand("switch");

  cwsh->getInputBlock(command, lines);

  bool case_processed = false;

  cwsh->startBlock(CWSH_BLOCK_TYPE_SWITCH, lines);

  bool processing = false;

  while (! cwsh->inputEof()) {
    string line = cwsh->getInputLine();

    vector<string> words;

    CwshString::addWords(line, words);

    if      (words.size() > 0 && words[0] == "case") {
      if (words.size() != 3 || words[2] != ":")
        CWSH_THROW("Syntax Error.");

      if (! case_processed) {
        CAutoPtr<CwshWildCard> wildcard;

        wildcard = new CwshWildCard(words[1]);

        if (wildcard->checkMatch(args[1]))
          processing = true;
        else
          processing = false;
      }
      else
        processing = false;
    }
    else if (words.size() > 0 && words[0] == "default") {
      if (! case_processed)
        processing = true;
      else
        processing = false;
    }
    else if (words.size() > 0 && words[0] == "breaksw")
      processing = false;
    else {
      if (processing) {
        cwsh->processInputLine(line);

        case_processed = true;
      }
    }

    if (cwsh->isBlockBreak   () ||
        cwsh->isBlockContinue() ||
        cwsh->isBlockReturn  ())
      break;

    if (cwsh->getBlockGotoDepth() > 0)
      break;
  }

  cwsh->endBlock();
}

void
CwshShellCommandMgr::
umaskCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "umask         ; print current umask" << std::endl;
    std::cout << "umask <value> ; set umask to value" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 1)
    CWSH_THROW("Too many arguments.");

  if (num_args == 0) {
    uint mask = COSUser::getUMask();

    int int1 = mask/64;
    int int2 = (mask - int1*64)/8;
    int int3 = mask - int1*64 - int2*8;

    std::cout << (char)(int1 + '0') <<
                 (char)(int2 + '0') <<
                 (char)(int3 + '0') << std::endl;
  }
  else {
    int len = args[0].size();

    if (len > 3)
      CWSH_THROW("Improper mask.");

    int int1 = 0;
    int int2 = 0;
    int int3 = 0;

    if      (len == 3) {
      int1 = args[0][2] - '0';
      int2 = args[0][1] - '0';
      int3 = args[0][0] - '0';
    }
    else if (len == 2) {
      int1 = args[0][1] - '0';
      int2 = args[0][0] - '0';
    }
    else if (len == 1)
      int1 = args[0][0] - '0';

    if (int1 < 0 || int1 > 7 || int2 < 0 || int2 > 7 || int3 < 0 || int3 > 7)
      CWSH_THROW("Improper mask.");

    uint mask = int3*64 + int2*8 + int1;

    COSUser::setUMask(mask);
  }
}

void
CwshShellCommandMgr::
timeCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "time <command> ; time command" << std::endl;
    return;
  }

  struct tms tms_data1;

  clock_t c1 = times(&tms_data1);

  string command = CStrUtil::toString(args, " ");

  cwsh->processInputLine(command);

  struct tms tms_data2;

  clock_t c2 = times(&tms_data2);

  long ticks = sysconf(_SC_CLK_TCK);

  printf("Elapsed = %lf secs, User = %lf secs, System = %lf secs\n",
         ((double) (c2 - c1))/ticks,
         ((double) (tms_data2.tms_utime - tms_data1.tms_utime))/ticks,
         ((double) (tms_data2.tms_stime - tms_data1.tms_stime))/ticks);
}

void
CwshShellCommandMgr::
unhashCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "unhash ; disable path command hashing" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args != 0)
    CWSH_THROW("Too many arguments.");

  cwsh->setFilePathActive(false);

  cwsh->clearFilePath();
}

void
CwshShellCommandMgr::
unaliasCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "unalias <name> ; undefine specified alias" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args < 1)
    CWSH_THROW("Too few arguments.");

  for (int i = 0; i < num_args; i++)
    cwsh->undefineAlias(args[i]);
}

void
CwshShellCommandMgr::
unlimitCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "unlimit                ; unlimit all resources" << std::endl;
    std::cout << "unlimit <resource> ... ; unlimit specified resource" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args == 0) {
    cwsh->unlimitAllResources();

    return;
  }

  for (int i = 0; i < num_args; i++)
    cwsh->unlimitResource(args[i]);
}

void
CwshShellCommandMgr::
unsetCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "unset <variable> ... ; unset specified variables" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args < 1)
    CWSH_THROW("Too few arguments.");

  for (int i = 0; i < num_args; i++)
    cwsh->undefineVariable(args[i]);
}

void
CwshShellCommandMgr::
unsetenvCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "unsetenv <variable> ... ; unset specified variables" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args < 1)
    CWSH_THROW("Too few arguments.");

  for (int i = 0; i < num_args; i++)
    if (CEnvInst.exists(args[i]))
      CEnvInst.unset(args[i]);
}

void
CwshShellCommandMgr::
waitCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "wait ; wait on active processes" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args > 0)
    CWSH_THROW("Too many arguments.");

  cwsh->waitActiveProcesses();
}

void
CwshShellCommandMgr::
whichCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "which [-a] <name> ; find alias, function or path of specified name" << std::endl;
    return;
  }

  int num_args = args.size();

  bool show_all = false;

  vector<string> files;

  for (int i = 0; i < num_args; i++) {
    if (args[i][0] == '-') {
      if (args[i] == "-a")
        show_all = true;
      else
        CWSH_THROW("Invalid Option " + args[i]);
    }
    else
      files.push_back(args[i]);
  }

  if (files.size() == 0)
    CWSH_THROW("Too few arguments.");

  int num_files = files.size();

  for (int i = 0; i < num_files; i++) {
    bool found = false;

    //------

    CwshAlias *alias = cwsh->lookupAlias(files[i]);

    if (alias != NULL) {
      found = true;

      std::cout << "alias: " << alias->getValue() << std::endl;

      if (! show_all)
        continue;
    }

    //------

    CwshFunction *function = cwsh->lookupFunction(files[i]);

    if (function != NULL) {
      found = true;

      std::cout << "function: " << files[i] << std::endl;

      if (! show_all)
        continue;
    }

    //------

    CwshShellCommand *command = cwsh->lookupShellCommand(files[i]);

    if (command != NULL) {
      found = true;

      std::cout << "builtin: " << files[i] << std::endl;

      if (! show_all)
        continue;
    }

    //------

    try {
      string path = CwshUnixCommand::search(cwsh, files[i]);

      found = true;

      std::cout << path << std::endl;

      if (! show_all)
        continue;
    }
    catch (...) {
    }

    //------

    if (! found)
      CWSH_THROW("no " + files[i] + " in (" + CEnvInst.get("PATH") + ")");
  }
}

void
CwshShellCommandMgr::
whileCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "while <expr> ; loop while expression is true" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args == 0)
    CWSH_THROW("Too few arguments.");

  string str = CStrUtil::toString(args, " ");

  string str1 = cwsh->processInputExprLine(str);

  uint i = 0;

  CwshExprParse parse(cwsh);

  string expr_str = parse.parse(str1, &i);

  CStrUtil::skipSpace(str1, &i);

  uint len1 = str1.size();

  if (i < len1)
    CWSH_THROW("Expression Syntax.");

  CwshShellCommand *command = cwsh->lookupShellCommand("while");

  CwshLineArray lines;

  cwsh->getInputBlock(command, lines);

  CwshExprEvaluate expr(cwsh, expr_str);

  int processing = expr.process();

  while (processing) {
    cwsh->startBlock(CWSH_BLOCK_TYPE_WHILE, lines);

    while (! cwsh->inputEof()) {
      string line = cwsh->getInputLine();

      cwsh->processInputLine(line);

      if (cwsh->isBlockBreak   () ||
          cwsh->isBlockContinue() ||
          cwsh->isBlockReturn  ())
        break;

      if (cwsh->getBlockGotoDepth() > 0) {
        cwsh->setBlockBreak(true);
        break;
      }

      if (cwsh->getInterrupt())
        break;
    }

    cwsh->endBlock();

    if (cwsh->isBlockBreak () ||
        cwsh->isBlockReturn())
      break;

    if (cwsh->getInterrupt())
      break;

    str1 = cwsh->processInputExprLine(str);

    i = 0;

    CwshExprParse parse(cwsh);

    expr_str = parse.parse(str1, &i);

    CStrUtil::skipSpace(str1, &i);

    uint len1 = str1.size();

    if (i < len1)
      CWSH_THROW("Expression Syntax.");

    CwshExprEvaluate expr(cwsh, expr_str);

    processing = expr.process();
  }

  cwsh->setBlockContinue(false);
  cwsh->setBlockBreak   (false);
}

void
CwshShellCommandMgr::
atCmd(Cwsh *cwsh, const CwshArgArray &args)
{
  if (isHelpArg(args)) {
    std::cout << "@                ; list all variables" << std::endl;
    std::cout << "@ <name> <value> ; set variable to numeric value" << std::endl;
    return;
  }

  int num_args = args.size();

  if (num_args == 0) {
    cwsh->listVariables();

    return;
  }

  string str = CStrUtil::toString(args, " ");

  string            name;
  int               index;
  string            expr_str;
  CwshSetAssignType assign_type;

  CwshSet set(cwsh);

  set.parseAssign(str, name, &index, &assign_type, expr_str);

  set.processAssign(name, index, assign_type, expr_str);
}

void
CwshShellCommandMgr::
badCmd(Cwsh *, const CwshArgArray &args)
{
  if (isHelpArg(args)) return;

  int num_args = args.size();

  for (int i = 0; i < num_args; i++)
    std::cerr << " " << args[i];

  std::cerr << std::endl;

  CWSH_THROW("unimplemented Command.");
}

bool
CwshShellCommandMgr::
isHelpArg(const CwshArgArray &args)
{
  uint num_args = args.size();

  for (uint i = 0; i < num_args; i++)
    if (args[i] == "--help")
      return true;

  return false;
}
##concat##CwshSignal.cpp
#include <CwshI.h>
#include <COSSignal.h>
#include <cerrno>

CwshSignal
CwshSignal::signals_[] = {
  CwshSignal("HUP"   , SIGHUP   ),
  CwshSignal("INT"   , SIGINT   ),
  CwshSignal("QUIT"  , SIGQUIT  ),
  CwshSignal("ILL"   , SIGILL   ),
  CwshSignal("TRAP"  , SIGTRAP  ),
  CwshSignal("ABRT"  , SIGABRT  ),
  CwshSignal("IOT"   , SIGIOT   ),
  CwshSignal("BUS"   , SIGBUS   ),
  CwshSignal("FPE"   , SIGFPE   ),
  CwshSignal("KILL"  , SIGKILL  ),
  CwshSignal("USR1"  , SIGUSR1  ),
  CwshSignal("SEGV"  , SIGSEGV  ),
  CwshSignal("USR2"  , SIGUSR2  ),
  CwshSignal("PIPE"  , SIGPIPE  ),
  CwshSignal("ALRM"  , SIGALRM  ),
  CwshSignal("TERM"  , SIGTERM  ),
#ifdef SIGSTKFLT
  CwshSignal("STKFLT", SIGSTKFLT),
#endif
  CwshSignal("CHLD"  , SIGCHLD  ),
  CwshSignal("CONT"  , SIGCONT  ),
  CwshSignal("STOP"  , SIGSTOP  ),
  CwshSignal("TSTP"  , SIGTSTP  ),
  CwshSignal("TTIN"  , SIGTTIN  ),
  CwshSignal("TTOU"  , SIGTTOU  ),
  CwshSignal("URG"   , SIGURG   ),
#ifdef SIGXCPU
  CwshSignal("XCPU"  , SIGXCPU  ),
#endif
#ifdef SIGXFSZ
  CwshSignal("XFSZ"  , SIGXFSZ  ),
#endif
#ifdef SIGVTALRM
  CwshSignal("VTALRM", SIGVTALRM),
#endif
  CwshSignal("PROF"  , SIGPROF  ),
  CwshSignal("WINCH" , SIGWINCH ),
  CwshSignal("IO"    , SIGIO    ),
#ifdef SIGPOLL
  CwshSignal("POLL"  , SIGPOLL  ),
#endif
#ifdef SIGPWR
  CwshSignal("PWR"   , SIGPWR   ),
#endif
#ifdef SIGSYS
  CwshSignal("SYS"   , SIGSYS   ),
#endif
};

CwshInterruptType CwshSignal::interrupt_type_ = CWSH_INTERRUPT_TYPE_NORMAL;
string            CwshSignal::interrupt_label_;

void
CwshSignal::
addHandlers()
{
  COSSignal::addSignalHandler(SIGHUP  , (COSSignal::SignalHandler) termHandler     );
  COSSignal::addSignalHandler(SIGINT  , (COSSignal::SignalHandler) interruptHandler);
  COSSignal::addSignalHandler(SIGQUIT , (COSSignal::SignalHandler) genericHandler  );
  COSSignal::addSignalHandler(SIGILL  , (COSSignal::SignalHandler) genericHandler  );
  COSSignal::addSignalHandler(SIGTRAP , (COSSignal::SignalHandler) genericHandler  );
  COSSignal::addSignalHandler(SIGIOT  , (COSSignal::SignalHandler) genericHandler  );
  COSSignal::addSignalHandler(SIGFPE  , (COSSignal::SignalHandler) genericHandler  );
  COSSignal::addSignalHandler(SIGUSR1 , (COSSignal::SignalHandler) genericHandler  );
  COSSignal::addSignalHandler(SIGUSR2 , (COSSignal::SignalHandler) genericHandler  );
  COSSignal::addSignalHandler(SIGPIPE , (COSSignal::SignalHandler) genericHandler  );
  COSSignal::addSignalHandler(SIGALRM , (COSSignal::SignalHandler) genericHandler  );
  COSSignal::addSignalHandler(SIGTERM , (COSSignal::SignalHandler) genericHandler  );
  COSSignal::addSignalHandler(SIGCONT , (COSSignal::SignalHandler) genericHandler  );
  COSSignal::addSignalHandler(SIGTSTP , (COSSignal::SignalHandler) stopHandler     );
  COSSignal::addSignalHandler(SIGTTIN , (COSSignal::SignalHandler) SIG_IGN         );
  COSSignal::addSignalHandler(SIGTTOU , (COSSignal::SignalHandler) genericHandler  );
  COSSignal::addSignalHandler(SIGWINCH, (COSSignal::SignalHandler) genericHandler  );
}

void
CwshSignal::
nohup()
{
  COSSignal::addSignalHandler(SIGHUP, (COSSignal::SignalHandler) SIG_IGN);
}

void
CwshSignal::
termHandler(int)
{
  CwshMgrInst.term(0);
}

// TODO: use static of type 'volatile sig_atomic_t flag'

// TODO: use sigsetjmp, siglongjmp to handle interrupt and restart readline loop
// and ensure signal handling is not changed
void
CwshSignal::
interruptHandler(int)
{
  if      (interrupt_type_ == CWSH_INTERRUPT_TYPE_NORMAL) {
    CwshMgrInst.setInterrupt(true);

    CwshMgrInst.readInterrupt();
  }
  else if (interrupt_type_ == CWSH_INTERRUPT_TYPE_GOTO)
    CwshMgrInst.gotoBlockLabel(interrupt_label_);
}

void
CwshSignal::
stopHandler(int)
{
  int savedErrno = errno; // In case we change 'errno'

#if 0
  //printf("Caught SIGTSTP\n");         /* UNSAFE (see Section 21.1.2) */

  if (signal(SIGTSTP, SIG_DFL) == SIG_ERR)
    errExit("signal");              /* Set handling to default */

  raise(SIGTSTP);                     /* Generate a further SIGTSTP */

  /* Unblock SIGTSTP; the pending SIGTSTP immediately suspends the program */

  COSSignal::unblockSignal(SIGTSTP);

  sigset_t prevMask = COSSignal::getOldSigSet();

  /* Execution resumes here after SIGCONT */

  COSSignal::setSigProcMask(prevMask);

  COSSignal::addSignalHandler(SIGTSTP, stopHandler, CSIGNAL_OPT_RESTART);

  //printf("Exiting SIGTSTP handler\n");
#else
  std::cerr << "stopHandler" << std::endl;

  CwshMgrInst.stopActiveProcesses();
#endif

  errno = savedErrno;
}

void
CwshSignal::
genericHandler(int)
{
#if 0
  CwshSignal *sig = lookup(num);

  std::cerr << "Signal " << sig->name_ << "(" << sig->num_ << ") received" << std::endl;
#endif
}

CwshSignal::
CwshSignal(const string &name, int num) :
 name_(name), num_(num)
{
}

CwshSignal *
CwshSignal::
lookup(const string &name)
{
  int num_signals = getNumSignals();

  for (int i = 0; i < num_signals; i++)
    if (name == signals_[i].name_)
      return &signals_[i];

  return NULL;
}

CwshSignal *
CwshSignal::
lookup(int num)
{
  int num_signals = getNumSignals();

  for (int i = 0; i < num_signals; i++)
    if (num == signals_[i].num_)
      return &signals_[i];

  return NULL;
}

int
CwshSignal::
getNumSignals()
{
  return sizeof(signals_)/sizeof(CwshSignal);
}

CwshSignal *
CwshSignal::
getSignal(int i)
{
  return &signals_[i];
}
##concat##CwshState.cpp
#include <CwshI.h>

CwshStateMgr::
CwshStateMgr(Cwsh *cwsh) :
 cwsh_(cwsh)
{
}

void
CwshStateMgr::
save(Cwsh *cwsh)
{
  if (current_state_ != NULL) {
    state_stack_.push(current_state_);

    current_state_.release();
  }

  current_state_ = new CwshState(cwsh);
}

void
CwshStateMgr::
restore()
{
  if (current_state_ == NULL)
    CWSH_THROW("Not in saved state.");

  if (! state_stack_.empty()) {
    CwshState *state;

    state_stack_.pop(&state);

    current_state_ = state;
  }
  else
    current_state_ = NULL;
}

//-----

CwshState::
CwshState(Cwsh *cwsh) :
 cwsh_(cwsh)
{
  dir_ = COSFile::getCurrentDir();

  cwsh_->saveVariables();
}

CwshState::
~CwshState()
{
  cwsh_->changeDir(dir_);

  cwsh_->restoreVariables();
}
##concat##CwshString.cpp
#include <CwshI.h>
#include <CGlob.h>

string
CwshString::
replaceHome(const string &str)
{
  string str1;

  if (! CFile::addTilde(str, str1))
    return str;

  return str1;
}

void
CwshString::
skipWordsToChar(const string &str, uint *i, int c)
{
  uint len = str.size();

  int brackets = 0;

  while (*i < len) {
    if      (str[*i] == '\"') {
      if (! CStrUtil::skipDoubleQuotedString(str, i))
        CWSH_THROW("Unmatched \".");
    }
    else if (str[*i] == '\'') {
      if (! CStrUtil::skipSingleQuotedString(str, i))
        CWSH_THROW("Unmatched \'.");
    }
    else if (str[*i] == '`') {
      if (! CStrUtil::skipBackQuotedString(str, i))
        CWSH_THROW("Unmatched `.");
    }
    else if (str[*i] == '(') {
      brackets++;

      (*i)++;
    }
    else if (str[*i] == ')') {
      if (brackets == 0) {
        if (c == str[*i])
          break;

        CWSH_THROW("Too many )'s.");
      }
      else
        brackets--;

      (*i)++;
    }
    else if (brackets == 0 && c == str[*i])
      break;
    else
      (*i)++;
  }

  if (*i >= len)
    CWSH_THROW(string("Unmatched ") + ((char) c) + ".");
}

void
CwshString::
skipWord(const string &str, uint *i)
{
  uint len = str.size();

  int brackets = 0;

  while (*i < len) {
    if      (str[*i] == '\"') {
      if (! CStrUtil::skipDoubleQuotedString(str, i))
        CWSH_THROW("Unmatched \".");
    }
    else if (str[*i] == '\'') {
      if (! CStrUtil::skipSingleQuotedString(str, i))
        CWSH_THROW("Unmatched \'.");
    }
    else if (str[*i] == '`') {
      if (! CStrUtil::skipBackQuotedString(str, i))
        CWSH_THROW("Unmatched `.");
    }
    else if (str[*i] == '(') {
      brackets++;

      (*i)++;
    }
    else if (str[*i] == ')') {
      if (brackets == 0)
        CWSH_THROW("Too many )'s.");
      else
        brackets--;

      (*i)++;
    }
    else if (brackets == 0 && isspace(str[*i]))
      break;
    else
      (*i)++;
  }
}

void
CwshString::
addWords(const string &str, vector<string> &words)
{
  uint len = str.size();

  string word;

  uint i = 0;

  while (i < len) {
    if      (isspace(str[i])) {
      if (word.size() > 0) {
        words.push_back(word);

        word = "";
      }

      CStrUtil::skipSpace(str, &i);
    }
    else if (str[i] == '\"') {
      uint i1 = i;

      if (! CStrUtil::skipDoubleQuotedString(str, &i))
        CWSH_THROW("Unmatched \".");

      word += str.substr(i1, i - i1);
    }
    else if (str[i] == '\'') {
      uint i1 = i;

      if (! CStrUtil::skipSingleQuotedString(str, &i))
        CWSH_THROW("Unmatched \'.");

      word += str.substr(i1, i - i1);
    }
    else if (str[i] == '`') {
      uint i1 = i;

      if (! CStrUtil::skipBackQuotedString(str, &i))
        CWSH_THROW("Unmatched `.");

      word += str.substr(i1, i - i1);
    }
    else if (str[i] == '(' || str[i] == ')' || str[i] == ';') {
      if (word.size() > 0) {
        words.push_back(word);

        word = "";
      }

      word += str[i++];

      words.push_back(word);

      word = "";
    }
    else if (str[i] == '&') {
      if (word.size() > 0) {
        words.push_back(word);

        word = "";
      }

      word += str[i++];

      if      (i < len && str[i] == '&')
        word += str[i++];

      words.push_back(word);

      word = "";
    }
    else if (str[i] == '|') {
      if (word.size() > 0) {
        words.push_back(word);

        word = "";
      }

      word += str[i++];

      if (i < len && (str[i] == '|' || str[i] == '&'))
        word += str[i++];

      words.push_back(word);

      word = "";
    }
    else if (str[i] == '<') {
      if (word.size() > 0) {
        words.push_back(word);

        word = "";
      }

      word += str[i++];

      if (i < len && str[i] == '<')
        word += str[i++];

      words.push_back(word);

      word = "";
    }
    else if (str[i] == '>') {
      if (word.size() > 0) {
        words.push_back(word);

        word = "";
      }

      word += str[i++];

      if      (i < len && str[i] == '!')
        word += str[i++];
      else if (i < len && str[i] == '>') {
        word += str[i++];

        if      (i < len && str[i] == '!')
          word += str[i++];
        else if (i < len && str[i] == '&') {
          word += str[i++];

          if (i < len && str[i] == '!')
            word += str[i++];
        }
      }
      else if (str[i] == '&') {
        word += str[i++];

        if (i < len && str[i] == '!')
          word += str[i++];
      }

      words.push_back(word);

      word = "";
    }
    else if (str[i] == ':') {
      if (CStrUtil::isIdentifier(word)) {
        words.push_back(word);

        word = str[i++];

        words.push_back(word);

        word = "";
      }
      else
        word += str[i++];
    }
    else if (str[i] == '\\') {
      word += str[i++];

      if (i < len)
        word += str[i++];
    }
    else
      word += str[i++];
  }

  if (word.size() > 0)
    words.push_back(word);
}

string
CwshString::
readLineFromFile(CFile *file)
{
  if (file->eof())
    CWSH_THROW("EOF");

  string line;

  file->readLine(line);

  while (line.size() > 0 && line[line.size() - 1] == '\\') {
    line = line.substr(0, line.size() - 1);

    string line1;

    file->readLine(line1);

    line += line1;
  }

  return line;
}

bool
CwshString::
matchUsers(const string &pattern, vector<string> &names)
{
  CGlob glob(pattern);

  glob.setAllowOr(false);
  glob.setAllowNonPrintable(true);

  vector<string> pw_names;

  COSUser::getUsers(pw_names);

  int num_names = pw_names.size();

  for (int i = 0; i < num_names; ++i) {
    if (glob.compare(pw_names[i]))
      names.push_back(pw_names[i]);
  }

  if (names.size() == 0)
    return false;

  return true;
}
##concat##CwshUnixCommand.cpp
#include <CwshI.h>
#include <CPathList.h>

string
CwshUnixCommand::
search(Cwsh *cwsh, const string &name)
{
  CPathList pathList;

  pathList.addEnvValue("PATH");

  string path;

  if (! pathList.search(name, path))
    CWSH_THROW(name + ": Command not found.");

  cwsh->addFilePath(name, path);

  return path;
}
##concat##CwshVariable.cpp
#include <CwshI.h>

enum CwshGetVariableType {
  CWSH_GET_VARIABLE_VALUES,
  CWSH_GET_VARIABLE_SIZE,
  CWSH_GET_VARIABLE_EXISTS
};

enum CwshVariableModifierType {
  CWSH_VARIABLE_MODIFIER_NONE,
  CWSH_VARIABLE_MODIFIER_ROOT,
  CWSH_VARIABLE_MODIFIER_EXTENSION,
  CWSH_VARIABLE_MODIFIER_HEADER,
  CWSH_VARIABLE_MODIFIER_TAIL,
  CWSH_VARIABLE_MODIFIER_QUOTE_WORDLIST,
  CWSH_VARIABLE_MODIFIER_QUOTE_PATTERN
};

string
CwshVariableMgr::
lower_env_names_[] = {
  "home",
  "path",
  "shell",
  "term",
  "user"
};

string
CwshVariableMgr::
upper_env_names_[] = {
  "HOME",
  "PATH",
  "SHELL",
  "TERM",
  "USER"
};

CwshVariableMgr::
CwshVariableMgr(Cwsh *cwsh) :
 cwsh_(cwsh)
{
}

CwshVariableMgr::
CwshVariableMgr(const CwshVariableMgr &mgr) :
 cwsh_(mgr.cwsh_)
{
  CwshVariableList::const_iterator pvariable1 = mgr.variables_.begin();
  CwshVariableList::const_iterator pvariable2 = mgr.variables_.end  ();

  for ( ; pvariable1 != pvariable2; ++pvariable1)
    variables_.push_back(new CwshVariable(**pvariable1));

  CwshVariableMgrArray::const_iterator pstack1 = mgr.stack_.begin();
  CwshVariableMgrArray::const_iterator pstack2 = mgr.stack_.end  ();

  for ( ; pstack1 != pstack2; ++pstack1)
    stack_.push_back(new CwshVariableMgr(**pstack1));
}

CwshVariableMgr::
~CwshVariableMgr()
{
  clear();
}

void
CwshVariableMgr::
define(const CwshVariableName &name)
{
  if (cwsh_->getDebug())
    std::cout << "define " << name << std::endl;

  undefine(name);

  CwshVariable *variable = new CwshVariable(cwsh_, name, "");

  variables_.push_back(variable);

  variables_.sort(CwshVariablesCmp());
}

void
CwshVariableMgr::
define(const CwshVariableName &name, const CwshVariableValue &value)
{
  if (cwsh_->getDebug())
    std::cout << "define " << name << "='" << value << "'" << std::endl;

  undefine(name);

  CwshVariable *variable = new CwshVariable(cwsh_, name, value);

  variables_.push_back(variable);

  variables_.sort(CwshVariablesCmp());
}

void
CwshVariableMgr::
define(const CwshVariableName &name, int value)
{
  if (cwsh_->getDebug())
    std::cout << "define " << name << "='" << value << "'" << std::endl;

  undefine(name);

  if (name == "_debug")
    cwsh_->setDebug(value != 0);

  CwshVariable *variable = new CwshVariable(cwsh_, name, CStrUtil::toString(value));

  variables_.push_back(variable);

  variables_.sort(CwshVariablesCmp());
}

void
CwshVariableMgr::
define(const CwshVariableName &name, const CwshVariableValueArray &values)
{
  if (cwsh_->getDebug()) {
    string value = CStrUtil::toString(values, " ");

    std::cout << "define " << name << "='" << value << "'" << std::endl;
  }

  undefine(name);

  CwshVariable *variable = new CwshVariable(cwsh_, name, values);

  variables_.push_back(variable);

  variables_.sort(CwshVariablesCmp());
}

void
CwshVariableMgr::
define(const CwshVariableName &name, const char **values, int num_values)
{
  if (cwsh_->getDebug()) {
    string value = CStrUtil::toString(values, num_values, " ");

    std::cout << "define " << name << "='" << value << "'" << std::endl;
  }

  undefine(name);

  CwshVariable *variable = new CwshVariable(cwsh_, name, values, num_values);

  variables_.push_back(variable);

  variables_.sort(CwshVariablesCmp());
}

void
CwshVariableMgr::
undefine(const CwshVariableName &name)
{
  CwshVariable *variable = lookup(name);

  if (variable != NULL) {
    variables_.remove(variable);

    delete variable;
  }
}

CwshVariable *
CwshVariableMgr::
lookup(const CwshVariableName &name) const
{
  CwshVariableList::const_iterator pvariable1 = variables_.begin();
  CwshVariableList::const_iterator pvariable2 = variables_.end  ();

  for ( ; pvariable1 != pvariable2; ++pvariable1)
    if ((*pvariable1)->getName() == name)
      return *pvariable1;

  return NULL;
}

void
CwshVariableMgr::
listVariables() const
{
  CwshVariableList::const_iterator pvariable1 = variables_.begin();
  CwshVariableList::const_iterator pvariable2 = variables_.end  ();

  for ( ; pvariable1 != pvariable2; ++pvariable1)
    (*pvariable1)->print();
}

void
CwshVariableMgr::
clear()
{
  std::for_each(variables_.begin(), variables_.end(), CDeletePointer());

  variables_.clear();

  std::for_each(stack_.begin(), stack_.end(), CDeletePointer());

  stack_.clear();
}

void
CwshVariableMgr::
save()
{
  CwshVariableMgr *copy = new CwshVariableMgr(*this);

  stack_.push_back(copy);
}

void
CwshVariableMgr::
restore()
{
  if (stack_.size() == 0)
    CWSH_THROW("Not in save state.");

  CwshVariableMgr *variable_mgr = stack_[stack_.size() - 1];

  stack_.pop_back();

  clear();

  copy(variable_mgr->variables_.begin(), variable_mgr->variables_.end(),
       back_inserter(variables_));

  variable_mgr->variables_.clear();

  copy(variable_mgr->stack_.begin(), variable_mgr->stack_.end(),
       back_inserter(stack_));

  variable_mgr->stack_.clear();

  delete variable_mgr;
}

bool
CwshVariableMgr::
isEnvironmentVariableLower(const string &name)
{
  int num_env_names_ = sizeof(lower_env_names_)/sizeof(string);

  for (int i = 0; i < num_env_names_; i++)
    if (lower_env_names_[i] == name)
      return true;

  return false;
}

bool
CwshVariableMgr::
isEnvironmentVariableUpper(const string &name)
{
  int num_env_names_ = sizeof(upper_env_names_)/sizeof(string);

  for (int i = 0; i < num_env_names_; i++)
    if (upper_env_names_[i] == name)
      return true;

  return false;
}

void
CwshVariableMgr::
updateEnvironmentVariable(CwshVariable *variable)
{
  string name = CStrUtil::toUpper(variable->getName());

  string value;

  int num_values = variable->getNumValues();

  for (int i = 0; i < num_values; i++) {
    if (i > 0)
      value += ":";

    value += variable->getValue(i);
  }

  CEnvInst.set(name, value);
}

CwshVariable::
CwshVariable(Cwsh *cwsh, const CwshVariableName &name, const CwshVariableValue &value) :
 cwsh_(cwsh), name_(name)
{
  checkName();

  values_.push_back(value);

  init();
}

CwshVariable::
CwshVariable(Cwsh *cwsh, const CwshVariableName &name, int value) :
 cwsh_(cwsh), name_(name)
{
  checkName();

  CwshVariableValue value1 = CStrUtil::toString(value);

  values_.push_back(value1);

  init();
}

CwshVariable::
CwshVariable(Cwsh *cwsh, const CwshVariableName &name, const CwshVariableValueArray &values) :
 cwsh_(cwsh), name_(name), values_(values)
{
  checkName();

  init();
}

CwshVariable::
CwshVariable(Cwsh *cwsh, const CwshVariableName &name, const char **values, int num_values) :
 cwsh_(cwsh), name_(name)
{
  checkName();

  for (int i = 0; i < num_values; ++i)
    values_.push_back(values[i]);

  init();
}

CwshVariable::
CwshVariable(const CwshVariable &variable) :
 cwsh_(variable.cwsh_), name_(variable.name_), type_(variable.type_), env_var_(variable.env_var_)
{
  int num_values = variable.values_.size();

  for (int i = 0; i < num_values; ++i)
    values_.push_back(variable.values_[i]);
}

CwshVariable::
~CwshVariable()
{
}

void
CwshVariable::
checkName()
{
  int len = name_.size();

  if (len < 1)
    CWSH_THROW("NULL variable Name");

  if (name_[0] != '_' && ! isalpha(name_[0]))
    CWSH_THROW("Variable name must begin with a letter or underscore");

  for (int i = 1; i < len; i++)
    if (name_[i] != '_' && ! isalnum(name_[i]))
      CWSH_THROW("Variable name must contain only letters, "
                 "numbers or underscore");
}

void
CwshVariable::
init()
{
  env_var_ = cwsh_->isEnvironmentVariableLower(name_);

  if (env_var_)
    cwsh_->updateEnvironmentVariable(this);
}

const CwshVariableName &
CwshVariable::
getName() const
{
  return name_;
}

CwshVariableType
CwshVariable::
getType() const
{
  return type_;
}

int
CwshVariable::
getNumValues() const
{
  return values_.size();
}

const CwshVariableValueArray &
CwshVariable::
getValues() const
{
  return values_;
}

const CwshVariableValue &
CwshVariable::
getValue(int pos) const
{
  return values_[pos];
}

void
CwshVariable::
setValue(int pos, const CwshVariableValue &value)
{
  values_[pos] = value;
}

void
CwshVariable::
shift()
{
  int len = values_.size();

  for (int i = 1; i < len; i++)
    values_[i - 1] = values_[i];

  values_.pop_back();
}

void
CwshVariable::
print() const
{
  std::cout << name_ << " ";

  int num_values = values_.size();

  if (num_values > 1)
    std::cout << '(';

  for (int i = 0; i < num_values; i++) {
    if (i > 0)
      std::cout << " ";

    std::cout << values_[i];
  }

  if (num_values > 1)
    std::cout << ')';

  std::cout << std::endl;
}

int
CwshVariablesCmp::
operator()(const CwshVariable *variable1, const CwshVariable *variable2)
{
  return (variable1->getName() < variable2->getName());
}
##concat##CwshVariableParser.cpp
#include <CwshI.h>
#include <COSProcess.h>

CwshVariableParser::
CwshVariableParser(Cwsh *cwsh, const CwshWord &word) :
 cwsh_(cwsh), word_(word)
{
}

bool
CwshVariableParser::
expandVariables(CwshWordArray &words)
{
  const CwshSubWordArray &sub_words = word_.getSubWords();

  string word1;

  int num_sub_words = sub_words.size();

  for (int i = 0; i < num_sub_words; i++) {
    CwshSubWordType type = sub_words[i].getType();

    if      (type == CWSH_SUB_WORD_TYPE_SINGLE_QUOTED) {
      string sub_word = sub_words[i].getString();

      word1 += sub_word;
    }
    else if (type == CWSH_SUB_WORD_TYPE_BACK_QUOTED) {
      string sub_word = sub_words[i].getString();

      word1 += sub_word;
    }
    else if (type == CWSH_SUB_WORD_TYPE_DOUBLE_QUOTED) {
      string sub_word =
        expandQuotedVariables(CwshWord(sub_words[i].getWord()));

      word1 += '"' + sub_word + '"';
    }
    else {
      vector<string> sub_words1;

      expandVariables1(sub_words[i].getString(), sub_words1);

      sub_words1[0] = word1 + sub_words1[0];

      int num_sub_words1 = sub_words1.size();

      for (int j = 0; j < num_sub_words1 - 1; j++)
        words.push_back(sub_words1[j]);

      word1 = sub_words1[num_sub_words1 - 1];
    }
  }

  words.push_back(word1);

  return true;
}

string
CwshVariableParser::
expandQuotedVariables(const CwshWord &word)
{
  CwshWordArray words;

  const CwshSubWordArray &sub_words = word.getSubWords();

  string word1;

  int num_sub_words = sub_words.size();

  for (int i = 0; i < num_sub_words; i++) {
    CwshSubWordType type = sub_words[i].getType();

    if      (type == CWSH_SUB_WORD_TYPE_SINGLE_QUOTED) {
      string sub_word = sub_words[i].getString();

      word1 += sub_word;
    }
    else if (type == CWSH_SUB_WORD_TYPE_BACK_QUOTED) {
      string sub_word = sub_words[i].getString();

      word1 += sub_word;
    }
    else {
      vector<string> sub_words1;

      expandVariables1(sub_words[i].getString(), sub_words1);

      int num_sub_words1 = sub_words1.size();

      for (int j = 0; j < num_sub_words1; j++)
        word1 += sub_words1[j];
    }
  }

  return word1;
}

bool
CwshVariableParser::
expandVariables1(const string &str, vector<string> &words)
{
  string word;

  int i = 0;

  int len = str.size();

  while (i < len) {
    int j = i;

    while (i < len) {
      if (str[i] == '$')
        break;

      if (str[i] == '\\' && i < len - 1)
        i++;

      i++;
    }

    word += str.substr(j, i - j);

    if (i >= len - 1)
      break;

    //------

    j = i++;

    string name;

    if (i < len && str[i] == '{') {
      i++;

      int k = i;

      while (i < len && str[i] != '}')
        i++;

      if (i >= len)
        CWSH_THROW("Missing }");

      i++;

      name = str.substr(k, i - k - 1);

      if (name == "")
        CWSH_THROW("Illegal variable name.");
    }
    else {
      int k = i;

      if (i < len && (str[i] == '#' || str[i] == '?'))
        i++;

      if      (i < len && (str[i] == '<' || str[i] == '$' || str[i] == '*'))
        i++;
      else if (i < len && isdigit(str[i])) {
        i++;

        while (i < len && isdigit(str[i]))
          i++;
      }
      else if (i < len && (isalpha(str[i]) || str[i] == '_')) {
        i++;

        while (i < len && (isalnum(str[i]) || str[i] == '_'))
          i++;

        if (i < len && str[i] == '[') {
          i++;

          while (i < len && str[i] != ']')
            i++;

          if (i >= len)
            CWSH_THROW("Newline in variable index.");

          i++;
        }
      }

      if (i < len && str[i] == ':') {
        int k = i + 1;

        if (k < len && str[k] == 'g') {
          k++;

          if (k < len &&
              (str[k] == 'r' || str[k] == 'e' ||
               str[k] == 'h' || str[k] == 't'))
            i = k + 1;
        }
        else {
          if (k < len &&
              (str[k] == 'r' || str[k] == 'e' ||
               str[k] == 'h' || str[k] == 't' ||
               str[k] == 'q' || str[k] == 'z'))
            i = k + 1;
        }
      }

      name = str.substr(k, i - k);

      if (name == "")
        continue;
    }

    vector<string> values;

    expandVariable(name, values);

    //------

    values[0] = word + values[0];

    int num_values = values.size();

    for (int k = 0; k < num_values - 1; k++)
      words.push_back(values[k]);

    word = values[num_values - 1];
  }

  words.push_back(word);

  return true;
}

bool
CwshVariableParser::
expandVariable(const string &name, vector<string> &words)
{
  if      (name[0] == '<') {
    string word = cwsh_->readLine();

    words.push_back(word);

    return true;
  }

  if (name[0] == '$') {
    int pid = COSProcess::getProcessId();

    string word = CStrUtil::toString(pid) + name.substr(1);

    words.push_back(word);

    return true;
  }

  CwshVariableValueType type = CWSH_VARIABLE_VALUE_TYPE_VALUE;

  string name1;

  if      (name[0] == '#') {
    type = CWSH_VARIABLE_VALUE_TYPE_SIZE;

    name1 = name.substr(1);

    if (name1.size() == 0) {
      string word = "0";

      words.push_back(word);

      return true;
    }
  }
  else if (name[0] == '?') {
    type = CWSH_VARIABLE_VALUE_TYPE_EXISTS;

    name1 = name.substr(1);

    if (name1.size() == 0) {
      string word = "1";

      words.push_back(word);

      return true;
    }
  }
  else
    name1 = name;

  //------

  if      (name1[0] == '*') {
    if (type == CWSH_VARIABLE_VALUE_TYPE_SIZE ||
        type == CWSH_VARIABLE_VALUE_TYPE_EXISTS)
      CWSH_THROW("* not allowed with $# or $?.");

    name1 = "argv[*]" + name1.substr(1);
  }

  //------

  if (isdigit(name1[0])) {
    int len1 = name1.size();

    int i = 1;

    while (i < len1 && isdigit(name1[i]))
      i++;

    string num_str = name1.substr(0, i);

    int num = CStrUtil::toInteger(num_str);

    if (type == CWSH_VARIABLE_VALUE_TYPE_SIZE)
      CWSH_THROW("$#<num> is not allowed.");

    if (type == CWSH_VARIABLE_VALUE_TYPE_EXISTS) {
      if (num > 0)
        CWSH_THROW("$?<num> is not allowed.");

       name1 = "argv" + name1.substr(i);
     }
     else
       name1 = "argv[" + num_str + "]" + name1.substr(i);
  }

  //------

  if (name1[0] != '_' && ! isalpha(name1[0]))
    CWSH_THROW(name1 + ": Invalid variable name.");

  //------

  int len1 = name1.size();

  int i = 1;

  while (i < len1 && (name1[i] == '_' || isalnum(name1[i])))
    i++;

  string variable_name = name1.substr(0, i);
  string subscript_str = name1.substr(i);

  //------

  vector<string> variable_values;

  CwshVariable *variable = cwsh_->lookupVariable(variable_name);

  if (variable != NULL) {
    if (type == CWSH_VARIABLE_VALUE_TYPE_EXISTS) {
      string word = "1";

      word += subscript_str;

      words.push_back(word);

      return true;
    }

    variable_values = variable->getValues();
  }
  else {
    if (type == CWSH_VARIABLE_VALUE_TYPE_EXISTS) {
      string word = "0";

      if (CEnvInst.exists(variable_name))
        word = "1";

      word += subscript_str;

      words.push_back(word);

      return true;
    }

    if (! CEnvInst.exists(variable_name))
      CWSH_THROW(variable_name + ": Undefined variable.");

    string value = CEnvInst.get(variable_name);

    vector<string> values;

    CStrUtil::addFields(value, values, ":");

    int num_values = values.size();

    for (int i = 0; i < num_values; i++)
      variable_values.push_back(values[i]);
  }

  //------

  if (type == CWSH_VARIABLE_VALUE_TYPE_SIZE) {
    string word = CStrUtil::toString((int) variable_values.size());

    word += subscript_str;

    words.push_back(word);

    return true;
  }

  //------

  int subscript_len = subscript_str.size();

  int start_value, end_value;

  if (subscript_len > 0 && subscript_str[0] == '[') {
    int i = 1;

    CStrUtil::skipSpace(subscript_str, &i);

    if (i >= subscript_len ||
        (subscript_str[i] != '*' && subscript_str[i] != '-' &&
         ! isdigit(subscript_str[i])))
      CWSH_THROW("Variable Syntax.");

    if      (subscript_str[i] == '*') {
      start_value = 1;
      end_value   = variable_values.size();

      i++;
    }
    else {
      if (isdigit(subscript_str[i])) {
        int j = i;

        i++;

        while (i < subscript_len && isdigit(subscript_str[i]))
          i++;

        string num_str = subscript_str.substr(j, i - j);

        start_value = CStrUtil::toInteger(num_str);

        int num_variable_values = variable_values.size();

        if (variable_name == "argv") {
          if (start_value <  0 || start_value > num_variable_values)
            CWSH_THROW(variable_name + ": Subscript out of range.");
        }
        else {
          if (start_value <= 0 || start_value > num_variable_values)
            CWSH_THROW(variable_name + ": Subscript out of range.");
        }

        CStrUtil::skipSpace(subscript_str, &i);
      }
      else
        start_value = -1;

      if (i < subscript_len && subscript_str[i] == '-') {
        i++;

        CStrUtil::skipSpace(subscript_str, &i);

        if (isdigit(subscript_str[i])) {
          if (start_value == -1)
            start_value = 1;

          int j = i;

          i++;

          while (i < subscript_len && isdigit(subscript_str[i]))
            i++;

          string num_str = subscript_str.substr(j, i - j);

          end_value = CStrUtil::toInteger(num_str);

          int num_variable_values = variable_values.size();

          if (end_value <= 0 || end_value > num_variable_values)
            CWSH_THROW(variable_name + ": Subscript out of range.");
        }
        else {
          if (start_value == -1)
            CWSH_THROW("Variable Syntax.");

          end_value = variable_values.size();
        }
      }
      else
        end_value = start_value;
    }

    CStrUtil::skipSpace(subscript_str, &i);

    if (i < subscript_len && subscript_str[i] != ']')
      CWSH_THROW("Variable Syntax.");

    i++;

    if (start_value > end_value)
      CWSH_THROW(variable_name + ": Invalid subscript range.");

    subscript_str = subscript_str.substr(i);

    subscript_len = subscript_str.size();
  }
  else {
    start_value = 1;
    end_value   = variable_values.size();
  }

  CwshVariableValueModifier modifier = CWSH_VARIABLE_VALUE_MODIFIER_NONE;

  bool modifier_global = false;

  if (subscript_len > 0 && subscript_str[0] == ':') {
    int i = 1;

    if (i >= subscript_len)
      CWSH_THROW("Variable Syntax.");

    if (i < subscript_len - 1 &&
        subscript_str[i] == 'g' &&
        (subscript_str[i + 1] == 'r' || subscript_str[i + 1] == 'e' ||
         subscript_str[i + 1] == 'h' || subscript_str[i + 1] == 't')) {
      i++;

      modifier_global = true;
    }

    switch (subscript_str[i]) {
      case 'r':
        modifier = CWSH_VARIABLE_VALUE_MODIFIER_ROOT;
        break;
      case 'e':
        modifier = CWSH_VARIABLE_VALUE_MODIFIER_EXTENSION;
        break;
      case 'h':
        modifier = CWSH_VARIABLE_VALUE_MODIFIER_HEADER;
        break;
      case 't':
        modifier = CWSH_VARIABLE_VALUE_MODIFIER_TAIL;
        break;
      case 'q':
        modifier = CWSH_VARIABLE_VALUE_MODIFIER_QUOTE_WORDLIST;
        break;
      case 'x':
        modifier = CWSH_VARIABLE_VALUE_MODIFIER_QUOTE_WORD;
        break;
      default:
        CWSH_THROW(string("Bad : modifier in $ (") + subscript_str[i] + ").");
        break;
    }

    i++;

    subscript_str = subscript_str.substr(i);
  }

  vector<string> values;

  if (start_value == 0) {
    values.push_back(cwsh_->getArgv0());

    start_value++;
  }

  int num_variable_values = variable_values.size();

  for (i = start_value; i <= end_value; i++) {
    if      (i >= 1 && i <= num_variable_values)
      values.push_back(variable_values[i - 1]);
    else if (i == 0)
      values.push_back(cwsh_->getName());
    else
      values.push_back("");
  }

  if      (modifier == CWSH_VARIABLE_VALUE_MODIFIER_ROOT ||
           modifier == CWSH_VARIABLE_VALUE_MODIFIER_EXTENSION ||
           modifier == CWSH_VARIABLE_VALUE_MODIFIER_HEADER ||
           modifier == CWSH_VARIABLE_VALUE_MODIFIER_TAIL) {
    int num_values = values.size();

    for (int i = 0; i < num_values; i++) {
      if      (modifier == CWSH_VARIABLE_VALUE_MODIFIER_ROOT) {
        string::size_type pos = values[i].rfind('.');

        if (pos != string::npos)
          values[i] = values[i].substr(0, pos);
      }
      else if (modifier == CWSH_VARIABLE_VALUE_MODIFIER_EXTENSION) {
        string::size_type pos = values[i].rfind('.');

        if (pos != string::npos)
          values[i] = values[i].substr(pos + 1);
      }
      else if (modifier == CWSH_VARIABLE_VALUE_MODIFIER_HEADER) {
        string::size_type pos = values[i].rfind('/');

        if (pos != string::npos)
          values[i] = values[i].substr(0, pos);
      }
      else if (modifier == CWSH_VARIABLE_VALUE_MODIFIER_TAIL) {
        string::size_type pos = values[i].rfind('/');

        if (pos != string::npos)
          values[i] = values[i].substr(pos + 1);
      }

      if (! modifier_global)
        break;
    }
  }
  else if (modifier == CWSH_VARIABLE_VALUE_MODIFIER_QUOTE_WORDLIST ||
           modifier == CWSH_VARIABLE_VALUE_MODIFIER_QUOTE_WORD) {
    string value;

    int num_values = values.size();

    for (int i = 0; i < num_values; i++) {
      if (i > 0)
        value += " ";

      value += values[i];
    }

    values.clear();

    values.push_back(value);
  }

  if (values.size() == 0)
    values.push_back("");

  values[0] += subscript_str;

  copy(values.begin(), values.end(), back_inserter(words));

  return true;
}
##concat##CwshWildCard.cpp
#include <CwshI.h>
#include <CGlob.h>

CwshWildCard::
CwshWildCard(const string &pattern)
{
  glob_ = new CGlob(pattern);

  glob_->setAllowOr(false);
  glob_->setAllowNonPrintable(true);
}

CwshWildCard::
~CwshWildCard()
{
}

bool
CwshWildCard::
isValid() const
{
  return glob_->isPattern();
}

bool
CwshWildCard::
checkMatch(const string &str) const
{
  return glob_->compare(str);
}
##concat##CwshWord.cpp
#include <CwshI.h>

void
CwshWord::
toWords(const string &line, CwshWordArray &words)
{
  vector<string> words1;

  CwshString::addWords(line, words1);

  int num_words1 = words1.size();

  for (int i = 0; i < num_words1; i++) {
    const string &word = words1[i];

    words.push_back(CwshWord(word));
  }
}

string
CwshWord::
toString(const CwshWordArray &words)
{
  string str;

  int num_words = words.size();

  for (int i = 0; i < num_words; i++) {
    if (i > 0)
      str += " ";

    str += words[i].getWord();
  }

  return str;
}

string
CwshWord::
toString(const CwshSubWordArray &sub_words)
{
  string str;

  int num_sub_words = sub_words.size();

  for (int i = 0; i < num_sub_words; i++)
    str += sub_words[i].getString();

  return str;
}

void
CwshWord::
printWords(const CwshWordArray &words)
{
  int num_words = words.size();

  for (int i = 0; i < num_words; i++) {
    if (i > 0)
      std::cerr << " ";

    std::cerr << "'" << words[i] << "'";
  }

  std::cerr << std::endl;
}

void
CwshWord::
printWord(const CwshWord &word)
{
  std::cerr << word << std::endl;
}

CwshWord::
CwshWord(const string &word) :
 word_(word)
{
  sub_words_created_ = false;
}

const CwshSubWordArray &
CwshWord::
getSubWords() const
{
  if (! sub_words_created_) {
    CwshWord *th = const_cast<CwshWord *>(this);

    th->createSubWords();
  }

  return sub_words_;
}

void
CwshWord::
createSubWords()
{
  uint len = word_.size();

  string sub_word;

  uint i = 0;

  while (i < len) {
    uint i1 = i;

    while (i < len && word_[i] != '\"' && word_[i] != '\'' && word_[i] != '`')
      i++;

    if (i > i1) {
      sub_word = word_.substr(i1, i - i1);

      sub_words_.push_back(CwshSubWord(sub_word));
    }

    if (i >= len)
      break;

    if (word_[i] == '\"') {
      uint i1 = i + 1;

      if (! CStrUtil::skipDoubleQuotedString(word_, &i))
        CWSH_THROW("Unmatched \".");

      sub_word = word_.substr(i1, i - i1 - 1);

      sub_words_.push_back(
       CwshSubWord(sub_word, CWSH_SUB_WORD_TYPE_DOUBLE_QUOTED));
    }
    else if (word_[i] == '\'') {
      uint i1 = i + 1;

      if (! CStrUtil::skipSingleQuotedString(word_, &i))
        CWSH_THROW("Unmatched \'.");

      sub_word = word_.substr(i1, i - i1 - 1);

      sub_words_.push_back(
       CwshSubWord(sub_word, CWSH_SUB_WORD_TYPE_SINGLE_QUOTED));
    }
    else if (word_[i] == '`') {
      uint i1 = i + 1;

      if (! CStrUtil::skipBackQuotedString(word_, &i))
        CWSH_THROW("Unmatched `.");

      sub_word = word_.substr(i1, i - i1 - 1);

      sub_words_.push_back(
       CwshSubWord(sub_word, CWSH_SUB_WORD_TYPE_BACK_QUOTED));
    }
  }

  sub_words_created_ = true;
}

void
CwshWord::
removeQuotes()
{
  const CwshSubWordArray &sub_words = getSubWords();

  string str;

  int num_sub_words = sub_words.size();

  for (int i = 0; i < num_sub_words; i++)
    str += sub_words[i].getWord();

  word_ = str;

  sub_words_.clear();

  sub_words_created_ = false;
}

ostream &
operator<<(ostream &os, const CwshWord &word)
{
  os << ">>" << word.word_ << "<<";

  return os;
}

CwshSubWord::
CwshSubWord(const string &word, CwshSubWordType type) :
 word_(word), type_(type)
{
}

string
CwshSubWord::
getString() const
{
  if      (type_ == CWSH_SUB_WORD_TYPE_SINGLE_QUOTED)
    return "'" + word_ + "'";
  else if (type_ == CWSH_SUB_WORD_TYPE_DOUBLE_QUOTED)
    return "\"" + word_ + "\"";
  else if (type_ == CWSH_SUB_WORD_TYPE_BACK_QUOTED)
    return "`" + word_ + "`";
  else
    return word_;
}

ostream &
operator<<(ostream &os, const CwshSubWord &sub_word)
{
  os << ">>" << sub_word.getString() << "<<";

  return os;
}
